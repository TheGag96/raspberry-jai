diff --git a/modules/Atomics.jai b/modules/Atomics.jai
index 8efeffa..fccdf04 100644
--- a/modules/Atomics.jai
+++ b/modules/Atomics.jai
@@ -36,13 +36,26 @@ compare_and_swap2 :: (dest: *void, old_value_1: $T1_64, old_value_2: $T2_64, new
     actual_old_2 := old_value_2;
 
     success: bool = ---;
-    #asm {
-        old_value_1 === a;
-        old_value_2 === d;
-        new_value_1 === b;
-        new_value_2 === c;
-        lock_cmpxchg16b  old_value_2, old_value_1, [dest], new_value_2, new_value_1;
-        setz success;
+    #if CPU == .X64 {
+        #asm {
+            old_value_1 === a;
+            old_value_2 === d;
+            new_value_1 === b;
+            new_value_2 === c;
+            lock_cmpxchg16b  old_value_2, old_value_1, [dest], new_value_2, new_value_1;
+            setz success;
+        }
+    }
+    else {
+        // @Hack: This is not atomic!!!!!!
+        if (old_value_1 == new_value_1 && old_value_2 == new_value_2) {
+            (cast(*T1_64)dest)[0] = new_value_1;
+            (cast(*T2_64)dest)[1] = new_value_2;
+            success = true;
+        }
+        else {
+            success = false;
+        }
     }
 
     return success;
diff --git a/modules/Bindings_Generator/module.jai b/modules/Bindings_Generator/module.jai
index 0080275..24bed4a 100644
--- a/modules/Bindings_Generator/module.jai
+++ b/modules/Bindings_Generator/module.jai
@@ -145,6 +145,7 @@ RESERVED_NAMES :: string.[
     "cast",
     "context",
     "false",
+    "interface",
     "is_constant",
     "null",
     "remove",
diff --git a/modules/POSIX/bindings/linux/arm64/base.jai b/modules/POSIX/bindings/linux/arm64/base.jai
new file mode 100644
index 0000000..547f1f3
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/base.jai
@@ -0,0 +1,2796 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+RTLD_LAZY :: 0x00001;
+RTLD_NOW :: 0x00002;
+RTLD_BINDING_MASK :: 0x3;
+RTLD_NOLOAD :: 0x00004;
+RTLD_DEEPBIND :: 0x00008;
+
+RTLD_GLOBAL :: 0x00100;
+
+RTLD_LOCAL :: 0;
+
+RTLD_NODELETE :: 0x01000;
+
+LM_ID_BASE :: 0;
+LM_ID_NEWLM :: -1;
+
+RTLD_NEXT :: cast,trunc(*void) -1;
+
+RTLD_DEFAULT :: cast(*void) 0;
+
+__S32_TYPE :: s32;
+
+__SLONG32_TYPE :: s32;
+
+_DIRENT_MATCHES_DIRENT64 :: 1;
+
+EPERM :: 1;
+ENOENT :: 2;
+ESRCH :: 3;
+EINTR :: 4;
+EIO :: 5;
+ENXIO :: 6;
+E2BIG :: 7;
+ENOEXEC :: 8;
+EBADF :: 9;
+ECHILD :: 10;
+EAGAIN :: 11;
+ENOMEM :: 12;
+EACCES :: 13;
+EFAULT :: 14;
+ENOTBLK :: 15;
+EBUSY :: 16;
+EEXIST :: 17;
+EXDEV :: 18;
+ENODEV :: 19;
+ENOTDIR :: 20;
+EISDIR :: 21;
+EINVAL :: 22;
+ENFILE :: 23;
+EMFILE :: 24;
+ENOTTY :: 25;
+ETXTBSY :: 26;
+EFBIG :: 27;
+ENOSPC :: 28;
+ESPIPE :: 29;
+EROFS :: 30;
+EMLINK :: 31;
+EPIPE :: 32;
+EDOM :: 33;
+ERANGE :: 34;
+
+EDEADLK :: 35;
+ENAMETOOLONG :: 36;
+ENOLCK :: 37;
+
+ENOSYS :: 38;
+
+ENOTEMPTY :: 39;
+ELOOP :: 40;
+EWOULDBLOCK :: EAGAIN;
+ENOMSG :: 42;
+EIDRM :: 43;
+ECHRNG :: 44;
+EL2NSYNC :: 45;
+EL3HLT :: 46;
+EL3RST :: 47;
+ELNRNG :: 48;
+EUNATCH :: 49;
+ENOCSI :: 50;
+EL2HLT :: 51;
+EBADE :: 52;
+EBADR :: 53;
+EXFULL :: 54;
+ENOANO :: 55;
+EBADRQC :: 56;
+EBADSLT :: 57;
+
+EDEADLOCK :: EDEADLK;
+
+EBFONT :: 59;
+ENOSTR :: 60;
+ENODATA :: 61;
+ETIME :: 62;
+ENOSR :: 63;
+ENONET :: 64;
+ENOPKG :: 65;
+EREMOTE :: 66;
+ENOLINK :: 67;
+EADV :: 68;
+ESRMNT :: 69;
+ECOMM :: 70;
+EPROTO :: 71;
+EMULTIHOP :: 72;
+EDOTDOT :: 73;
+EBADMSG :: 74;
+EOVERFLOW :: 75;
+ENOTUNIQ :: 76;
+EBADFD :: 77;
+EREMCHG :: 78;
+ELIBACC :: 79;
+ELIBBAD :: 80;
+ELIBSCN :: 81;
+ELIBMAX :: 82;
+ELIBEXEC :: 83;
+EILSEQ :: 84;
+ERESTART :: 85;
+ESTRPIPE :: 86;
+EUSERS :: 87;
+ENOTSOCK :: 88;
+EDESTADDRREQ :: 89;
+EMSGSIZE :: 90;
+EPROTOTYPE :: 91;
+ENOPROTOOPT :: 92;
+EPROTONOSUPPORT :: 93;
+ESOCKTNOSUPPORT :: 94;
+EOPNOTSUPP :: 95;
+EPFNOSUPPORT :: 96;
+EAFNOSUPPORT :: 97;
+EADDRINUSE :: 98;
+EADDRNOTAVAIL :: 99;
+ENETDOWN :: 100;
+ENETUNREACH :: 101;
+ENETRESET :: 102;
+ECONNABORTED :: 103;
+ECONNRESET :: 104;
+ENOBUFS :: 105;
+EISCONN :: 106;
+ENOTCONN :: 107;
+ESHUTDOWN :: 108;
+ETOOMANYREFS :: 109;
+ETIMEDOUT :: 110;
+ECONNREFUSED :: 111;
+EHOSTDOWN :: 112;
+EHOSTUNREACH :: 113;
+EALREADY :: 114;
+EINPROGRESS :: 115;
+ESTALE :: 116;
+EUCLEAN :: 117;
+ENOTNAM :: 118;
+ENAVAIL :: 119;
+EISNAM :: 120;
+EREMOTEIO :: 121;
+EDQUOT :: 122;
+
+ENOMEDIUM :: 123;
+EMEDIUMTYPE :: 124;
+ECANCELED :: 125;
+ENOKEY :: 126;
+EKEYEXPIRED :: 127;
+EKEYREVOKED :: 128;
+EKEYREJECTED :: 129;
+
+EOWNERDEAD :: 130;
+ENOTRECOVERABLE :: 131;
+
+ERFKILL :: 132;
+
+EHWPOISON :: 133;
+
+ENOTSUP :: EOPNOTSUPP;
+
+FNM_PATHNAME :: 1 << 0;
+FNM_NOESCAPE :: 1 << 1;
+FNM_PERIOD :: 1 << 2;
+
+FNM_FILE_NAME :: FNM_PATHNAME;
+FNM_LEADING_DIR :: 1 << 3;
+FNM_CASEFOLD :: 1 << 4;
+FNM_EXTMATCH :: 1 << 5;
+
+FNM_NOMATCH :: 1;
+
+FNM_NOSYS :: -1;
+
+NSS_BUFLEN_PASSWD :: 1024;
+
+SIG_ERR :: cast(#type (unknown0: s32) -> void #c_call) -1;
+SIG_DFL :: cast(#type (unknown0: s32) -> void #c_call) 0;
+SIG_IGN :: cast(#type (unknown0: s32) -> void #c_call) 1;
+
+SIG_HOLD :: cast(#type (unknown0: s32) -> void #c_call) 2;
+
+SIGINT :: 2;
+SIGILL :: 4;
+SIGABRT :: 6;
+SIGFPE :: 8;
+SIGSEGV :: 11;
+SIGTERM :: 15;
+
+SIGHUP :: 1;
+SIGQUIT :: 3;
+SIGTRAP :: 5;
+SIGKILL :: 9;
+SIGPIPE :: 13;
+SIGALRM :: 14;
+
+SIGIOT :: SIGABRT;
+
+_STRUCT_TIMESPEC :: 1;
+
+__SIGEV_MAX_SIZE :: 64;
+
+SA_NOCLDSTOP :: 1;
+SA_NOCLDWAIT :: 2;
+SA_SIGINFO :: 4;
+
+SA_ONSTACK :: 0x08000000;
+
+SA_RESTART :: 0x10000000;
+SA_NODEFER :: 0x40000000;
+
+SA_RESETHAND :: 0x80000000;
+
+SA_INTERRUPT :: 0x20000000;
+
+SA_NOMASK :: SA_NODEFER;
+SA_ONESHOT :: SA_RESETHAND;
+SA_STACK :: SA_ONSTACK;
+
+SIG_BLOCK :: 0;
+SIG_UNBLOCK :: 1;
+SIG_SETMASK :: 2;
+
+__FD_SETSIZE :: 1024;
+
+__BIT_TYPES_DEFINED__ :: 1;
+
+__POSIX2_THIS_VERSION :: 200809;
+
+_XOPEN_VERSION :: 700;
+
+_XOPEN_XCU_VERSION :: 4;
+
+_XOPEN_XPG2 :: 1;
+_XOPEN_XPG3 :: 1;
+_XOPEN_XPG4 :: 1;
+
+_XOPEN_UNIX :: 1;
+
+_XOPEN_ENH_I18N :: 1;
+
+_XOPEN_LEGACY :: 1;
+
+STDIN_FILENO :: 0;
+STDOUT_FILENO :: 1;
+STDERR_FILENO :: 2;
+
+L_SET :: SEEK_SET;
+L_INCR :: SEEK_CUR;
+L_XTND :: SEEK_END;
+
+IPC_CREAT :: 0x200 /* 01000 */;
+IPC_EXCL :: 0x400 /* 02000 */;
+IPC_NOWAIT :: 0x800 /* 04000 */;
+
+IPC_RMID :: 0;
+IPC_SET :: 1;
+IPC_STAT :: 2;
+
+IPC_INFO :: 3;
+
+IPC_PRIVATE :: cast(s32) 0;
+
+PROT_BTI :: 0x10;
+PROT_MTE :: 0x20;
+
+PROT_READ :: 0x1;
+PROT_WRITE :: 0x2;
+PROT_EXEC :: 0x4;
+PROT_NONE :: 0x0;
+PROT_GROWSDOWN :: 0x01000000;
+
+PROT_GROWSUP :: 0x02000000;
+
+MAP_SHARED :: 0x01;
+MAP_PRIVATE :: 0x02;
+
+MAP_SHARED_VALIDATE :: 0x03;
+
+MAP_TYPE :: 0x0f;
+
+MAP_FIXED :: 0x10;
+
+MAP_FILE :: 0;
+
+MAP_ANONYMOUS :: 0x20;
+
+MAP_ANON :: MAP_ANONYMOUS;
+
+MAP_HUGE_SHIFT :: 26;
+MAP_HUGE_MASK :: 0x3f;
+
+MS_ASYNC :: 1;
+MS_SYNC :: 4;
+MS_INVALIDATE :: 2;
+
+MADV_NORMAL :: 0;
+MADV_RANDOM :: 1;
+MADV_SEQUENTIAL :: 2;
+MADV_WILLNEED :: 3;
+MADV_DONTNEED :: 4;
+MADV_FREE :: 8;
+MADV_REMOVE :: 9;
+MADV_DONTFORK :: 10;
+MADV_DOFORK :: 11;
+MADV_MERGEABLE :: 12;
+MADV_UNMERGEABLE :: 13;
+MADV_HUGEPAGE :: 14;
+MADV_NOHUGEPAGE :: 15;
+MADV_DONTDUMP :: 16;
+
+MADV_DODUMP :: 17;
+MADV_WIPEONFORK :: 18;
+MADV_KEEPONFORK :: 19;
+MADV_COLD :: 20;
+MADV_PAGEOUT :: 21;
+MADV_POPULATE_READ :: 22;
+
+MADV_POPULATE_WRITE :: 23;
+
+MADV_DONTNEED_LOCKED :: 24;
+
+MADV_HWPOISON :: 100;
+
+MCL_CURRENT :: 1;
+MCL_FUTURE :: 2;
+
+MCL_ONFAULT :: 4;
+
+MAP_FAILED :: cast,trunc(*void) -1;
+
+POLLIN :: 0x001;
+POLLPRI :: 0x002;
+POLLOUT :: 0x004;
+
+POLLRDNORM :: 0x040;
+POLLRDBAND :: 0x080;
+POLLWRNORM :: 0x100;
+POLLWRBAND :: 0x200;
+
+POLLMSG :: 0x400;
+POLLREMOVE :: 0x1000;
+POLLRDHUP :: 0x2000;
+
+POLLERR :: 0x008;
+POLLHUP :: 0x010;
+POLLNVAL :: 0x020;
+
+SHM_R :: 0x100 /* 0400 */;
+SHM_W :: 0x80 /* 0200 */;
+
+SHM_RDONLY :: 0x1000 /* 010000 */;
+SHM_RND :: 0x2000 /* 020000 */;
+SHM_REMAP :: 0x4000 /* 040000 */;
+SHM_EXEC :: 0x8000 /* 0100000 */;
+
+SHM_LOCK :: 11;
+SHM_UNLOCK :: 12;
+
+SHM_STAT :: 13;
+SHM_INFO :: 14;
+SHM_STAT_ANY :: 15;
+
+SHM_DEST :: 0x200 /* 01000 */;
+SHM_LOCKED :: 0x400 /* 02000 */;
+SHM_HUGETLB :: 0x800 /* 04000 */;
+SHM_NORESERVE :: 0x1000 /* 010000 */;
+
+WNOHANG :: 1;
+WUNTRACED :: 2;
+
+WSTOPPED :: 2;
+WEXITED :: 4;
+WCONTINUED :: 8;
+WNOWAIT :: 0x01000000;
+
+__WNOTHREAD :: 0x20000000;
+
+__WALL :: 0x40000000;
+__WCLONE :: 0x80000000;
+
+WAIT_ANY :: -1;
+WAIT_MYPGRP :: 0;
+
+CLOCKS_PER_SEC :: cast(s64) 1000000;
+
+clockid_t :: enum u32 {
+    REALTIME           :: 0;
+
+    MONOTONIC          :: 1;
+
+    PROCESS_CPUTIME_ID :: 2;
+
+    THREAD_CPUTIME_ID  :: 3;
+
+    MONOTONIC_RAW      :: 4;
+
+    REALTIME_COARSE    :: 5;
+
+    MONOTONIC_COARSE   :: 6;
+
+    BOOTTIME           :: 7;
+
+    REALTIME_ALARM     :: 8;
+
+    BOOTTIME_ALARM     :: 9;
+
+    TAI                :: 11;
+
+    CLOCK_REALTIME           :: REALTIME;
+
+    CLOCK_MONOTONIC          :: MONOTONIC;
+
+    CLOCK_PROCESS_CPUTIME_ID :: PROCESS_CPUTIME_ID;
+
+    CLOCK_THREAD_CPUTIME_ID  :: THREAD_CPUTIME_ID;
+
+    CLOCK_MONOTONIC_RAW      :: MONOTONIC_RAW;
+
+    CLOCK_REALTIME_COARSE    :: REALTIME_COARSE;
+
+    CLOCK_MONOTONIC_COARSE   :: MONOTONIC_COARSE;
+
+    CLOCK_BOOTTIME           :: BOOTTIME;
+
+    CLOCK_REALTIME_ALARM     :: REALTIME_ALARM;
+
+    CLOCK_BOOTTIME_ALARM     :: BOOTTIME_ALARM;
+
+    CLOCK_TAI                :: TAI;
+}
+
+TIMER_ABSTIME :: 1;
+
+TIME_UTC :: 1;
+
+_dl_mcount_wrapper_check :: (__selfpc: *void) -> void #foreign libc;
+
+/* Type for namespace indices.  */
+Lmid_t :: s64;
+
+/* Open the shared object FILE and map it in; return a handle that can be
+passed to `dlsym' to get symbol values from it.  */
+dlopen :: (__file: *u8, __mode: s32) -> *void #foreign libc;
+
+/* Unmap and close a shared object opened by `dlopen'.
+The handle cannot be used again after calling `dlclose'.  */
+dlclose :: (__handle: *void) -> s32 #foreign libc;
+
+/* Find the run-time address in the shared object HANDLE refers to
+of the symbol called NAME.  */
+dlsym :: (__handle: *void, __name: *u8) -> *void #foreign libc;
+
+/* Like `dlopen', but request object to be allocated in a new namespace.  */
+dlmopen :: (__nsid: Lmid_t, __file: *u8, __mode: s32) -> *void #foreign libc;
+
+/* Find the run-time address in the shared object HANDLE refers to
+of the symbol called NAME with VERSION.  */
+dlvsym :: (__handle: *void, __name: *u8, __version: *u8) -> *void #foreign libc;
+
+/* When any of the above functions fails, call this function
+to return a string describing the error.  Each call resets
+the error string so that a following call returns null.  */
+dlerror :: () -> *u8 #foreign libc;
+
+/* Structure containing information about object searched using
+`dladdr'.  */
+Dl_info :: struct {
+    dli_fname: *u8; /* File name of defining object.  */
+    dli_fbase: *void; /* Load address of that object.  */
+    dli_sname: *u8; /* Name of nearest symbol.  */
+    dli_saddr: *void; /* Exact value of nearest symbol.  */
+}
+
+/* Fill in *INFO with the following information about ADDRESS.
+Returns 0 iff no shared object's segments contain that address.  */
+dladdr :: (__address: *void, __info: *Dl_info) -> s32 #foreign libc;
+
+/* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  */
+dladdr1 :: (__address: *void, __info: *Dl_info, __extra_info: **void, __flags: s32) -> s32 #foreign libc;
+
+/* These are the possible values for the FLAGS argument to `dladdr1'.
+This indicates what extra information is stored at *EXTRA_INFO.
+It may also be zero, in which case the EXTRA_INFO argument is not used.  */
+RTLD_DL :: enum u32 {
+    SYMENT  :: 1;
+
+    LINKMAP :: 2;
+
+    RTLD_DL_SYMENT  :: SYMENT;
+
+    RTLD_DL_LINKMAP :: LINKMAP;
+}
+
+/* Get information about the shared object HANDLE refers to.
+REQUEST is from among the values below, and determines the use of ARG.
+
+On success, returns zero.  On failure, returns -1 and records an error
+message to be fetched with `dlerror'.  */
+dlinfo :: (__handle: *void, __request: s32, __arg: *void) -> s32 #foreign libc;
+
+/* These are the possible values for the REQUEST argument to `dlinfo'.  */
+RTLD_DI :: enum u32 {
+    LMID        :: 1;
+
+    LINKMAP     :: 2;
+
+    CONFIGADDR  :: 3;
+
+    SERINFO     :: 4;
+    SERINFOSIZE :: 5;
+
+    ORIGIN      :: 6;
+
+    PROFILENAME :: 7;
+    PROFILEOUT  :: 8;
+
+    TLS_MODID   :: 9;
+
+    TLS_DATA    :: 10;
+
+    PHDR        :: 11;
+
+    MAX         :: 11;
+
+    RTLD_DI_LMID        :: LMID;
+
+    RTLD_DI_LINKMAP     :: LINKMAP;
+
+    RTLD_DI_CONFIGADDR  :: CONFIGADDR;
+
+    RTLD_DI_SERINFO     :: SERINFO;
+    RTLD_DI_SERINFOSIZE :: SERINFOSIZE;
+
+    RTLD_DI_ORIGIN      :: ORIGIN;
+
+    RTLD_DI_PROFILENAME :: PROFILENAME;
+    RTLD_DI_PROFILEOUT  :: PROFILEOUT;
+
+    RTLD_DI_TLS_MODID   :: TLS_MODID;
+
+    RTLD_DI_TLS_DATA    :: TLS_DATA;
+
+    RTLD_DI_PHDR        :: PHDR;
+
+    RTLD_DI_MAX         :: MAX;
+}
+
+/* This is the type of elements in `Dl_serinfo', below.
+The `dls_name' member points to space in the buffer passed to `dlinfo'.  */
+Dl_serpath :: struct {
+    dls_name:  *u8; /* Name of library search path directory.  */
+    dls_flags: u32; /* Indicates where this directory came from. */
+}
+
+/* This is the structure that must be passed (by reference) to `dlinfo' for
+the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  */
+Dl_serinfo :: struct {
+    dls_size: u64; /* Size in bytes of the whole buffer.  */
+    dls_cnt:  u32; /* Number of elements in `dls_serpath'.  */
+
+    /* The zero-length array avoids an unwanted array subscript check by
+    the compiler, while the surrounding anonymous union preserves the
+    historic size of the type.  At the time of writing, GNU C does
+    not support structs with flexible array members in unions.  */
+    union {
+        dls_serpath:       [0] Dl_serpath; /* Actually longer, dls_cnt elements.  */
+        __dls_serpath_pad: [1] Dl_serpath;
+    }
+}
+
+dl_find_object :: struct {
+    dlfo_flags:      u64;
+    dlfo_map_start:  *void; /* Beginning of mapping containing address.  */
+    dlfo_map_end:    *void; /* End of mapping.  */
+    link_map :: struct {}
+    dlfo_link_map:   *link_map;
+    dlfo_eh_frame:   *void; /* Exception handling data of the object.  */
+
+    __dflo_reserved: [7] u64;
+}
+
+/* If ADDRESS is found in an object, fill in *RESULT and return 0.
+Otherwise, return -1.  */
+_dl_find_object :: (__address: *void, __result: *dl_find_object) -> s32 #foreign libc;
+
+__fsid_t :: struct {
+    __val: [2] s32;
+}
+
+ino64_t :: u64;
+
+dirent :: struct {
+    d_ino:    u64;
+    d_off:    s64;
+
+    d_reclen: u16;
+    d_type:   DT;
+    d_name:   [256] u8;
+}
+
+dirent64 :: struct {
+    d_ino:    u64;
+    d_off:    s64;
+    d_reclen: u16;
+    d_type:   DT;
+    d_name:   [256] u8;
+}
+
+/* File types for `d_type'.  */
+DT :: enum u8 {
+    UNKNOWN :: 0;
+
+    FIFO    :: 1;
+
+    CHR     :: 2;
+
+    DIR     :: 4;
+
+    BLK     :: 6;
+
+    REG     :: 8;
+
+    LNK     :: 10;
+
+    SOCK    :: 12;
+
+    WHT     :: 14;
+}
+
+__dirstream :: struct {}
+/* This is the data type of directory stream objects.
+The actual structure is opaque to users.  */
+DIR :: __dirstream;
+
+/* Close the directory stream DIRP.
+Return 0 if successful, -1 if not.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+closedir :: (__dirp: *DIR) -> s32 #foreign libc;
+
+/* Open a directory stream on NAME.
+Return a DIR stream on the directory, or NULL if it could not be opened.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+opendir :: (__name: *u8) -> *DIR #foreign libc;
+
+/* Same as opendir, but open the stream on the file descriptor FD.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fdopendir :: (__fd: s32) -> *DIR #foreign libc;
+
+readdir :: (__dirp: *DIR) -> *dirent #foreign libc;
+
+readdir64 :: (__dirp: *DIR) -> *dirent64 #foreign libc;
+
+readdir_r :: (__dirp: *DIR, __entry: *dirent, __result: **dirent) -> s32 #foreign libc;
+
+readdir64_r :: (__dirp: *DIR, __entry: *dirent64, __result: **dirent64) -> s32 #foreign libc;
+
+/* Rewind DIRP to the beginning of the directory.  */
+rewinddir :: (__dirp: *DIR) -> void #foreign libc;
+
+/* Seek to position POS on DIRP.  */
+seekdir :: (__dirp: *DIR, __pos: s64) -> void #foreign libc;
+
+/* Return the current position of DIRP.  */
+telldir :: (__dirp: *DIR) -> s64 #foreign libc;
+
+/* Return the file descriptor used by DIRP.  */
+dirfd :: (__dirp: *DIR) -> s32 #foreign libc;
+
+scandir :: (__dir: *u8, __namelist: ***dirent, __selector: #type (unknown0: *dirent) -> s32 #c_call, __cmp: #type (unknown0: **dirent, unknown1: **dirent) -> s32 #c_call) -> s32 #foreign libc;
+
+/* This function is like `scandir' but it uses the 64bit dirent structure.
+Please note that the CMP function must now work with struct dirent64 **.  */
+scandir64 :: (__dir: *u8, __namelist: ***dirent64, __selector: #type (unknown0: *dirent64) -> s32 #c_call, __cmp: #type (unknown0: **dirent64, unknown1: **dirent64) -> s32 #c_call) -> s32 #foreign libc;
+
+scandirat :: (__dfd: s32, __dir: *u8, __namelist: ***dirent, __selector: #type (unknown0: *dirent) -> s32 #c_call, __cmp: #type (unknown0: **dirent, unknown1: **dirent) -> s32 #c_call) -> s32 #foreign libc;
+
+/* This function is like `scandir' but it uses the 64bit dirent structure.
+Please note that the CMP function must now work with struct dirent64 **.  */
+scandirat64 :: (__dfd: s32, __dir: *u8, __namelist: ***dirent64, __selector: #type (unknown0: *dirent64) -> s32 #c_call, __cmp: #type (unknown0: **dirent64, unknown1: **dirent64) -> s32 #c_call) -> s32 #foreign libc;
+
+alphasort :: (__e1: **dirent, __e2: **dirent) -> s32 #foreign libc;
+
+alphasort64 :: (__e1: **dirent64, __e2: **dirent64) -> s32 #foreign libc;
+
+getdirentries :: (__fd: s32, __buf: *u8, __nbytes: u64, __basep: *s64) -> s64 #foreign libc;
+
+getdirentries64 :: (__fd: s32, __buf: *u8, __nbytes: u64, __basep: *s64) -> s64 #foreign libc;
+
+versionsort :: (__e1: **dirent, __e2: **dirent) -> s32 #foreign libc;
+
+versionsort64 :: (__e1: **dirent64, __e2: **dirent64) -> s32 #foreign libc;
+
+/* The error code set by various library functions.  */
+__errno_location :: () -> *OS_Error_Code #foreign libc;
+
+/* The full and simple forms of the name with which the program was
+invoked.  These variables are set up automatically at startup based on
+the value of argv[0].  */
+program_invocation_name: *u8 #elsewhere libc;
+program_invocation_short_name: *u8 #elsewhere libc;
+
+/* Store up to SIZE return address of the current program state in
+ARRAY and return the exact number of values stored.  */
+backtrace :: (__array: **void, __size: s32) -> s32 #foreign libc;
+
+/* Return names of functions from the backtrace list in ARRAY in a newly
+malloc()ed memory block.  */
+backtrace_symbols :: (__array: **void, __size: s32) -> **u8 #foreign libc;
+
+/* This function is similar to backtrace_symbols() but it writes the result
+immediately to a file.  */
+backtrace_symbols_fd :: (__array: **void, __size: s32, __fd: s32) -> void #foreign libc;
+
+/* Match NAME against the filename pattern PATTERN,
+returning zero if it matches, FNM_NOMATCH if not.  */
+fnmatch :: (__pattern: *u8, __name: *u8, __flags: s32) -> s32 #foreign libc;
+
+/* A record in the user database.  */
+passwd :: struct {
+    pw_name:   *u8; /* Username.  */
+    /* Hashed passphrase, if shadow database
+    not in use (see shadow.h).  */
+    pw_passwd: *u8;
+
+    pw_uid:    u32; /* User ID.  */
+    pw_gid:    u32; /* Group ID.  */
+    pw_gecos:  *u8; /* Real name.  */
+    pw_dir:    *u8; /* Home directory.  */
+    pw_shell:  *u8; /* Shell program.  */
+}
+
+/* Rewind the user database stream.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+setpwent :: () -> void #foreign libc;
+
+/* Close the user database stream.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+endpwent :: () -> void #foreign libc;
+
+/* Read an entry from the user database stream, opening it if necessary.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getpwent :: () -> *passwd #foreign libc;
+
+/* Read a user database entry from STREAM.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fgetpwent :: (__stream: *FILE) -> *passwd #foreign libc;
+
+/* Write a given user database entry onto the given stream.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+putpwent :: (__p: *passwd, __f: *FILE) -> s32 #foreign libc;
+
+/* Retrieve the user database entry for the given user ID.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getpwuid :: (__uid: u32) -> *passwd #foreign libc;
+
+/* Retrieve the user database entry for the given username.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getpwnam :: (__name: *u8) -> *passwd #foreign libc;
+
+/* This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getpwent_r :: (__resultbuf: *passwd, __buffer: *u8, __buflen: u64, __result: **passwd) -> s32 #foreign libc;
+
+getpwuid_r :: (__uid: u32, __resultbuf: *passwd, __buffer: *u8, __buflen: u64, __result: **passwd) -> s32 #foreign libc;
+
+getpwnam_r :: (__name: *u8, __resultbuf: *passwd, __buffer: *u8, __buflen: u64, __result: **passwd) -> s32 #foreign libc;
+
+/* Read a user database entry from STREAM.  This function is not
+standardized and probably never will.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fgetpwent_r :: (__stream: *FILE, __resultbuf: *passwd, __buffer: *u8, __buflen: u64, __result: **passwd) -> s32 #foreign libc;
+
+/* Write a traditional /etc/passwd line, based on the user database
+entry for the given UID, to BUFFER; space for BUFFER must be
+allocated by the caller.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getpw :: (__uid: u32, __buffer: *u8) -> s32 #foreign libc;
+
+sigset_t :: __sigset_t;
+
+time_t :: s64;
+
+timespec :: struct {
+    tv_sec:  s64;
+
+    tv_nsec: s64;
+}
+
+sigval :: union {
+    sival_int: s32;
+    sival_ptr: *void;
+}
+
+siginfo_t :: struct {
+    si_signo:  s32;
+
+    si_errno:  s32;
+
+    si_code:   s32;
+
+    __pad0:    s32;
+
+    _sifields: union {
+        _pad:      [28] s32;
+
+        _kill:     struct {
+            si_pid: s32;
+            si_uid: u32;
+        };
+
+        _timer:    struct {
+            si_tid:     s32;
+            si_overrun: s32;
+            si_sigval:  sigval;
+        };
+
+        _rt:       struct {
+            si_pid:    s32;
+            si_uid:    u32;
+            si_sigval: sigval;
+        };
+
+        _sigchld:  struct {
+            si_pid:    s32;
+            si_uid:    u32;
+            si_status: s32;
+            si_utime:  s64;
+            si_stime:  s64;
+        };
+
+        _sigfault: struct {
+            si_addr:     *void;
+
+            si_addr_lsb: s16;
+            _bounds:     union {
+                _addr_bnd: struct {
+                    _lower: *void;
+                    _upper: *void;
+                };
+
+                _pkey:     u32;
+            };
+        };
+
+        _sigpoll:  struct {
+            si_band: s64;
+            si_fd:   s32;
+        };
+
+        _sigsys:   struct {
+            _call_addr: *void;
+            _syscall:   s32;
+            _arch:      u32;
+        };
+    };
+}
+
+sigevent :: struct {
+    sigev_value:  sigval;
+    sigev_signo:  s32;
+    sigev_notify: s32;
+
+    _sigev_un:    union {
+        _pad:          [12] s32;
+
+        _tid:          s32;
+
+        _sigev_thread: struct {
+            _function:  #type (unknown0: sigval) -> void #c_call;
+            _attribute: *pthread_attr_t;
+        };
+    };
+}
+
+sigevent_t :: sigevent;
+
+/* The X/Open definition of `signal' specifies the SVID semantic.  Use
+the additional function `sysv_signal' when X/Open compatibility is
+requested.  */
+__sysv_signal :: (__sig: s32, __handler: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32) -> void #c_call) #foreign libc;
+
+sysv_signal :: (__sig: s32, __handler: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32) -> void #c_call) #foreign libc;
+
+signal :: (__sig: s32, __handler: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32) -> void #c_call) #foreign libc;
+
+kill :: (__pid: s32, __sig: s32) -> s32 #foreign libc;
+
+/* Send SIG to all processes in process group PGRP.
+If PGRP is zero, send SIG to all processes in
+the current process's process group.  */
+killpg :: (__pgrp: s32, __sig: s32) -> s32 #foreign libc;
+
+/* Raise signal SIG, i.e., send SIG to yourself.  */
+raise :: (__sig: s32) -> s32 #foreign libc;
+
+/* SVID names for the same things.  */
+ssignal :: (__sig: s32, __handler: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32) -> void #c_call) #foreign libc;
+
+gsignal :: (__sig: s32) -> s32 #foreign libc;
+
+/* Print a message describing the meaning of the given signal number.  */
+psignal :: (__sig: s32, __s: *u8) -> void #foreign libc;
+
+/* Print a message describing the meaning of the given signal information.  */
+psiginfo :: (__pinfo: *siginfo_t, __s: *u8) -> void #foreign libc;
+
+sigpause :: (__sig: s32) -> s32 #foreign libc "__xpg_sigpause";
+
+/* Block signals in MASK, returning the old mask.  */
+sigblock :: (__mask: s32) -> s32 #foreign libc;
+
+/* Set the mask of blocked signals to MASK, returning the old mask.  */
+sigsetmask :: (__mask: s32) -> s32 #foreign libc;
+
+/* Return currently selected signal mask.  */
+siggetmask :: () -> s32 #foreign libc;
+
+sighandler_t :: #type (unknown0: s32) -> void #c_call;
+
+sig_t :: #type (unknown0: s32) -> void #c_call;
+
+/* Clear all signals from SET.  */
+sigemptyset :: (__set: *sigset_t) -> s32 #foreign libc;
+
+/* Set all signals in SET.  */
+sigfillset :: (__set: *sigset_t) -> s32 #foreign libc;
+
+/* Add SIGNO to SET.  */
+sigaddset :: (__set: *sigset_t, __signo: s32) -> s32 #foreign libc;
+
+/* Remove SIGNO from SET.  */
+sigdelset :: (__set: *sigset_t, __signo: s32) -> s32 #foreign libc;
+
+/* Return 1 if SIGNO is in SET, 0 if not.  */
+sigismember :: (__set: *sigset_t, __signo: s32) -> s32 #foreign libc;
+
+/* Return non-empty value is SET is not empty.  */
+sigisemptyset :: (__set: *sigset_t) -> s32 #foreign libc;
+
+/* Build new signal set by combining the two inputs set using logical AND.  */
+sigandset :: (__set: *sigset_t, __left: *sigset_t, __right: *sigset_t) -> s32 #foreign libc;
+
+/* Build new signal set by combining the two inputs set using logical OR.  */
+sigorset :: (__set: *sigset_t, __left: *sigset_t, __right: *sigset_t) -> s32 #foreign libc;
+
+sigaction_t :: struct {
+    using __sigaction_handler: union {
+        sa_handler:   #type (unknown0: s32) -> void #c_call;
+
+        sa_sigaction: #type (unknown0: s32, unknown1: *siginfo_t, unknown2: *void) -> void #c_call;
+    };
+
+    sa_mask:             __sigset_t;
+
+    sa_flags:            s32;
+
+    sa_restorer:         #type () -> void #c_call;
+}
+
+/* Get and/or change the set of blocked signals.  */
+sigprocmask :: (__how: s32, __set: *sigset_t, __oset: *sigset_t) -> s32 #foreign libc;
+
+/* Change the set of blocked signals to SET,
+wait until a signal arrives, and restore the set of blocked signals.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+sigsuspend :: (__set: *sigset_t) -> s32 #foreign libc;
+
+/* Get and/or set the action for signal SIG.  */
+sigaction :: (__sig: s32, __act: *sigaction_t, __oact: *sigaction_t) -> s32 #foreign libc;
+
+/* Put in SET all signals that are blocked and waiting to be delivered.  */
+sigpending :: (__set: *sigset_t) -> s32 #foreign libc;
+
+/* Select any of pending signals from SET or wait for any to arrive.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+sigwait :: (__set: *sigset_t, __sig: *s32) -> s32 #foreign libc;
+
+/* Select any of pending signals from SET and place information in INFO.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+sigwaitinfo :: (__set: *sigset_t, __info: *siginfo_t) -> s32 #foreign libc;
+
+sigtimedwait :: (__set: *sigset_t, __info: *siginfo_t, __timeout: *timespec) -> s32 #foreign libc;
+
+/* Send signal SIG to the process PID.  Associate data in VAL with the
+signal.  */
+sigqueue :: (__pid: s32, __sig: s32, __val: sigval) -> s32 #foreign libc;
+
+__kernel_fd_set :: struct {
+    fds_bits: [16] u64;
+}
+
+__kernel_fsid_t :: struct {
+    val: [2] s32;
+}
+
+sigcontext :: struct {
+    fault_address: u64;
+
+    regs:          [31] u64;
+    sp:            u64;
+    pc:            u64;
+    pstate:        u64;
+
+    __reserved:    [4096] u8 #align 9;
+}
+
+/* Restore the state saved in SCP.  */
+sigreturn :: (__scp: *sigcontext) -> s32 #foreign libc;
+
+stack_t :: struct {
+    ss_sp:    *void;
+    ss_flags: s32;
+    ss_size:  u64;
+}
+
+timeval :: struct {
+    tv_sec:  s64;
+    tv_usec: s64;
+}
+
+suseconds_t :: s64;
+
+timezone :: struct {
+    tz_minuteswest: s32;
+    tz_dsttime:     s32;
+}
+
+gettimeofday :: (__tv: *timeval, __tz: *void) -> s32 #foreign libc;
+
+settimeofday :: (__tv: *timeval, __tz: *timezone) -> s32 #foreign libc;
+
+adjtime :: (__delta: *timeval, __olddelta: *timeval) -> s32 #foreign libc;
+
+__itimer_which :: enum u32 {
+    REAL    :: 0;
+
+    VIRTUAL :: 1;
+
+    PROF    :: 2;
+
+    ITIMER_REAL    :: REAL;
+
+    ITIMER_VIRTUAL :: VIRTUAL;
+
+    ITIMER_PROF    :: PROF;
+}
+
+itimerval :: struct {
+    it_interval: timeval;
+
+    it_value:    timeval;
+}
+
+getitimer :: (__which: __itimer_which, __value: *itimerval) -> s32 #foreign libc;
+
+setitimer :: (__which: __itimer_which, __new: *itimerval, __old: *itimerval) -> s32 #foreign libc;
+
+utimes :: (__file: *u8, __tvp: *[2] timeval) -> s32 #foreign libc;
+
+lutimes :: (__file: *u8, __tvp: *[2] timeval) -> s32 #foreign libc;
+
+futimes :: (__fd: s32, __tvp: *[2] timeval) -> s32 #foreign libc;
+
+futimesat :: (__fd: s32, __file: *u8, __tvp: *[2] timeval) -> s32 #foreign libc;
+
+fsid_t :: __fsid_t;
+
+key_t :: s32;
+
+clock_t :: s64;
+
+timer_t :: *void;
+
+useconds_t :: u32;
+
+register_t :: s64;
+
+fsblkcnt_t :: u64;
+
+fsfilcnt_t :: u64;
+
+blkcnt64_t :: s64;
+fsblkcnt64_t :: u64;
+fsfilcnt64_t :: u64;
+
+user_regs_struct :: struct {
+    regs:   [31] u64;
+    sp:     u64;
+    pc:     u64;
+    pstate: u64;
+}
+
+user_fpsimd_struct :: struct {
+    vregs: [32] U128;
+    fpsr:  u32;
+    fpcr:  u32;
+}
+
+elf_greg_t :: u64;
+
+elf_gregset_t :: [34] elf_greg_t;
+
+elf_fpregset_t :: user_fpsimd_struct;
+
+greg_t :: elf_greg_t;
+
+gregset_t :: elf_gregset_t;
+
+fpregset_t :: elf_fpregset_t;
+
+mcontext_t :: struct {
+    fault_address: u64;
+    regs:          [31] u64;
+    sp:            u64;
+    pc:            u64;
+    pstate:        u64;
+
+    __reserved:    [4096] u8 #align 9;
+}
+
+ucontext_t :: struct {
+    uc_flags:    u64;
+    uc_link:     *ucontext_t;
+    uc_stack:    stack_t;
+    uc_sigmask:  sigset_t;
+    uc_mcontext: mcontext_t #align 16;
+}
+
+/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
+(causing them to fail with EINTR); if INTERRUPT is zero, make system
+calls be restarted after signal SIG.  */
+siginterrupt :: (__sig: s32, __interrupt: s32) -> s32 #foreign libc;
+
+access :: (__name: *u8, __type: s32) -> s32 #foreign libc;
+
+euidaccess :: (__name: *u8, __type: s32) -> s32 #foreign libc;
+
+eaccess :: (__name: *u8, __type: s32) -> s32 #foreign libc;
+
+execveat :: (__fd: s32, __path: *u8, __argv: **u8, __envp: **u8, __flags: s32) -> s32 #foreign libc;
+
+faccessat :: (__fd: s32, __file: *u8, __type: s32, __flag: s32) -> s32 #foreign libc;
+
+lseek :: (__fd: s32, __offset: s64, __whence: s32) -> s64 #foreign libc;
+
+lseek64 :: (__fd: s32, __offset: s64, __whence: s32) -> s64 #foreign libc;
+
+close :: (__fd: s32) -> s32 #foreign libc;
+
+closefrom :: (__lowfd: s32) -> void #foreign libc;
+
+read :: (__fd: s32, __buf: *void, __nbytes: u64) -> s64 #foreign libc;
+
+write :: (__fd: s32, __buf: *void, __n: u64) -> s64 #foreign libc;
+
+pread :: (__fd: s32, __buf: *void, __nbytes: u64, __offset: s64) -> s64 #foreign libc;
+
+pwrite :: (__fd: s32, __buf: *void, __n: u64, __offset: s64) -> s64 #foreign libc;
+
+pread64 :: (__fd: s32, __buf: *void, __nbytes: u64, __offset: s64) -> s64 #foreign libc;
+
+pwrite64 :: (__fd: s32, __buf: *void, __n: u64, __offset: s64) -> s64 #foreign libc;
+
+pipe :: (__pipedes: *[2] s32) -> s32 #foreign libc;
+
+pipe2 :: (__pipedes: *[2] s32, __flags: s32) -> s32 #foreign libc;
+
+alarm :: (__seconds: u32) -> u32 #foreign libc;
+
+sleep :: (__seconds: u32) -> u32 #foreign libc;
+
+ualarm :: (__value: u32, __interval: u32) -> u32 #foreign libc;
+
+usleep :: (__useconds: u32) -> s32 #foreign libc;
+
+pause :: () -> s32 #foreign libc;
+
+chown :: (__file: *u8, __owner: u32, __group: u32) -> s32 #foreign libc;
+
+fchown :: (__fd: s32, __owner: u32, __group: u32) -> s32 #foreign libc;
+
+lchown :: (__file: *u8, __owner: u32, __group: u32) -> s32 #foreign libc;
+
+fchownat :: (__fd: s32, __file: *u8, __owner: u32, __group: u32, __flag: s32) -> s32 #foreign libc;
+
+chdir :: (__path: *u8) -> s32 #foreign libc;
+
+fchdir :: (__fd: s32) -> s32 #foreign libc;
+
+getcwd :: (__buf: *u8, __size: u64) -> *u8 #foreign libc;
+
+get_current_dir_name :: () -> *u8 #foreign libc;
+
+getwd :: (__buf: *u8) -> *u8 #foreign libc;
+
+dup :: (__fd: s32) -> s32 #foreign libc;
+
+dup2 :: (__fd: s32, __fd2: s32) -> s32 #foreign libc;
+
+dup3 :: (__fd: s32, __fd2: s32, __flags: s32) -> s32 #foreign libc;
+
+__environ: **u8 #elsewhere libc;
+
+environ: **u8 #elsewhere libc;
+
+execve :: (__path: *u8, __argv: **u8, __envp: **u8) -> s32 #foreign libc;
+
+fexecve :: (__fd: s32, __argv: **u8, __envp: **u8) -> s32 #foreign libc;
+
+execv :: (__path: *u8, __argv: **u8) -> s32 #foreign libc;
+
+execle :: (__path: *u8, __arg: *u8, __args: ..Any) -> s32 #foreign libc;
+
+execl :: (__path: *u8, __arg: *u8, __args: ..Any) -> s32 #foreign libc;
+
+execvp :: (__file: *u8, __argv: **u8) -> s32 #foreign libc;
+
+execlp :: (__file: *u8, __arg: *u8, __args: ..Any) -> s32 #foreign libc;
+
+execvpe :: (__file: *u8, __argv: **u8, __envp: **u8) -> s32 #foreign libc;
+
+nice :: (__inc: s32) -> s32 #foreign libc;
+
+_exit :: (__status: s32) -> void #foreign libc;
+
+PC :: enum u32 {
+    LINK_MAX           :: 0;
+
+    MAX_CANON          :: 1;
+
+    MAX_INPUT          :: 2;
+
+    NAME_MAX           :: 3;
+
+    PATH_MAX           :: 4;
+
+    PIPE_BUF           :: 5;
+
+    CHOWN_RESTRICTED   :: 6;
+
+    NO_TRUNC           :: 7;
+
+    VDISABLE           :: 8;
+
+    SYNC_IO            :: 9;
+
+    ASYNC_IO           :: 10;
+
+    PRIO_IO            :: 11;
+
+    SOCK_MAXBUF        :: 12;
+
+    FILESIZEBITS       :: 13;
+
+    REC_INCR_XFER_SIZE :: 14;
+
+    REC_MAX_XFER_SIZE  :: 15;
+
+    REC_MIN_XFER_SIZE  :: 16;
+
+    REC_XFER_ALIGN     :: 17;
+
+    ALLOC_SIZE_MIN     :: 18;
+
+    SYMLINK_MAX        :: 19;
+
+    _2_SYMLINKS        :: 20;
+
+    _PC_LINK_MAX           :: LINK_MAX;
+
+    _PC_MAX_CANON          :: MAX_CANON;
+
+    _PC_MAX_INPUT          :: MAX_INPUT;
+
+    _PC_NAME_MAX           :: NAME_MAX;
+
+    _PC_PATH_MAX           :: PATH_MAX;
+
+    _PC_PIPE_BUF           :: PIPE_BUF;
+
+    _PC_CHOWN_RESTRICTED   :: CHOWN_RESTRICTED;
+
+    _PC_NO_TRUNC           :: NO_TRUNC;
+
+    _PC_VDISABLE           :: VDISABLE;
+
+    _PC_SYNC_IO            :: SYNC_IO;
+
+    _PC_ASYNC_IO           :: ASYNC_IO;
+
+    _PC_PRIO_IO            :: PRIO_IO;
+
+    _PC_SOCK_MAXBUF        :: SOCK_MAXBUF;
+
+    _PC_FILESIZEBITS       :: FILESIZEBITS;
+
+    _PC_REC_INCR_XFER_SIZE :: REC_INCR_XFER_SIZE;
+
+    _PC_REC_MAX_XFER_SIZE  :: REC_MAX_XFER_SIZE;
+
+    _PC_REC_MIN_XFER_SIZE  :: REC_MIN_XFER_SIZE;
+
+    _PC_REC_XFER_ALIGN     :: REC_XFER_ALIGN;
+
+    _PC_ALLOC_SIZE_MIN     :: ALLOC_SIZE_MIN;
+
+    _PC_SYMLINK_MAX        :: SYMLINK_MAX;
+
+    _PC_2_SYMLINKS         :: _2_SYMLINKS;
+}
+
+using _SC_definitions :: enum s32 {
+    _SC_ARG_MAX                      :: 0;
+
+    _SC_CHILD_MAX                    :: 1;
+
+    _SC_CLK_TCK                      :: 2;
+
+    _SC_NGROUPS_MAX                  :: 3;
+
+    _SC_OPEN_MAX                     :: 4;
+
+    _SC_STREAM_MAX                   :: 5;
+
+    _SC_TZNAME_MAX                   :: 6;
+
+    _SC_JOB_CONTROL                  :: 7;
+
+    _SC_SAVED_IDS                    :: 8;
+
+    _SC_REALTIME_SIGNALS             :: 9;
+
+    _SC_PRIORITY_SCHEDULING          :: 10;
+
+    _SC_TIMERS                       :: 11;
+
+    _SC_ASYNCHRONOUS_IO              :: 12;
+
+    _SC_PRIORITIZED_IO               :: 13;
+
+    _SC_SYNCHRONIZED_IO              :: 14;
+
+    _SC_FSYNC                        :: 15;
+
+    _SC_MAPPED_FILES                 :: 16;
+
+    _SC_MEMLOCK                      :: 17;
+
+    _SC_MEMLOCK_RANGE                :: 18;
+
+    _SC_MEMORY_PROTECTION            :: 19;
+
+    _SC_MESSAGE_PASSING              :: 20;
+
+    _SC_SEMAPHORES                   :: 21;
+
+    _SC_SHARED_MEMORY_OBJECTS        :: 22;
+
+    _SC_AIO_LISTIO_MAX               :: 23;
+
+    _SC_AIO_MAX                      :: 24;
+
+    _SC_AIO_PRIO_DELTA_MAX           :: 25;
+
+    _SC_DELAYTIMER_MAX               :: 26;
+
+    _SC_MQ_OPEN_MAX                  :: 27;
+
+    _SC_MQ_PRIO_MAX                  :: 28;
+
+    _SC_VERSION                      :: 29;
+
+    _SC_PAGESIZE                     :: 30;
+
+    _SC_RTSIG_MAX                    :: 31;
+
+    _SC_SEM_NSEMS_MAX                :: 32;
+
+    _SC_SEM_VALUE_MAX                :: 33;
+
+    _SC_SIGQUEUE_MAX                 :: 34;
+
+    _SC_TIMER_MAX                    :: 35;
+
+    _SC_BC_BASE_MAX                  :: 36;
+
+    _SC_BC_DIM_MAX                   :: 37;
+
+    _SC_BC_SCALE_MAX                 :: 38;
+
+    _SC_BC_STRING_MAX                :: 39;
+
+    _SC_COLL_WEIGHTS_MAX             :: 40;
+
+    _SC_EQUIV_CLASS_MAX              :: 41;
+
+    _SC_EXPR_NEST_MAX                :: 42;
+
+    _SC_LINE_MAX                     :: 43;
+
+    _SC_RE_DUP_MAX                   :: 44;
+
+    _SC_CHARCLASS_NAME_MAX           :: 45;
+
+    _SC_2_VERSION                    :: 46;
+
+    _SC_2_C_BIND                     :: 47;
+
+    _SC_2_C_DEV                      :: 48;
+
+    _SC_2_FORT_DEV                   :: 49;
+
+    _SC_2_FORT_RUN                   :: 50;
+
+    _SC_2_SW_DEV                     :: 51;
+
+    _SC_2_LOCALEDEF                  :: 52;
+
+    _SC_PII                          :: 53;
+
+    _SC_PII_XTI                      :: 54;
+
+    _SC_PII_SOCKET                   :: 55;
+
+    _SC_PII_INTERNET                 :: 56;
+
+    _SC_PII_OSI                      :: 57;
+
+    _SC_POLL                         :: 58;
+
+    _SC_SELECT                       :: 59;
+
+    _SC_UIO_MAXIOV                   :: 60;
+
+    _SC_IOV_MAX                      :: 60;
+
+    _SC_PII_INTERNET_STREAM          :: 61;
+
+    _SC_PII_INTERNET_DGRAM           :: 62;
+
+    _SC_PII_OSI_COTS                 :: 63;
+
+    _SC_PII_OSI_CLTS                 :: 64;
+
+    _SC_PII_OSI_M                    :: 65;
+
+    _SC_T_IOV_MAX                    :: 66;
+
+    _SC_THREADS                      :: 67;
+
+    _SC_THREAD_SAFE_FUNCTIONS        :: 68;
+
+    _SC_GETGR_R_SIZE_MAX             :: 69;
+
+    _SC_GETPW_R_SIZE_MAX             :: 70;
+
+    _SC_LOGIN_NAME_MAX               :: 71;
+
+    _SC_TTY_NAME_MAX                 :: 72;
+
+    _SC_THREAD_DESTRUCTOR_ITERATIONS :: 73;
+
+    _SC_THREAD_KEYS_MAX              :: 74;
+
+    _SC_THREAD_STACK_MIN             :: 75;
+
+    _SC_THREAD_THREADS_MAX           :: 76;
+
+    _SC_THREAD_ATTR_STACKADDR        :: 77;
+
+    _SC_THREAD_ATTR_STACKSIZE        :: 78;
+
+    _SC_THREAD_PRIORITY_SCHEDULING   :: 79;
+
+    _SC_THREAD_PRIO_INHERIT          :: 80;
+
+    _SC_THREAD_PRIO_PROTECT          :: 81;
+
+    _SC_THREAD_PROCESS_SHARED        :: 82;
+
+    _SC_NPROCESSORS_CONF             :: 83;
+
+    _SC_NPROCESSORS_ONLN             :: 84;
+
+    _SC_PHYS_PAGES                   :: 85;
+
+    _SC_AVPHYS_PAGES                 :: 86;
+
+    _SC_ATEXIT_MAX                   :: 87;
+
+    _SC_PASS_MAX                     :: 88;
+
+    _SC_XOPEN_VERSION                :: 89;
+
+    _SC_XOPEN_XCU_VERSION            :: 90;
+
+    _SC_XOPEN_UNIX                   :: 91;
+
+    _SC_XOPEN_CRYPT                  :: 92;
+
+    _SC_XOPEN_ENH_I18N               :: 93;
+
+    _SC_XOPEN_SHM                    :: 94;
+
+    _SC_2_CHAR_TERM                  :: 95;
+
+    _SC_2_C_VERSION                  :: 96;
+
+    _SC_2_UPE                        :: 97;
+
+    _SC_XOPEN_XPG2                   :: 98;
+
+    _SC_XOPEN_XPG3                   :: 99;
+
+    _SC_XOPEN_XPG4                   :: 100;
+
+    _SC_CHAR_BIT                     :: 101;
+
+    _SC_CHAR_MAX                     :: 102;
+
+    _SC_CHAR_MIN                     :: 103;
+
+    _SC_INT_MAX                      :: 104;
+
+    _SC_INT_MIN                      :: 105;
+
+    _SC_LONG_BIT                     :: 106;
+
+    _SC_WORD_BIT                     :: 107;
+
+    _SC_MB_LEN_MAX                   :: 108;
+
+    _SC_NZERO                        :: 109;
+
+    _SC_SSIZE_MAX                    :: 110;
+
+    _SC_SCHAR_MAX                    :: 111;
+
+    _SC_SCHAR_MIN                    :: 112;
+
+    _SC_SHRT_MAX                     :: 113;
+
+    _SC_SHRT_MIN                     :: 114;
+
+    _SC_UCHAR_MAX                    :: 115;
+
+    _SC_UINT_MAX                     :: 116;
+
+    _SC_ULONG_MAX                    :: 117;
+
+    _SC_USHRT_MAX                    :: 118;
+
+    _SC_NL_ARGMAX                    :: 119;
+
+    _SC_NL_LANGMAX                   :: 120;
+
+    _SC_NL_MSGMAX                    :: 121;
+
+    _SC_NL_NMAX                      :: 122;
+
+    _SC_NL_SETMAX                    :: 123;
+
+    _SC_NL_TEXTMAX                   :: 124;
+
+    _SC_XBS5_ILP32_OFF32             :: 125;
+
+    _SC_XBS5_ILP32_OFFBIG            :: 126;
+
+    _SC_XBS5_LP64_OFF64              :: 127;
+
+    _SC_XBS5_LPBIG_OFFBIG            :: 128;
+
+    _SC_XOPEN_LEGACY                 :: 129;
+
+    _SC_XOPEN_REALTIME               :: 130;
+
+    _SC_XOPEN_REALTIME_THREADS       :: 131;
+
+    _SC_ADVISORY_INFO                :: 132;
+
+    _SC_BARRIERS                     :: 133;
+
+    _SC_BASE                         :: 134;
+
+    _SC_C_LANG_SUPPORT               :: 135;
+
+    _SC_C_LANG_SUPPORT_R             :: 136;
+
+    _SC_CLOCK_SELECTION              :: 137;
+
+    _SC_CPUTIME                      :: 138;
+
+    _SC_THREAD_CPUTIME               :: 139;
+
+    _SC_DEVICE_IO                    :: 140;
+
+    _SC_DEVICE_SPECIFIC              :: 141;
+
+    _SC_DEVICE_SPECIFIC_R            :: 142;
+
+    _SC_FD_MGMT                      :: 143;
+
+    _SC_FIFO                         :: 144;
+
+    _SC_PIPE                         :: 145;
+
+    _SC_FILE_ATTRIBUTES              :: 146;
+
+    _SC_FILE_LOCKING                 :: 147;
+
+    _SC_FILE_SYSTEM                  :: 148;
+
+    _SC_MONOTONIC_CLOCK              :: 149;
+
+    _SC_MULTI_PROCESS                :: 150;
+
+    _SC_SINGLE_PROCESS               :: 151;
+
+    _SC_NETWORKING                   :: 152;
+
+    _SC_READER_WRITER_LOCKS          :: 153;
+
+    _SC_SPIN_LOCKS                   :: 154;
+
+    _SC_REGEXP                       :: 155;
+
+    _SC_REGEX_VERSION                :: 156;
+
+    _SC_SHELL                        :: 157;
+
+    _SC_SIGNALS                      :: 158;
+
+    _SC_SPAWN                        :: 159;
+
+    _SC_SPORADIC_SERVER              :: 160;
+
+    _SC_THREAD_SPORADIC_SERVER       :: 161;
+
+    _SC_SYSTEM_DATABASE              :: 162;
+
+    _SC_SYSTEM_DATABASE_R            :: 163;
+
+    _SC_TIMEOUTS                     :: 164;
+
+    _SC_TYPED_MEMORY_OBJECTS         :: 165;
+
+    _SC_USER_GROUPS                  :: 166;
+
+    _SC_USER_GROUPS_R                :: 167;
+
+    _SC_2_PBS                        :: 168;
+
+    _SC_2_PBS_ACCOUNTING             :: 169;
+
+    _SC_2_PBS_LOCATE                 :: 170;
+
+    _SC_2_PBS_MESSAGE                :: 171;
+
+    _SC_2_PBS_TRACK                  :: 172;
+
+    _SC_SYMLOOP_MAX                  :: 173;
+
+    _SC_STREAMS                      :: 174;
+
+    _SC_2_PBS_CHECKPOINT             :: 175;
+
+    _SC_V6_ILP32_OFF32               :: 176;
+
+    _SC_V6_ILP32_OFFBIG              :: 177;
+
+    _SC_V6_LP64_OFF64                :: 178;
+
+    _SC_V6_LPBIG_OFFBIG              :: 179;
+
+    _SC_HOST_NAME_MAX                :: 180;
+
+    _SC_TRACE                        :: 181;
+
+    _SC_TRACE_EVENT_FILTER           :: 182;
+
+    _SC_TRACE_INHERIT                :: 183;
+
+    _SC_TRACE_LOG                    :: 184;
+
+    _SC_LEVEL1_ICACHE_SIZE           :: 185;
+
+    _SC_LEVEL1_ICACHE_ASSOC          :: 186;
+
+    _SC_LEVEL1_ICACHE_LINESIZE       :: 187;
+
+    _SC_LEVEL1_DCACHE_SIZE           :: 188;
+
+    _SC_LEVEL1_DCACHE_ASSOC          :: 189;
+
+    _SC_LEVEL1_DCACHE_LINESIZE       :: 190;
+
+    _SC_LEVEL2_CACHE_SIZE            :: 191;
+
+    _SC_LEVEL2_CACHE_ASSOC           :: 192;
+
+    _SC_LEVEL2_CACHE_LINESIZE        :: 193;
+
+    _SC_LEVEL3_CACHE_SIZE            :: 194;
+
+    _SC_LEVEL3_CACHE_ASSOC           :: 195;
+
+    _SC_LEVEL3_CACHE_LINESIZE        :: 196;
+
+    _SC_LEVEL4_CACHE_SIZE            :: 197;
+
+    _SC_LEVEL4_CACHE_ASSOC           :: 198;
+
+    _SC_LEVEL4_CACHE_LINESIZE        :: 199;
+
+    _SC_IPV6                         :: 235;
+
+    _SC_RAW_SOCKETS                  :: 236;
+
+    _SC_V7_ILP32_OFF32               :: 237;
+
+    _SC_V7_ILP32_OFFBIG              :: 238;
+
+    _SC_V7_LP64_OFF64                :: 239;
+
+    _SC_V7_LPBIG_OFFBIG              :: 240;
+
+    _SC_SS_REPL_MAX                  :: 241;
+
+    _SC_TRACE_EVENT_NAME_MAX         :: 242;
+
+    _SC_TRACE_NAME_MAX               :: 243;
+
+    _SC_TRACE_SYS_MAX                :: 244;
+
+    _SC_TRACE_USER_EVENT_MAX         :: 245;
+
+    _SC_XOPEN_STREAMS                :: 246;
+
+    _SC_THREAD_ROBUST_PRIO_INHERIT   :: 247;
+
+    _SC_THREAD_ROBUST_PRIO_PROTECT   :: 248;
+
+    _SC_MINSIGSTKSZ                  :: 249;
+
+    _SC_SIGSTKSZ                     :: 250;
+}
+
+CS :: enum u32 {
+    PATH                            :: 0;
+
+    V6_WIDTH_RESTRICTED_ENVS        :: 1;
+
+    GNU_LIBC_VERSION                :: 2;
+
+    GNU_LIBPTHREAD_VERSION          :: 3;
+
+    V5_WIDTH_RESTRICTED_ENVS        :: 4;
+
+    V7_WIDTH_RESTRICTED_ENVS        :: 5;
+
+    LFS_CFLAGS                      :: 1000;
+
+    LFS_LDFLAGS                     :: 1001;
+
+    LFS_LIBS                        :: 1002;
+
+    LFS_LINTFLAGS                   :: 1003;
+
+    LFS64_CFLAGS                    :: 1004;
+
+    LFS64_LDFLAGS                   :: 1005;
+
+    LFS64_LIBS                      :: 1006;
+
+    LFS64_LINTFLAGS                 :: 1007;
+
+    XBS5_ILP32_OFF32_CFLAGS         :: 1100;
+
+    XBS5_ILP32_OFF32_LDFLAGS        :: 1101;
+
+    XBS5_ILP32_OFF32_LIBS           :: 1102;
+
+    XBS5_ILP32_OFF32_LINTFLAGS      :: 1103;
+
+    XBS5_ILP32_OFFBIG_CFLAGS        :: 1104;
+
+    XBS5_ILP32_OFFBIG_LDFLAGS       :: 1105;
+
+    XBS5_ILP32_OFFBIG_LIBS          :: 1106;
+
+    XBS5_ILP32_OFFBIG_LINTFLAGS     :: 1107;
+
+    XBS5_LP64_OFF64_CFLAGS          :: 1108;
+
+    XBS5_LP64_OFF64_LDFLAGS         :: 1109;
+
+    XBS5_LP64_OFF64_LIBS            :: 1110;
+
+    XBS5_LP64_OFF64_LINTFLAGS       :: 1111;
+
+    XBS5_LPBIG_OFFBIG_CFLAGS        :: 1112;
+
+    XBS5_LPBIG_OFFBIG_LDFLAGS       :: 1113;
+
+    XBS5_LPBIG_OFFBIG_LIBS          :: 1114;
+
+    XBS5_LPBIG_OFFBIG_LINTFLAGS     :: 1115;
+
+    POSIX_V6_ILP32_OFF32_CFLAGS     :: 1116;
+
+    POSIX_V6_ILP32_OFF32_LDFLAGS    :: 1117;
+
+    POSIX_V6_ILP32_OFF32_LIBS       :: 1118;
+
+    POSIX_V6_ILP32_OFF32_LINTFLAGS  :: 1119;
+
+    POSIX_V6_ILP32_OFFBIG_CFLAGS    :: 1120;
+
+    POSIX_V6_ILP32_OFFBIG_LDFLAGS   :: 1121;
+
+    POSIX_V6_ILP32_OFFBIG_LIBS      :: 1122;
+
+    POSIX_V6_ILP32_OFFBIG_LINTFLAGS :: 1123;
+
+    POSIX_V6_LP64_OFF64_CFLAGS      :: 1124;
+
+    POSIX_V6_LP64_OFF64_LDFLAGS     :: 1125;
+
+    POSIX_V6_LP64_OFF64_LIBS        :: 1126;
+
+    POSIX_V6_LP64_OFF64_LINTFLAGS   :: 1127;
+
+    POSIX_V6_LPBIG_OFFBIG_CFLAGS    :: 1128;
+
+    POSIX_V6_LPBIG_OFFBIG_LDFLAGS   :: 1129;
+
+    POSIX_V6_LPBIG_OFFBIG_LIBS      :: 1130;
+
+    POSIX_V6_LPBIG_OFFBIG_LINTFLAGS :: 1131;
+
+    POSIX_V7_ILP32_OFF32_CFLAGS     :: 1132;
+
+    POSIX_V7_ILP32_OFF32_LDFLAGS    :: 1133;
+
+    POSIX_V7_ILP32_OFF32_LIBS       :: 1134;
+
+    POSIX_V7_ILP32_OFF32_LINTFLAGS  :: 1135;
+
+    POSIX_V7_ILP32_OFFBIG_CFLAGS    :: 1136;
+
+    POSIX_V7_ILP32_OFFBIG_LDFLAGS   :: 1137;
+
+    POSIX_V7_ILP32_OFFBIG_LIBS      :: 1138;
+
+    POSIX_V7_ILP32_OFFBIG_LINTFLAGS :: 1139;
+
+    POSIX_V7_LP64_OFF64_CFLAGS      :: 1140;
+
+    POSIX_V7_LP64_OFF64_LDFLAGS     :: 1141;
+
+    POSIX_V7_LP64_OFF64_LIBS        :: 1142;
+
+    POSIX_V7_LP64_OFF64_LINTFLAGS   :: 1143;
+
+    POSIX_V7_LPBIG_OFFBIG_CFLAGS    :: 1144;
+
+    POSIX_V7_LPBIG_OFFBIG_LDFLAGS   :: 1145;
+
+    POSIX_V7_LPBIG_OFFBIG_LIBS      :: 1146;
+
+    POSIX_V7_LPBIG_OFFBIG_LINTFLAGS :: 1147;
+
+    V6_ENV                          :: 1148;
+
+    V7_ENV                          :: 1149;
+
+    _CS_PATH                            :: PATH;
+
+    _CS_V6_WIDTH_RESTRICTED_ENVS        :: V6_WIDTH_RESTRICTED_ENVS;
+
+    _CS_GNU_LIBC_VERSION                :: GNU_LIBC_VERSION;
+
+    _CS_GNU_LIBPTHREAD_VERSION          :: GNU_LIBPTHREAD_VERSION;
+
+    _CS_V5_WIDTH_RESTRICTED_ENVS        :: V5_WIDTH_RESTRICTED_ENVS;
+
+    _CS_V7_WIDTH_RESTRICTED_ENVS        :: V7_WIDTH_RESTRICTED_ENVS;
+
+    _CS_LFS_CFLAGS                      :: LFS_CFLAGS;
+
+    _CS_LFS_LDFLAGS                     :: LFS_LDFLAGS;
+
+    _CS_LFS_LIBS                        :: LFS_LIBS;
+
+    _CS_LFS_LINTFLAGS                   :: LFS_LINTFLAGS;
+
+    _CS_LFS64_CFLAGS                    :: LFS64_CFLAGS;
+
+    _CS_LFS64_LDFLAGS                   :: LFS64_LDFLAGS;
+
+    _CS_LFS64_LIBS                      :: LFS64_LIBS;
+
+    _CS_LFS64_LINTFLAGS                 :: LFS64_LINTFLAGS;
+
+    _CS_XBS5_ILP32_OFF32_CFLAGS         :: XBS5_ILP32_OFF32_CFLAGS;
+
+    _CS_XBS5_ILP32_OFF32_LDFLAGS        :: XBS5_ILP32_OFF32_LDFLAGS;
+
+    _CS_XBS5_ILP32_OFF32_LIBS           :: XBS5_ILP32_OFF32_LIBS;
+
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS      :: XBS5_ILP32_OFF32_LINTFLAGS;
+
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS        :: XBS5_ILP32_OFFBIG_CFLAGS;
+
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS       :: XBS5_ILP32_OFFBIG_LDFLAGS;
+
+    _CS_XBS5_ILP32_OFFBIG_LIBS          :: XBS5_ILP32_OFFBIG_LIBS;
+
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS     :: XBS5_ILP32_OFFBIG_LINTFLAGS;
+
+    _CS_XBS5_LP64_OFF64_CFLAGS          :: XBS5_LP64_OFF64_CFLAGS;
+
+    _CS_XBS5_LP64_OFF64_LDFLAGS         :: XBS5_LP64_OFF64_LDFLAGS;
+
+    _CS_XBS5_LP64_OFF64_LIBS            :: XBS5_LP64_OFF64_LIBS;
+
+    _CS_XBS5_LP64_OFF64_LINTFLAGS       :: XBS5_LP64_OFF64_LINTFLAGS;
+
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS        :: XBS5_LPBIG_OFFBIG_CFLAGS;
+
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS       :: XBS5_LPBIG_OFFBIG_LDFLAGS;
+
+    _CS_XBS5_LPBIG_OFFBIG_LIBS          :: XBS5_LPBIG_OFFBIG_LIBS;
+
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS     :: XBS5_LPBIG_OFFBIG_LINTFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS     :: POSIX_V6_ILP32_OFF32_CFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS    :: POSIX_V6_ILP32_OFF32_LDFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFF32_LIBS       :: POSIX_V6_ILP32_OFF32_LIBS;
+
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  :: POSIX_V6_ILP32_OFF32_LINTFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    :: POSIX_V6_ILP32_OFFBIG_CFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   :: POSIX_V6_ILP32_OFFBIG_LDFLAGS;
+
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS      :: POSIX_V6_ILP32_OFFBIG_LIBS;
+
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS :: POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
+
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS      :: POSIX_V6_LP64_OFF64_CFLAGS;
+
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS     :: POSIX_V6_LP64_OFF64_LDFLAGS;
+
+    _CS_POSIX_V6_LP64_OFF64_LIBS        :: POSIX_V6_LP64_OFF64_LIBS;
+
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS   :: POSIX_V6_LP64_OFF64_LINTFLAGS;
+
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    :: POSIX_V6_LPBIG_OFFBIG_CFLAGS;
+
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   :: POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
+
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS      :: POSIX_V6_LPBIG_OFFBIG_LIBS;
+
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS :: POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS     :: POSIX_V7_ILP32_OFF32_CFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS    :: POSIX_V7_ILP32_OFF32_LDFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFF32_LIBS       :: POSIX_V7_ILP32_OFF32_LIBS;
+
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS  :: POSIX_V7_ILP32_OFF32_LINTFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS    :: POSIX_V7_ILP32_OFFBIG_CFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS   :: POSIX_V7_ILP32_OFFBIG_LDFLAGS;
+
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS      :: POSIX_V7_ILP32_OFFBIG_LIBS;
+
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS :: POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
+
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS      :: POSIX_V7_LP64_OFF64_CFLAGS;
+
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS     :: POSIX_V7_LP64_OFF64_LDFLAGS;
+
+    _CS_POSIX_V7_LP64_OFF64_LIBS        :: POSIX_V7_LP64_OFF64_LIBS;
+
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS   :: POSIX_V7_LP64_OFF64_LINTFLAGS;
+
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS    :: POSIX_V7_LPBIG_OFFBIG_CFLAGS;
+
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS   :: POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
+
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS      :: POSIX_V7_LPBIG_OFFBIG_LIBS;
+
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS :: POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
+
+    _CS_V6_ENV                          :: V6_ENV;
+
+    _CS_V7_ENV                          :: V7_ENV;
+}
+
+pathconf :: (__path: *u8, __name: PC) -> s64 #foreign libc;
+
+fpathconf :: (__fd: s32, __name: PC) -> s64 #foreign libc;
+
+sysconf :: (name: _SC_definitions) -> s64 #foreign libc;
+
+confstr :: (__name: s32, __buf: *u8, __len: u64) -> u64 #foreign libc;
+
+getpid :: () -> s32 #foreign libc;
+
+getppid :: () -> s32 #foreign libc;
+
+getpgrp :: () -> s32 #foreign libc;
+
+__getpgid :: (__pid: s32) -> s32 #foreign libc;
+
+getpgid :: (__pid: s32) -> s32 #foreign libc;
+
+setpgid :: (__pid: s32, __pgid: s32) -> s32 #foreign libc;
+
+setpgrp :: () -> s32 #foreign libc;
+
+setsid :: () -> s32 #foreign libc;
+
+getsid :: (__pid: s32) -> s32 #foreign libc;
+
+getuid :: () -> u32 #foreign libc;
+
+geteuid :: () -> u32 #foreign libc;
+
+getgid :: () -> u32 #foreign libc;
+
+getegid :: () -> u32 #foreign libc;
+
+getgroups :: (__size: s32, __list: *u32) -> s32 #foreign libc;
+
+group_member :: (__gid: u32) -> s32 #foreign libc;
+
+setuid :: (__uid: u32) -> s32 #foreign libc;
+
+setreuid :: (__ruid: u32, __euid: u32) -> s32 #foreign libc;
+
+seteuid :: (__uid: u32) -> s32 #foreign libc;
+
+setgid :: (__gid: u32) -> s32 #foreign libc;
+
+setregid :: (__rgid: u32, __egid: u32) -> s32 #foreign libc;
+
+setegid :: (__gid: u32) -> s32 #foreign libc;
+
+getresuid :: (__ruid: *u32, __euid: *u32, __suid: *u32) -> s32 #foreign libc;
+
+getresgid :: (__rgid: *u32, __egid: *u32, __sgid: *u32) -> s32 #foreign libc;
+
+setresuid :: (__ruid: u32, __euid: u32, __suid: u32) -> s32 #foreign libc;
+
+setresgid :: (__rgid: u32, __egid: u32, __sgid: u32) -> s32 #foreign libc;
+
+fork :: () -> s32 #foreign libc;
+
+vfork :: () -> s32 #foreign libc;
+
+_Fork :: () -> s32 #foreign libc;
+
+ttyname :: (__fd: s32) -> *u8 #foreign libc;
+
+ttyname_r :: (__fd: s32, __buf: *u8, __buflen: u64) -> s32 #foreign libc;
+
+isatty :: (__fd: s32) -> s32 #foreign libc;
+
+ttyslot :: () -> s32 #foreign libc;
+
+link :: (__from: *u8, __to: *u8) -> s32 #foreign libc;
+
+linkat :: (__fromfd: s32, __from: *u8, __tofd: s32, __to: *u8, __flags: s32) -> s32 #foreign libc;
+
+symlink :: (__from: *u8, __to: *u8) -> s32 #foreign libc;
+
+readlink :: (__path: *u8, __buf: *u8, __len: u64) -> s64 #foreign libc;
+
+symlinkat :: (__from: *u8, __tofd: s32, __to: *u8) -> s32 #foreign libc;
+
+readlinkat :: (__fd: s32, __path: *u8, __buf: *u8, __len: u64) -> s64 #foreign libc;
+
+unlink :: (__name: *u8) -> s32 #foreign libc;
+
+unlinkat :: (__fd: s32, __name: *u8, __flag: s32) -> s32 #foreign libc;
+
+rmdir :: (__path: *u8) -> s32 #foreign libc;
+
+tcgetpgrp :: (__fd: s32) -> s32 #foreign libc;
+
+tcsetpgrp :: (__fd: s32, __pgrp_id: s32) -> s32 #foreign libc;
+
+getlogin :: () -> *u8 #foreign libc;
+
+getlogin_r :: (__name: *u8, __name_len: u64) -> s32 #foreign libc;
+
+setlogin :: (__name: *u8) -> s32 #foreign libc;
+
+gethostname :: (__name: *u8, __len: u64) -> s32 #foreign libc;
+
+sethostname :: (__name: *u8, __len: u64) -> s32 #foreign libc;
+
+sethostid :: (__id: s64) -> s32 #foreign libc;
+
+getdomainname :: (__name: *u8, __len: u64) -> s32 #foreign libc;
+
+setdomainname :: (__name: *u8, __len: u64) -> s32 #foreign libc;
+
+vhangup :: () -> s32 #foreign libc;
+
+revoke :: (__file: *u8) -> s32 #foreign libc;
+
+profil :: (__sample_buffer: *u16, __size: u64, __offset: u64, __scale: u32) -> s32 #foreign libc;
+
+acct :: (__name: *u8) -> s32 #foreign libc;
+
+getusershell :: () -> *u8 #foreign libc;
+endusershell :: () -> void #foreign libc;
+setusershell :: () -> void #foreign libc;
+
+daemon :: (__nochdir: s32, __noclose: s32) -> s32 #foreign libc;
+
+chroot :: (__path: *u8) -> s32 #foreign libc;
+
+getpass :: (__prompt: *u8) -> *u8 #foreign libc;
+
+fsync :: (__fd: s32) -> s32 #foreign libc;
+
+syncfs :: (__fd: s32) -> s32 #foreign libc;
+
+gethostid :: () -> s64 #foreign libc;
+
+sync :: () -> void #foreign libc;
+
+getpagesize :: () -> s32 #foreign libc;
+
+getdtablesize :: () -> s32 #foreign libc;
+
+truncate :: (__file: *u8, __length: s64) -> s32 #foreign libc;
+
+truncate64 :: (__file: *u8, __length: s64) -> s32 #foreign libc;
+
+ftruncate :: (__fd: s32, __length: s64) -> s32 #foreign libc;
+
+ftruncate64 :: (__fd: s32, __length: s64) -> s32 #foreign libc;
+
+brk :: (__addr: *void) -> s32 #foreign libc;
+
+sbrk :: (__delta: s64) -> *void #foreign libc;
+
+copy_file_range :: (__infd: s32, __pinoff: *s64, __outfd: s32, __poutoff: *s64, __length: u64, __flags: u32) -> s64 #foreign libc;
+
+fdatasync :: (__fildes: s32) -> s32 #foreign libc;
+
+swab :: (__from: *void, __to: *void, __n: s64) -> void #foreign libc;
+
+getentropy :: (__buffer: *void, __length: u64) -> s32 #foreign libc;
+
+close_range :: (__fd: u32, __max_fd: u32, __flags: s32) -> s32 #foreign libc;
+
+/* Alternate signal handler stack interface.
+This interface should always be preferred over `sigstack'.  */
+sigaltstack :: (__ss: *stack_t, __oss: *stack_t) -> s32 #foreign libc;
+
+/* Add SIG to the calling process' signal mask.  */
+sighold :: (__sig: s32) -> s32 #foreign libc;
+
+/* Remove SIG from the calling process' signal mask.  */
+sigrelse :: (__sig: s32) -> s32 #foreign libc;
+
+/* Set the disposition of SIG to SIG_IGN.  */
+sigignore :: (__sig: s32) -> s32 #foreign libc;
+
+/* Set the disposition of SIG.  */
+sigset :: (__sig: s32, __disp: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32) -> void #c_call) #foreign libc;
+
+/* Return number of available real-time signal with highest priority.  */
+__libc_current_sigrtmin :: () -> s32 #foreign libc;
+
+/* Return number of available real-time signal with lowest priority.  */
+__libc_current_sigrtmax :: () -> s32 #foreign libc;
+
+ipc_perm :: struct {
+    __key:             s32;
+    uid:               u32;
+    gid:               u32;
+    cuid:              u32;
+    cgid:              u32;
+    mode:              u32;
+    __seq:             u16;
+    __pad2:            u16;
+    __glibc_reserved1: u64;
+    __glibc_reserved2: u64;
+}
+
+/* Generates key for System V style IPC.  */
+ftok :: (__pathname: *u8, __proj_id: s32) -> key_t #foreign libc;
+
+mmap :: (__addr: *void, __len: u64, __prot: s32, __flags: s32, __fd: s32, __offset: s64) -> *void #foreign libc;
+
+mmap64 :: (__addr: *void, __len: u64, __prot: s32, __flags: s32, __fd: s32, __offset: s64) -> *void #foreign libc;
+
+/* Deallocate any mapping for the region starting at ADDR and extending LEN
+bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
+munmap :: (__addr: *void, __len: u64) -> s32 #foreign libc;
+
+/* Change the memory protection of the region starting at ADDR and
+extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
+(and sets errno).  */
+mprotect :: (__addr: *void, __len: u64, __prot: s32) -> s32 #foreign libc;
+
+/* Synchronize the region starting at ADDR and extending LEN bytes with the
+file it maps.  Filesystem operations on a file being mapped are
+unpredictable before this is done.  Flags are from the MS_* set.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+msync :: (__addr: *void, __len: u64, __flags: s32) -> s32 #foreign libc;
+
+/* Advise the system about particular usage patterns the program follows
+for the region starting at ADDR and extending LEN bytes.  */
+madvise :: (__addr: *void, __len: u64, __advice: s32) -> s32 #foreign libc;
+
+/* This is the POSIX name for this function.  */
+posix_madvise :: (__addr: *void, __len: u64, __advice: s32) -> s32 #foreign libc;
+
+/* Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to
+be memory resident.  */
+mlock :: (__addr: *void, __len: u64) -> s32 #foreign libc;
+
+/* Unlock whole pages previously mapped by the range [ADDR,ADDR+LEN).  */
+munlock :: (__addr: *void, __len: u64) -> s32 #foreign libc;
+
+/* Cause all currently mapped pages of the process to be memory resident
+until unlocked by a call to the `munlockall', until the process exits,
+or until the process calls `execve'.  */
+mlockall :: (__flags: s32) -> s32 #foreign libc;
+
+/* All currently mapped pages of the process' address space become
+unlocked.  */
+munlockall :: () -> s32 #foreign libc;
+
+/* mincore returns the memory residency status of the pages in the
+current process's address space specified by [start, start + len).
+The status is returned in a vector of bytes.  The least significant
+bit of each byte is 1 if the referenced page is in memory, otherwise
+it is zero.  */
+mincore :: (__start: *void, __len: u64, __vec: *u8) -> s32 #foreign libc;
+
+/* Remap pages mapped by the range [ADDR,ADDR+OLD_LEN) to new length
+NEW_LEN.  If MREMAP_MAYMOVE is set in FLAGS the returned address
+may differ from ADDR.  If MREMAP_FIXED is set in FLAGS the function
+takes another parameter which is a fixed address at which the block
+resides after a successful call.  */
+mremap :: (__addr: *void, __old_len: u64, __new_len: u64, __flags: s32, __args: ..Any) -> *void #foreign libc;
+
+/* Remap arbitrary pages of a shared backing store within an existing
+VMA.  */
+remap_file_pages :: (__start: *void, __size: u64, __prot: s32, __pgoff: u64, __flags: s32) -> s32 #foreign libc;
+
+/* Open shared memory segment.  */
+shm_open :: (__name: *u8, __oflag: s32, __mode: mode_t) -> s32 #foreign libc;
+
+/* Remove shared memory segment.  */
+shm_unlink :: (__name: *u8) -> s32 #foreign libc;
+
+/* Type used for the number of file descriptors.  */
+nfds_t :: u64;
+
+/* Data structure describing a polling request.  */
+pollfd :: struct {
+    fd:      s32; /* File descriptor to poll.  */
+    events:  s16; /* Types of events poller cares about.  */
+    revents: s16; /* Types of events that actually occurred.  */
+}
+
+/* Poll the file descriptors described by the NFDS structures starting at
+FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
+an event to occur; if TIMEOUT is -1, block until an event occurs.
+Returns the number of file descriptors with events, zero if timed out,
+or -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+poll :: (__fds: *pollfd, __nfds: nfds_t, __timeout: s32) -> s32 #foreign libc;
+
+/* Like poll, but before waiting the threads signal mask is replaced
+with that specified in the fourth parameter.  For better usability,
+the timeout value is specified using a TIMESPEC object.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+ppoll :: (__fds: *pollfd, __nfds: nfds_t, __timeout: *timespec, __ss: *__sigset_t) -> s32 #foreign libc;
+
+shmatt_t :: u64;
+
+shmid_ds :: struct {
+    shm_perm:          ipc_perm;
+    shm_segsz:         u64;
+
+    shm_atime:         s64;
+    shm_dtime:         s64;
+    shm_ctime:         s64;
+
+    shm_cpid:          s32;
+    shm_lpid:          s32;
+    shm_nattch:        shmatt_t;
+    __glibc_reserved5: u64;
+    __glibc_reserved6: u64;
+}
+
+shminfo :: struct {
+    shmmax:            u64;
+    shmmin:            u64;
+    shmmni:            u64;
+    shmseg:            u64;
+    shmall:            u64;
+    __glibc_reserved1: u64;
+    __glibc_reserved2: u64;
+    __glibc_reserved3: u64;
+    __glibc_reserved4: u64;
+}
+
+shm_info :: struct {
+    used_ids:       s32;
+    shm_tot:        u64;
+    shm_rss:        u64;
+    shm_swp:        u64;
+    swap_attempts:  u64;
+    swap_successes: u64;
+}
+
+shmctl :: (__shmid: s32, __cmd: s32, __buf: *shmid_ds) -> s32 #foreign libc;
+
+/* Get shared memory segment.  */
+shmget :: (__key: key_t, __size: u64, __shmflg: s32) -> s32 #foreign libc;
+
+/* Attach shared memory segment.  */
+shmat :: (__shmid: s32, __shmaddr: *void, __shmflg: s32) -> *void #foreign libc;
+
+/* Detach shared memory segment.  */
+shmdt :: (__shmaddr: *void) -> s32 #foreign libc;
+
+/* Structure describing the system and machine.  */
+utsname :: struct {
+    /* Name of the implementation of the operating system.  */
+    sysname:    [65] u8;
+
+    /* Name of this node on the network.  */
+    nodename:   [65] u8;
+
+    /* Current release level of this implementation.  */
+    release:    [65] u8;
+
+    /* Current version level of this release.  */
+    version:    [65] u8;
+
+    /* Name of the hardware type the system is running on.  */
+    machine:    [65] u8;
+
+    domainname: [65] u8;
+}
+
+/* Put information about the system in NAME.  */
+uname :: (__name: *utsname) -> s32 #foreign libc;
+
+idtype_t :: enum u32 {
+    ALL   :: 0;
+    PID   :: 1;
+    PGID  :: 2;
+    PIDFD :: 3;
+
+    P_ALL   :: ALL;
+    P_PID   :: PID;
+    P_PGID  :: PGID;
+    P_PIDFD :: PIDFD;
+}
+
+/* Wait for a child to die.  When one does, put its status in *STAT_LOC
+and return its process ID.  For errors, return (pid_t) -1.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+wait :: (__stat_loc: *s32) -> s32 #foreign libc;
+
+/* Wait for a child matching PID to die.
+If PID is greater than 0, match any process whose process ID is PID.
+If PID is (pid_t) -1, match any process.
+If PID is (pid_t) 0, match any process with the
+same process group as the current process.
+If PID is less than -1, match any process whose
+process group is the absolute value of PID.
+If the WNOHANG bit is set in OPTIONS, and that child
+is not already dead, return (pid_t) 0.  If successful,
+return PID and store the dead child's status in STAT_LOC.
+Return (pid_t) -1 for errors.  If the WUNTRACED bit is
+set in OPTIONS, return status for stopped children; otherwise don't.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+waitpid :: (__pid: s32, __stat_loc: *s32, __options: s32) -> s32 #foreign libc;
+
+/* Wait for a childing matching IDTYPE and ID to change the status and
+place appropriate information in *INFOP.
+If IDTYPE is P_PID, match any process whose process ID is ID.
+If IDTYPE is P_PGID, match any process whose process group is ID.
+If IDTYPE is P_ALL, match any process.
+If the WNOHANG bit is set in OPTIONS, and that child
+is not already dead, clear *INFOP and return 0.  If successful, store
+exit code and status in *INFOP.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+waitid :: (__idtype: idtype_t, __id: u32, __infop: *siginfo_t, __options: s32) -> s32 #foreign libc;
+
+wait3 :: (__stat_loc: *s32, __options: s32, __usage: *rusage) -> s32 #foreign libc;
+
+/* PID is like waitpid.  Other args are like wait3.  */
+wait4 :: (__pid: s32, __stat_loc: *s32, __options: s32, __usage: *rusage) -> s32 #foreign libc;
+
+timex :: struct {
+    modes:        u32;
+    offset:       s64;
+    freq:         s64;
+    maxerror:     s64;
+    esterror:     s64;
+    status:       s32;
+    constant:     s64;
+    precision:    s64;
+    tolerance:    s64;
+    time:         timeval;
+    tick:         s64;
+    ppsfreq:      s64;
+    jitter:       s64;
+    shift:        s32;
+    stabil:       s64;
+    jitcnt:       s64;
+    calcnt:       s64;
+    errcnt:       s64;
+    stbcnt:       s64;
+
+    tai:          s32;
+
+    anon_decl:    s32;
+    anon_decl_1:  s32;
+    anon_decl_2:  s32;
+    anon_decl_3:  s32;
+    anon_decl_4:  s32;
+    anon_decl_5:  s32;
+    anon_decl_6:  s32;
+    anon_decl_7:  s32;
+    anon_decl_8:  s32;
+    anon_decl_9:  s32;
+    anon_decl_10: s32;
+}
+
+clock_adjtime :: (__clock_id: s32, __utx: *timex) -> s32 #foreign libc;
+
+tm :: struct {
+    tm_sec:    s32;
+    tm_min:    s32;
+    tm_hour:   s32;
+    tm_mday:   s32;
+    tm_mon:    s32;
+    tm_year:   s32;
+    tm_wday:   s32;
+    tm_yday:   s32;
+    tm_isdst:  s32;
+
+    tm_gmtoff: s64;
+    tm_zone:   *u8;
+}
+
+itimerspec :: struct {
+    it_interval: timespec;
+    it_value:    timespec;
+}
+
+__locale_struct :: struct {
+    __locale_data :: struct {}
+    __locales:       [13] *__locale_data;
+
+    __ctype_b:       *u16;
+    __ctype_tolower: *s32;
+    __ctype_toupper: *s32;
+
+    __names:         [13] *u8;
+}
+
+locale_t :: *__locale_struct;
+
+/* Time used by the program so far (user time + system time).
+The result / CLOCKS_PER_SEC is program time in seconds.  */
+clock :: () -> clock_t #foreign libc;
+
+/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
+time :: (__timer: *time_t) -> time_t #foreign libc;
+
+/* Return the difference between TIME1 and TIME0.  */
+difftime :: (__time1: time_t, __time0: time_t) -> float64 #foreign libc;
+
+/* Return the `time_t' representation of TP and normalize TP.  */
+mktime :: (__tp: *tm) -> time_t #foreign libc;
+
+/* Format TP into S according to FORMAT.
+Write no more than MAXSIZE characters and return the number
+of characters written, or 0 if it would exceed MAXSIZE.  */
+strftime :: (__s: *u8, __maxsize: u64, __format: *u8, __tp: *tm) -> u64 #foreign libc;
+
+/* Parse S according to FORMAT and store binary time information in TP.
+The return value is a pointer to the first unparsed character in S.  */
+strptime :: (__s: *u8, __fmt: *u8, __tp: *tm) -> *u8 #foreign libc;
+
+/* Similar to the two functions above but take the information from
+the provided locale and not the global locale.  */
+strftime_l :: (__s: *u8, __maxsize: u64, __format: *u8, __tp: *tm, __loc: locale_t) -> u64 #foreign libc;
+
+strptime_l :: (__s: *u8, __fmt: *u8, __tp: *tm, __loc: locale_t) -> *u8 #foreign libc;
+
+/* Return the `struct tm' representation of *TIMER
+in Universal Coordinated Time (aka Greenwich Mean Time).  */
+gmtime :: (__timer: *time_t) -> *tm #foreign libc;
+
+/* Return the `struct tm' representation
+of *TIMER in the local timezone.  */
+localtime :: (__timer: *time_t) -> *tm #foreign libc;
+
+/* Return the `struct tm' representation of *TIMER in UTC,
+using *TP to store the result.  */
+gmtime_r :: (__timer: *time_t, __tp: *tm) -> *tm #foreign libc;
+
+/* Return the `struct tm' representation of *TIMER in local time,
+using *TP to store the result.  */
+localtime_r :: (__timer: *time_t, __tp: *tm) -> *tm #foreign libc;
+
+/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+that is the representation of TP in this format.  */
+asctime :: (__tp: *tm) -> *u8 #foreign libc;
+
+ctime :: (__timer: *time_t) -> *u8 #foreign libc;
+
+/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
+that is the representation of TP in this format.  */
+asctime_r :: (__tp: *tm, __buf: *u8) -> *u8 #foreign libc;
+
+ctime_r :: (__timer: *time_t, __buf: *u8) -> *u8 #foreign libc;
+
+__tzname: [2] *u8 #elsewhere libc; /* Current timezone names.  */
+__daylight: s32 #elsewhere libc; /* If daylight-saving time is ever in use.  */
+__timezone: s64 #elsewhere libc; /* Seconds west of UTC.  */
+
+/* Same as above.  */
+tzname: [2] *u8 #elsewhere libc;
+
+/* Set time conversion information from the TZ environment variable.
+If TZ is not defined, a locale-dependent default is used.  */
+tzset :: () -> void #foreign libc;
+
+daylight: s32 #elsewhere libc;
+
+/* Like `mktime', but for TP represents Universal Time, not local time.  */
+timegm :: (__tp: *tm) -> time_t #foreign libc;
+
+/* Another name for `mktime'.  */
+timelocal :: (__tp: *tm) -> time_t #foreign libc;
+
+/* Return the number of days in YEAR.  */
+dysize :: (__year: s32) -> s32 #foreign libc;
+
+/* Pause execution for a number of nanoseconds.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+nanosleep :: (__requested_time: *timespec, __remaining: *timespec) -> s32 #foreign libc;
+
+/* Get resolution of clock CLOCK_ID.  */
+clock_getres :: (__clock_id: clockid_t, __res: *timespec) -> s32 #foreign libc;
+
+/* Get current value of clock CLOCK_ID and store it in TP.  */
+clock_gettime :: (__clock_id: clockid_t, __tp: *timespec) -> s32 #foreign libc;
+
+/* Set clock CLOCK_ID to value TP.  */
+clock_settime :: (__clock_id: clockid_t, __tp: *timespec) -> s32 #foreign libc;
+
+clock_nanosleep :: (__clock_id: clockid_t, __flags: s32, __req: *timespec, __rem: *timespec) -> s32 #foreign libc;
+
+/* Return clock ID for CPU-time clock.  */
+clock_getcpuclockid :: (__pid: pid_t, __clock_id: *clockid_t) -> s32 #foreign libc;
+
+/* Create new per-process timer using CLOCK_ID.  */
+timer_create :: (__clock_id: clockid_t, __evp: *sigevent, __timerid: *timer_t) -> s32 #foreign libc;
+
+/* Delete timer TIMERID.  */
+timer_delete :: (__timerid: timer_t) -> s32 #foreign libc;
+
+timer_settime :: (__timerid: timer_t, __flags: s32, __value: *itimerspec, __ovalue: *itimerspec) -> s32 #foreign libc;
+
+/* Get current value of timer TIMERID and store it in VALUE.  */
+timer_gettime :: (__timerid: timer_t, __value: *itimerspec) -> s32 #foreign libc;
+
+/* Get expiration overrun for timer TIMERID.  */
+timer_getoverrun :: (__timerid: timer_t) -> s32 #foreign libc;
+
+/* Set TS to calendar time based in time base BASE.  */
+timespec_get :: (__ts: *timespec, __base: s32) -> s32 #foreign libc;
+
+/* Set TS to resolution of time base BASE.  */
+timespec_getres :: (__ts: *timespec, __base: s32) -> s32 #foreign libc;
+
+/* Set to one of the following values to indicate an error.
+1  the DATEMSK environment variable is null or undefined,
+2  the template file cannot be opened for reading,
+3  failed to get file status information,
+4  the template file is not a regular file,
+5  an error is encountered while reading the template file,
+6  memory allication failed (not enough memory available),
+7  there is no line in the template that matches the input,
+8  invalid input specification Example: February 31 or a time is
+specified that can not be represented in a time_t (representing
+the time in seconds since 00:00:00 UTC, January 1, 1970) */
+getdate_err: s32 #elsewhere libc;
+
+/* Parse the given string as a date specification and return a value
+representing the value.  The templates from the file identified by
+the environment variable DATEMSK are used.  In case of an error
+`getdate_err' is set.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getdate :: (__string: *u8) -> *tm #foreign libc;
+
+/* Since `getdate' is not reentrant because of the use of `getdate_err'
+and the static buffer to return the result in, we provide a thread-safe
+variant.  The functionality is the same.  The result is returned in
+the buffer pointed to by RESBUFP and in case of an error the return
+value is != 0 with the same values as given above for `getdate_err'.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getdate_r :: (__string: *u8, __resbufp: *tm) -> s32 #foreign libc;
+
+iovec :: struct {
+    iov_base: *void;
+    iov_len:  u64;
+}
+
+/* Read data from file descriptor FD, and put the result in the
+buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
+The buffers are filled in the order specified.
+Operates just like 'read' (see <unistd.h>) except that data are
+put in IOVEC instead of a contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+readv :: (__fd: s32, __iovec: *iovec, __count: s32) -> s64 #foreign libc;
+
+/* Write data pointed by the buffers described by IOVEC, which
+is a vector of COUNT 'struct iovec's, to file descriptor FD.
+The data is written in the order specified.
+Operates just like 'write' (see <unistd.h>) except that the data
+are taken from IOVEC instead of a contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+writev :: (__fd: s32, __iovec: *iovec, __count: s32) -> s64 #foreign libc;
+
+/* Read data from file descriptor FD at the given position OFFSET
+without change the file pointer, and put the result in the buffers
+described by IOVEC, which is a vector of COUNT 'struct iovec's.
+The buffers are filled in the order specified.  Operates just like
+'pread' (see <unistd.h>) except that data are put in IOVEC instead
+of a contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+preadv :: (__fd: s32, __iovec: *iovec, __count: s32, __offset: s64) -> s64 #foreign libc;
+
+/* Write data pointed by the buffers described by IOVEC, which is a
+vector of COUNT 'struct iovec's, to file descriptor FD at the given
+position OFFSET without change the file pointer.  The data is
+written in the order specified.  Operates just like 'pwrite' (see
+<unistd.h>) except that the data are taken from IOVEC instead of a
+contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pwritev :: (__fd: s32, __iovec: *iovec, __count: s32, __offset: s64) -> s64 #foreign libc;
+
+/* Read data from file descriptor FD at the given position OFFSET
+without change the file pointer, and put the result in the buffers
+described by IOVEC, which is a vector of COUNT 'struct iovec's.
+The buffers are filled in the order specified.  Operates just like
+'pread' (see <unistd.h>) except that data are put in IOVEC instead
+of a contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+preadv64 :: (__fd: s32, __iovec: *iovec, __count: s32, __offset: s64) -> s64 #foreign libc;
+
+/* Write data pointed by the buffers described by IOVEC, which is a
+vector of COUNT 'struct iovec's, to file descriptor FD at the given
+position OFFSET without change the file pointer.  The data is
+written in the order specified.  Operates just like 'pwrite' (see
+<unistd.h>) except that the data are taken from IOVEC instead of a
+contiguous buffer.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pwritev64 :: (__fd: s32, __iovec: *iovec, __count: s32, __offset: s64) -> s64 #foreign libc;
+
+/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
+preadv2 :: (__fp: s32, __iovec: *iovec, __count: s32, __offset: s64, ___flags: s32) -> s64 #foreign libc;
+
+/* Same as preadv but with an additional flag argument defined at uio.h.  */
+pwritev2 :: (__fd: s32, __iodev: *iovec, __count: s32, __offset: s64, __flags: s32) -> s64 #foreign libc;
+
+/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
+preadv64v2 :: (__fp: s32, __iovec: *iovec, __count: s32, __offset: s64, ___flags: s32) -> s64 #foreign libc;
+
+/* Same as preadv but with an additional flag argument defined at uio.h.  */
+pwritev64v2 :: (__fd: s32, __iodev: *iovec, __count: s32, __offset: s64, __flags: s32) -> s64 #foreign libc;
+
+#scope_file
+
+#import "Basic"; // For U128/S128
+
+libc :: #library,system "libc";
+libdl :: #library,system "libdl";
+librt :: #library,system "librt";
diff --git a/modules/POSIX/bindings/linux/arm64/pthread.jai b/modules/POSIX/bindings/linux/arm64/pthread.jai
new file mode 100644
index 0000000..c96a606
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/pthread.jai
@@ -0,0 +1,902 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+SCHED_OTHER :: 0;
+SCHED_FIFO :: 1;
+SCHED_RR :: 2;
+
+SCHED_BATCH :: 3;
+SCHED_ISO :: 4;
+SCHED_IDLE :: 5;
+SCHED_DEADLINE :: 6;
+
+SCHED_RESET_ON_FORK :: 0x40000000;
+
+CSIGNAL :: 0x000000ff;
+CLONE_VM :: 0x00000100;
+CLONE_FS :: 0x00000200;
+CLONE_FILES :: 0x00000400;
+CLONE_SIGHAND :: 0x00000800;
+CLONE_PIDFD :: 0x00001000;
+
+CLONE_PTRACE :: 0x00002000;
+CLONE_VFORK :: 0x00004000;
+
+CLONE_PARENT :: 0x00008000;
+
+CLONE_THREAD :: 0x00010000;
+CLONE_NEWNS :: 0x00020000;
+CLONE_SYSVSEM :: 0x00040000;
+CLONE_SETTLS :: 0x00080000;
+CLONE_PARENT_SETTID :: 0x00100000;
+
+CLONE_CHILD_CLEARTID :: 0x00200000;
+
+CLONE_DETACHED :: 0x00400000;
+CLONE_UNTRACED :: 0x00800000;
+
+CLONE_CHILD_SETTID :: 0x01000000;
+
+CLONE_NEWCGROUP :: 0x02000000;
+CLONE_NEWUTS :: 0x04000000;
+CLONE_NEWIPC :: 0x08000000;
+CLONE_NEWUSER :: 0x10000000;
+CLONE_NEWPID :: 0x20000000;
+CLONE_NEWNET :: 0x40000000;
+CLONE_IO :: 0x80000000;
+
+CLONE_NEWTIME :: 0x00000080;
+
+_BITS_TYPES_STRUCT_SCHED_PARAM :: 1;
+
+__CPU_SETSIZE :: 1024;
+
+CPU_SETSIZE :: __CPU_SETSIZE;
+
+__PTHREAD_MUTEX_HAVE_PREV :: 1;
+
+__have_pthread_attr_t :: 1;
+
+__jmp_buf_tag_defined :: 1;
+
+PTHREAD_CANCELED :: cast,trunc(*void) -1;
+
+PTHREAD_ONCE_INIT :: 0;
+
+PTHREAD_BARRIER_SERIAL_THREAD :: -1;
+
+PTHREAD_ATTR_NO_SIGMASK_NP :: -1;
+
+sched_param :: struct {
+    sched_priority: s32;
+}
+
+clone :: (__fn: #type (__arg: *void) -> s32 #c_call, __child_stack: *void, __flags: s32, __arg: *void, __args: ..Any) -> s32 #foreign libpthread;
+
+unshare :: (__flags: s32) -> s32 #foreign libpthread;
+
+sched_getcpu :: () -> s32 #foreign libpthread;
+
+getcpu :: (unknown0: *u32, unknown1: *u32) -> s32 #foreign libpthread;
+
+setns :: (__fd: s32, __nstype: s32) -> s32 #foreign libpthread;
+
+__cpu_mask :: u64;
+
+cpu_set_t :: struct {
+    __bits: [16] __cpu_mask;
+}
+
+__sched_cpucount :: (__setsize: u64, __setp: *cpu_set_t) -> s32 #foreign libpthread;
+
+__sched_cpualloc :: (__count: u64) -> *cpu_set_t #foreign libpthread;
+__sched_cpufree :: (__set: *cpu_set_t) -> void #foreign libpthread;
+
+sched_setparam :: (__pid: s32, __param: *sched_param) -> s32 #foreign libpthread;
+
+sched_getparam :: (__pid: s32, __param: *sched_param) -> s32 #foreign libpthread;
+
+sched_setscheduler :: (__pid: s32, __policy: s32, __param: *sched_param) -> s32 #foreign libpthread;
+
+sched_getscheduler :: (__pid: s32) -> s32 #foreign libpthread;
+
+sched_yield :: () -> s32 #foreign libpthread;
+
+sched_get_priority_max :: (__algorithm: s32) -> s32 #foreign libpthread;
+
+sched_get_priority_min :: (__algorithm: s32) -> s32 #foreign libpthread;
+
+sched_rr_get_interval :: (__pid: s32, __t: *timespec) -> s32 #foreign libpthread;
+
+sched_setaffinity :: (__pid: s32, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+sched_getaffinity :: (__pid: s32, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+__pthread_internal_list :: struct {
+    __prev: *__pthread_internal_list;
+    __next: *__pthread_internal_list;
+}
+
+__pthread_internal_slist :: struct {
+    __next: *__pthread_internal_slist;
+}
+
+__pthread_mutex_s :: struct {
+    __lock:   s32;
+    __count:  u32;
+    __owner:  s32;
+
+    __nusers: u32;
+
+    __kind:   s32;
+
+    __spins:  s32;
+    __list:   __pthread_internal_list;
+}
+
+__pthread_rwlock_arch_t :: struct {
+    __readers:       u32;
+    __writers:       u32;
+    __wrphase_futex: u32;
+    __writers_futex: u32;
+    __pad3:          u32;
+    __pad4:          u32;
+    __cur_writer:    s32;
+    __shared:        s32;
+    __pad1:          u64;
+    __pad2:          u64;
+    __flags:         u32;
+}
+
+__pthread_cond_s :: struct {
+    __wseq:         u64;
+    __g1_start:     u64;
+    __g_refs:       [2] u32;
+    __g_size:       [2] u32;
+    __g1_orig_size: u32;
+    __wrefs:        u32;
+    __g_signals:    [2] u32;
+}
+
+__once_flag :: struct {
+    __data: s32;
+}
+
+pthread_t :: u64;
+
+pthread_mutexattr_t :: union {
+    __size:  [8] u8;
+    __align: s32;
+}
+
+pthread_condattr_t :: union {
+    __size:  [8] u8;
+    __align: s32;
+}
+
+pthread_key_t :: u32;
+
+pthread_once_t :: s32;
+
+pthread_attr_t :: union {
+    __size:  [64] u8;
+    __align: s64;
+}
+
+pthread_mutex_t :: union {
+    __data:  __pthread_mutex_s;
+    __size:  [48] u8;
+    __align: s64;
+}
+
+pthread_cond_t :: union {
+    __data:  __pthread_cond_s;
+    __size:  [48] u8;
+    __align: s64;
+}
+
+pthread_rwlock_t :: union {
+    __data:  __pthread_rwlock_arch_t;
+    __size:  [56] u8;
+    __align: s64;
+}
+
+pthread_rwlockattr_t :: union {
+    __size:  [8] u8;
+    __align: s64;
+}
+
+pthread_spinlock_t :: s32;
+
+pthread_barrier_t :: union {
+    __size:  [32] u8;
+    __align: s64;
+}
+
+pthread_barrierattr_t :: union {
+    __size:  [8] u8;
+    __align: s32;
+}
+
+__jmp_buf :: [22] u64;
+
+__sigset_t :: struct {
+    __val: [16] u64;
+}
+
+__jmp_buf_tag :: struct {
+    __jmpbuf:         __jmp_buf;
+    __mask_was_saved: s32;
+    __saved_mask:     __sigset_t;
+}
+
+/* Detach state.  */
+PTHREAD_CREATE :: enum u32 {
+    JOINABLE :: 0;
+
+    DETACHED :: 1;
+
+    PTHREAD_CREATE_JOINABLE :: JOINABLE;
+
+    PTHREAD_CREATE_DETACHED :: DETACHED;
+}
+
+/* Mutex types.  */
+PTHREAD_MUTEX :: enum u32 {
+    TIMED_NP      :: 0;
+    RECURSIVE_NP  :: 1;
+    ERRORCHECK_NP :: 2;
+    ADAPTIVE_NP   :: 3;
+
+    NORMAL        :: 0;
+    RECURSIVE     :: 1;
+    ERRORCHECK    :: 2;
+    DEFAULT       :: 0;
+
+    FAST_NP       :: 0;
+
+    PTHREAD_MUTEX_TIMED_NP      :: TIMED_NP;
+    PTHREAD_MUTEX_RECURSIVE_NP  :: RECURSIVE_NP;
+    PTHREAD_MUTEX_ERRORCHECK_NP :: ERRORCHECK_NP;
+    PTHREAD_MUTEX_ADAPTIVE_NP   :: ADAPTIVE_NP;
+
+    PTHREAD_MUTEX_NORMAL        :: NORMAL;
+    PTHREAD_MUTEX_RECURSIVE     :: RECURSIVE;
+    PTHREAD_MUTEX_ERRORCHECK    :: ERRORCHECK;
+    PTHREAD_MUTEX_DEFAULT       :: DEFAULT;
+
+    PTHREAD_MUTEX_FAST_NP       :: FAST_NP;
+}
+
+/* Robust mutex or not flags.  */
+PTHREAD_MUTEX_1 :: enum u32 {
+    STALLED    :: 0;
+    STALLED_NP :: 0;
+    ROBUST     :: 1;
+    ROBUST_NP  :: 1;
+
+    PTHREAD_MUTEX_STALLED    :: STALLED;
+    PTHREAD_MUTEX_STALLED_NP :: STALLED_NP;
+    PTHREAD_MUTEX_ROBUST     :: ROBUST;
+    PTHREAD_MUTEX_ROBUST_NP  :: ROBUST_NP;
+}
+
+/* Mutex protocols.  */
+PTHREAD_PRIO :: enum u32 {
+    NONE    :: 0;
+    INHERIT :: 1;
+    PROTECT :: 2;
+
+    PTHREAD_PRIO_NONE    :: NONE;
+    PTHREAD_PRIO_INHERIT :: INHERIT;
+    PTHREAD_PRIO_PROTECT :: PROTECT;
+}
+
+PTHREAD_RWLOCK :: enum u32 {
+    PREFER_READER_NP              :: 0;
+    PREFER_WRITER_NP              :: 1;
+    PREFER_WRITER_NONRECURSIVE_NP :: 2;
+    DEFAULT_NP                    :: 0;
+
+    PTHREAD_RWLOCK_PREFER_READER_NP              :: PREFER_READER_NP;
+    PTHREAD_RWLOCK_PREFER_WRITER_NP              :: PREFER_WRITER_NP;
+    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP :: PREFER_WRITER_NONRECURSIVE_NP;
+    PTHREAD_RWLOCK_DEFAULT_NP                    :: DEFAULT_NP;
+}
+
+/* Scheduler inheritance.  */
+PTHREAD :: enum u32 {
+    INHERIT_SCHED  :: 0;
+
+    EXPLICIT_SCHED :: 1;
+
+    PTHREAD_INHERIT_SCHED  :: INHERIT_SCHED;
+
+    PTHREAD_EXPLICIT_SCHED :: EXPLICIT_SCHED;
+}
+
+/* Scope handling.  */
+PTHREAD_SCOPE :: enum u32 {
+    SYSTEM  :: 0;
+
+    PROCESS :: 1;
+
+    PTHREAD_SCOPE_SYSTEM  :: SYSTEM;
+
+    PTHREAD_SCOPE_PROCESS :: PROCESS;
+}
+
+/* Process shared or private flag.  */
+PTHREAD_PROCESS :: enum u32 {
+    PRIVATE :: 0;
+
+    SHARED  :: 1;
+
+    PTHREAD_PROCESS_PRIVATE :: PRIVATE;
+
+    PTHREAD_PROCESS_SHARED  :: SHARED;
+}
+
+/* Cleanup buffers */
+_pthread_cleanup_buffer :: struct {
+    __routine:    #type (unknown0: *void) -> void #c_call; /* Function to call.  */
+    __arg:        *void; /* Its argument.  */
+    __canceltype: s32; /* Saved cancellation type. */
+    __prev:       *_pthread_cleanup_buffer; /* Chaining of cleanup functions.  */
+}
+
+/* Cancellation */
+PTHREAD_CANCEL :: enum u32 {
+    ENABLE  :: 0;
+
+    DISABLE :: 1;
+
+    PTHREAD_CANCEL_ENABLE  :: ENABLE;
+
+    PTHREAD_CANCEL_DISABLE :: DISABLE;
+}
+
+PTHREAD_CANCEL_1 :: enum u32 {
+    DEFERRED     :: 0;
+
+    ASYNCHRONOUS :: 1;
+
+    PTHREAD_CANCEL_DEFERRED     :: DEFERRED;
+
+    PTHREAD_CANCEL_ASYNCHRONOUS :: ASYNCHRONOUS;
+}
+
+/* Create a new thread, starting with execution of START-ROUTINE
+getting passed ARG.  Creation attributed come from ATTR.  The new
+handle is stored in *NEWTHREAD.  */
+pthread_create :: (__newthread: *pthread_t, __attr: *pthread_attr_t, __start_routine: #type (unknown0: *void) -> *void #c_call, __arg: *void) -> s32 #foreign libpthread;
+
+/* Terminate calling thread.
+
+The registered cleanup handlers are called via exception handling
+so we cannot mark this function with __THROW.*/
+pthread_exit :: (__retval: *void) -> void #foreign libpthread;
+
+/* Make calling thread wait for termination of the thread TH.  The
+exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
+is not NULL.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pthread_join :: (__th: pthread_t, __thread_return: **void) -> s32 #foreign libpthread;
+
+/* Check whether thread TH has terminated.  If yes return the status of
+the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
+pthread_tryjoin_np :: (__th: pthread_t, __thread_return: **void) -> s32 #foreign libpthread;
+
+/* Make calling thread wait for termination of the thread TH, but only
+until TIMEOUT.  The exit status of the thread is stored in
+*THREAD_RETURN, if THREAD_RETURN is not NULL.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pthread_timedjoin_np :: (__th: pthread_t, __thread_return: **void, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Make calling thread wait for termination of the thread TH, but only
+until TIMEOUT measured against the clock specified by CLOCKID.  The
+exit status of the thread is stored in *THREAD_RETURN, if
+THREAD_RETURN is not NULL.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pthread_clockjoin_np :: (__th: pthread_t, __thread_return: **void, __clockid: clockid_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
+The resources of TH will therefore be freed immediately when it
+terminates, instead of waiting for another thread to perform PTHREAD_JOIN
+on it.  */
+pthread_detach :: (__th: pthread_t) -> s32 #foreign libpthread;
+
+/* Obtain the identifier of the current thread.  */
+pthread_self :: () -> pthread_t #foreign libpthread;
+
+/* Compare two thread identifiers.  */
+pthread_equal :: (__thread1: pthread_t, __thread2: pthread_t) -> s32 #foreign libpthread;
+
+/* Initialize thread attribute *ATTR with default attributes
+(detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
+no user-provided stack).  */
+pthread_attr_init :: (__attr: *pthread_attr_t) -> s32 #foreign libpthread;
+
+/* Destroy thread attribute *ATTR.  */
+pthread_attr_destroy :: (__attr: *pthread_attr_t) -> s32 #foreign libpthread;
+
+/* Get detach state attribute.  */
+pthread_attr_getdetachstate :: (__attr: *pthread_attr_t, __detachstate: *s32) -> s32 #foreign libpthread;
+
+/* Set detach state attribute.  */
+pthread_attr_setdetachstate :: (__attr: *pthread_attr_t, __detachstate: s32) -> s32 #foreign libpthread;
+
+/* Get the size of the guard area created for stack overflow protection.  */
+pthread_attr_getguardsize :: (__attr: *pthread_attr_t, __guardsize: *u64) -> s32 #foreign libpthread;
+
+/* Set the size of the guard area created for stack overflow protection.  */
+pthread_attr_setguardsize :: (__attr: *pthread_attr_t, __guardsize: u64) -> s32 #foreign libpthread;
+
+/* Return in *PARAM the scheduling parameters of *ATTR.  */
+pthread_attr_getschedparam :: (__attr: *pthread_attr_t, __param: *sched_param) -> s32 #foreign libpthread;
+
+/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
+pthread_attr_setschedparam :: (__attr: *pthread_attr_t, __param: *sched_param) -> s32 #foreign libpthread;
+
+/* Return in *POLICY the scheduling policy of *ATTR.  */
+pthread_attr_getschedpolicy :: (__attr: *pthread_attr_t, __policy: *s32) -> s32 #foreign libpthread;
+
+/* Set scheduling policy in *ATTR according to POLICY.  */
+pthread_attr_setschedpolicy :: (__attr: *pthread_attr_t, __policy: s32) -> s32 #foreign libpthread;
+
+/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
+pthread_attr_getinheritsched :: (__attr: *pthread_attr_t, __inherit: *s32) -> s32 #foreign libpthread;
+
+/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
+pthread_attr_setinheritsched :: (__attr: *pthread_attr_t, __inherit: s32) -> s32 #foreign libpthread;
+
+/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
+pthread_attr_getscope :: (__attr: *pthread_attr_t, __scope: *s32) -> s32 #foreign libpthread;
+
+/* Set scheduling contention scope in *ATTR according to SCOPE.  */
+pthread_attr_setscope :: (__attr: *pthread_attr_t, __scope: s32) -> s32 #foreign libpthread;
+
+/* Return the previously set address for the stack.  */
+pthread_attr_getstackaddr :: (__attr: *pthread_attr_t, __stackaddr: **void) -> s32 #foreign libpthread;
+
+/* Set the starting address of the stack of the thread to be created.
+Depending on whether the stack grows up or down the value must either
+be higher or lower than all the address in the memory block.  The
+minimal size of the block must be PTHREAD_STACK_MIN.  */
+pthread_attr_setstackaddr :: (__attr: *pthread_attr_t, __stackaddr: *void) -> s32 #foreign libpthread;
+
+/* Return the currently used minimal stack size.  */
+pthread_attr_getstacksize :: (__attr: *pthread_attr_t, __stacksize: *u64) -> s32 #foreign libpthread;
+
+/* Add information about the minimum stack size needed for the thread
+to be started.  This size must never be less than PTHREAD_STACK_MIN
+and must also not exceed the system limits.  */
+pthread_attr_setstacksize :: (__attr: *pthread_attr_t, __stacksize: u64) -> s32 #foreign libpthread;
+
+/* Return the previously set address for the stack.  */
+pthread_attr_getstack :: (__attr: *pthread_attr_t, __stackaddr: **void, __stacksize: *u64) -> s32 #foreign libpthread;
+
+/* The following two interfaces are intended to replace the last two.  They
+require setting the address as well as the size since only setting the
+address will make the implementation on some architectures impossible.  */
+pthread_attr_setstack :: (__attr: *pthread_attr_t, __stackaddr: *void, __stacksize: u64) -> s32 #foreign libpthread;
+
+/* Thread created with attribute ATTR will be limited to run only on
+the processors represented in CPUSET.  */
+pthread_attr_setaffinity_np :: (__attr: *pthread_attr_t, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+/* Get bit set in CPUSET representing the processors threads created with
+ATTR can run on.  */
+pthread_attr_getaffinity_np :: (__attr: *pthread_attr_t, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+/* Get the default attributes used by pthread_create in this process.  */
+pthread_getattr_default_np :: (__attr: *pthread_attr_t) -> s32 #foreign libpthread;
+
+/* Store *SIGMASK as the signal mask for the new thread in *ATTR.  */
+pthread_attr_setsigmask_np :: (__attr: *pthread_attr_t, sigmask: *__sigset_t) -> s32 #foreign libpthread;
+
+/* Store the signal mask of *ATTR in *SIGMASK.  If there is no signal
+mask stored, return PTHREAD_ATTR_NOSIGMASK_NP.  Return zero on
+success.  */
+pthread_attr_getsigmask_np :: (__attr: *pthread_attr_t, sigmask: *__sigset_t) -> s32 #foreign libpthread;
+
+/* Set the default attributes to be used by pthread_create in this
+process.  */
+pthread_setattr_default_np :: (__attr: *pthread_attr_t) -> s32 #foreign libpthread;
+
+/* Initialize thread attribute *ATTR with attributes corresponding to the
+already running thread TH.  It shall be called on uninitialized ATTR
+and destroyed with pthread_attr_destroy when no longer needed.  */
+pthread_getattr_np :: (__th: pthread_t, __attr: *pthread_attr_t) -> s32 #foreign libpthread;
+
+/* Set the scheduling parameters for TARGET_THREAD according to POLICY
+and *PARAM.  */
+pthread_setschedparam :: (__target_thread: pthread_t, __policy: s32, __param: *sched_param) -> s32 #foreign libpthread;
+
+/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */
+pthread_getschedparam :: (__target_thread: pthread_t, __policy: *s32, __param: *sched_param) -> s32 #foreign libpthread;
+
+/* Set the scheduling priority for TARGET_THREAD.  */
+pthread_setschedprio :: (__target_thread: pthread_t, __prio: s32) -> s32 #foreign libpthread;
+
+/* Get thread name visible in the kernel and its interfaces.  */
+pthread_getname_np :: (__target_thread: pthread_t, __buf: *u8, __buflen: u64) -> s32 #foreign libpthread;
+
+/* Set thread name visible in the kernel and its interfaces.  */
+pthread_setname_np :: (__target_thread: pthread_t, __name: *u8) -> s32 #foreign libpthread;
+
+/* Determine level of concurrency.  */
+pthread_getconcurrency :: () -> s32 #foreign libpthread;
+
+/* Set new concurrency level to LEVEL.  */
+pthread_setconcurrency :: (__level: s32) -> s32 #foreign libpthread;
+
+/* Limit specified thread TH to run only on the processors represented
+in CPUSET.  */
+pthread_setaffinity_np :: (__th: pthread_t, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+/* Get bit set in CPUSET representing the processors TH can run on.  */
+pthread_getaffinity_np :: (__th: pthread_t, __cpusetsize: u64, __cpuset: *cpu_set_t) -> s32 #foreign libpthread;
+
+/* Guarantee that the initialization function INIT_ROUTINE will be called
+only once, even if pthread_once is executed several times with the
+same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
+extern variable initialized to PTHREAD_ONCE_INIT.
+
+The initialization functions might throw exception which is why
+this function is not marked with __THROW.  */
+pthread_once :: (__once_control: *pthread_once_t, __init_routine: #type () -> void #c_call) -> s32 #foreign libpthread;
+
+/* Set cancelability state of current thread to STATE, returning old
+state in *OLDSTATE if OLDSTATE is not NULL.  */
+pthread_setcancelstate :: (__state: s32, __oldstate: *s32) -> s32 #foreign libpthread;
+
+/* Set cancellation state of current thread to TYPE, returning the old
+type in *OLDTYPE if OLDTYPE is not NULL.  */
+pthread_setcanceltype :: (__type: s32, __oldtype: *s32) -> s32 #foreign libpthread;
+
+/* Cancel THREAD immediately or at the next possibility.  */
+pthread_cancel :: (__th: pthread_t) -> s32 #foreign libpthread;
+
+/* Test for pending cancellation for the current thread and terminate
+the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
+cancelled.  */
+pthread_testcancel :: () -> void #foreign libpthread;
+
+/* Cancellation handling with integration into exception handling.  */
+__cancel_jmp_buf_tag :: struct {
+    __cancel_jmp_buf: __jmp_buf;
+    __mask_was_saved: s32;
+}
+
+__pthread_unwind_buf_t :: struct {
+    __cancel_jmp_buf: [1] __cancel_jmp_buf_tag;
+    __pad:            [4] *void;
+}
+
+/* Structure to hold the cleanup handler information.  */
+__pthread_cleanup_frame :: struct {
+    __cancel_routine: #type (unknown0: *void) -> void #c_call;
+    __cancel_arg:     *void;
+    __do_it:          s32;
+    __cancel_type:    s32;
+}
+
+__pthread_register_cancel :: (__buf: *__pthread_unwind_buf_t) -> void #foreign libpthread;
+
+__pthread_unregister_cancel :: (__buf: *__pthread_unwind_buf_t) -> void #foreign libpthread;
+
+__pthread_register_cancel_defer :: (__buf: *__pthread_unwind_buf_t) -> void #foreign libpthread;
+
+__pthread_unregister_cancel_restore :: (__buf: *__pthread_unwind_buf_t) -> void #foreign libpthread;
+
+/* Internal interface to initiate cleanup.  */
+__pthread_unwind_next :: (__buf: *__pthread_unwind_buf_t) -> void #foreign libpthread;
+
+/* Store the calling environment in ENV, also saving the
+signal mask if SAVEMASK is nonzero.  Return 0.
+This is the internal name for `sigsetjmp'.  */
+__sigsetjmp :: (__env: *[1] __jmp_buf_tag, __savemask: s32) -> s32 #foreign libpthread;
+
+/* Initialize a mutex.  */
+pthread_mutex_init :: (__mutex: *pthread_mutex_t, __mutexattr: *pthread_mutexattr_t) -> s32 #foreign libpthread;
+
+/* Destroy a mutex.  */
+pthread_mutex_destroy :: (__mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+/* Try locking a mutex.  */
+pthread_mutex_trylock :: (__mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+/* Lock a mutex.  */
+pthread_mutex_lock :: (__mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+pthread_mutex_timedlock :: (__mutex: *pthread_mutex_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+pthread_mutex_clocklock :: (__mutex: *pthread_mutex_t, __clockid: clockid_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Unlock a mutex.  */
+pthread_mutex_unlock :: (__mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+/* Get the priority ceiling of MUTEX.  */
+pthread_mutex_getprioceiling :: (__mutex: *pthread_mutex_t, __prioceiling: *s32) -> s32 #foreign libpthread;
+
+/* Set the priority ceiling of MUTEX to PRIOCEILING, return old
+priority ceiling value in *OLD_CEILING.  */
+pthread_mutex_setprioceiling :: (__mutex: *pthread_mutex_t, __prioceiling: s32, __old_ceiling: *s32) -> s32 #foreign libpthread;
+
+/* Declare the state protected by MUTEX as consistent.  */
+pthread_mutex_consistent :: (__mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+/* Initialize mutex attribute object ATTR with default attributes
+(kind is PTHREAD_MUTEX_TIMED_NP).  */
+pthread_mutexattr_init :: (__attr: *pthread_mutexattr_t) -> s32 #foreign libpthread;
+
+/* Destroy mutex attribute object ATTR.  */
+pthread_mutexattr_destroy :: (__attr: *pthread_mutexattr_t) -> s32 #foreign libpthread;
+
+/* Get the process-shared flag of the mutex attribute ATTR.  */
+pthread_mutexattr_getpshared :: (__attr: *pthread_mutexattr_t, __pshared: *s32) -> s32 #foreign libpthread;
+
+/* Set the process-shared flag of the mutex attribute ATTR.  */
+pthread_mutexattr_setpshared :: (__attr: *pthread_mutexattr_t, __pshared: s32) -> s32 #foreign libpthread;
+
+/* Return in *KIND the mutex kind attribute in *ATTR.  */
+pthread_mutexattr_gettype :: (__attr: *pthread_mutexattr_t, __kind: *s32) -> s32 #foreign libpthread;
+
+/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
+PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
+PTHREAD_MUTEX_DEFAULT).  */
+pthread_mutexattr_settype :: (__attr: *pthread_mutexattr_t, __kind: s32) -> s32 #foreign libpthread;
+
+/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
+pthread_mutexattr_getprotocol :: (__attr: *pthread_mutexattr_t, __protocol: *s32) -> s32 #foreign libpthread;
+
+/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
+PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */
+pthread_mutexattr_setprotocol :: (__attr: *pthread_mutexattr_t, __protocol: s32) -> s32 #foreign libpthread;
+
+/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */
+pthread_mutexattr_getprioceiling :: (__attr: *pthread_mutexattr_t, __prioceiling: *s32) -> s32 #foreign libpthread;
+
+/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */
+pthread_mutexattr_setprioceiling :: (__attr: *pthread_mutexattr_t, __prioceiling: s32) -> s32 #foreign libpthread;
+
+/* Get the robustness flag of the mutex attribute ATTR.  */
+pthread_mutexattr_getrobust :: (__attr: *pthread_mutexattr_t, __robustness: *s32) -> s32 #foreign libpthread;
+
+/* Set the robustness flag of the mutex attribute ATTR.  */
+pthread_mutexattr_setrobust :: (__attr: *pthread_mutexattr_t, __robustness: s32) -> s32 #foreign libpthread;
+
+/* Initialize read-write lock RWLOCK using attributes ATTR, or use
+the default values if later is NULL.  */
+pthread_rwlock_init :: (__rwlock: *pthread_rwlock_t, __attr: *pthread_rwlockattr_t) -> s32 #foreign libpthread;
+
+/* Destroy read-write lock RWLOCK.  */
+pthread_rwlock_destroy :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+/* Acquire read lock for RWLOCK.  */
+pthread_rwlock_rdlock :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+/* Try to acquire read lock for RWLOCK.  */
+pthread_rwlock_tryrdlock :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+pthread_rwlock_timedrdlock :: (__rwlock: *pthread_rwlock_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+pthread_rwlock_clockrdlock :: (__rwlock: *pthread_rwlock_t, __clockid: clockid_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Acquire write lock for RWLOCK.  */
+pthread_rwlock_wrlock :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+/* Try to acquire write lock for RWLOCK.  */
+pthread_rwlock_trywrlock :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+pthread_rwlock_timedwrlock :: (__rwlock: *pthread_rwlock_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+pthread_rwlock_clockwrlock :: (__rwlock: *pthread_rwlock_t, __clockid: clockid_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Unlock RWLOCK.  */
+pthread_rwlock_unlock :: (__rwlock: *pthread_rwlock_t) -> s32 #foreign libpthread;
+
+/* Initialize attribute object ATTR with default values.  */
+pthread_rwlockattr_init :: (__attr: *pthread_rwlockattr_t) -> s32 #foreign libpthread;
+
+/* Destroy attribute object ATTR.  */
+pthread_rwlockattr_destroy :: (__attr: *pthread_rwlockattr_t) -> s32 #foreign libpthread;
+
+/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
+pthread_rwlockattr_getpshared :: (__attr: *pthread_rwlockattr_t, __pshared: *s32) -> s32 #foreign libpthread;
+
+/* Set process-shared attribute of ATTR to PSHARED.  */
+pthread_rwlockattr_setpshared :: (__attr: *pthread_rwlockattr_t, __pshared: s32) -> s32 #foreign libpthread;
+
+/* Return current setting of reader/writer preference.  */
+pthread_rwlockattr_getkind_np :: (__attr: *pthread_rwlockattr_t, __pref: *s32) -> s32 #foreign libpthread;
+
+/* Set reader/write preference.  */
+pthread_rwlockattr_setkind_np :: (__attr: *pthread_rwlockattr_t, __pref: s32) -> s32 #foreign libpthread;
+
+/* Initialize condition variable COND using attributes ATTR, or use
+the default values if later is NULL.  */
+pthread_cond_init :: (__cond: *pthread_cond_t, __cond_attr: *pthread_condattr_t) -> s32 #foreign libpthread;
+
+/* Destroy condition variable COND.  */
+pthread_cond_destroy :: (__cond: *pthread_cond_t) -> s32 #foreign libpthread;
+
+/* Wake up one thread waiting for condition variable COND.  */
+pthread_cond_signal :: (__cond: *pthread_cond_t) -> s32 #foreign libpthread;
+
+/* Wake up all threads waiting for condition variables COND.  */
+pthread_cond_broadcast :: (__cond: *pthread_cond_t) -> s32 #foreign libpthread;
+
+/* Wait for condition variable COND to be signaled or broadcast.
+MUTEX is assumed to be locked before.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+pthread_cond_wait :: (__cond: *pthread_cond_t, __mutex: *pthread_mutex_t) -> s32 #foreign libpthread;
+
+pthread_cond_timedwait :: (__cond: *pthread_cond_t, __mutex: *pthread_mutex_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+pthread_cond_clockwait :: (__cond: *pthread_cond_t, __mutex: *pthread_mutex_t, __clock_id: s32, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Initialize condition variable attribute ATTR.  */
+pthread_condattr_init :: (__attr: *pthread_condattr_t) -> s32 #foreign libpthread;
+
+/* Destroy condition variable attribute ATTR.  */
+pthread_condattr_destroy :: (__attr: *pthread_condattr_t) -> s32 #foreign libpthread;
+
+/* Get the process-shared flag of the condition variable attribute ATTR.  */
+pthread_condattr_getpshared :: (__attr: *pthread_condattr_t, __pshared: *s32) -> s32 #foreign libpthread;
+
+/* Set the process-shared flag of the condition variable attribute ATTR.  */
+pthread_condattr_setpshared :: (__attr: *pthread_condattr_t, __pshared: s32) -> s32 #foreign libpthread;
+
+/* Get the clock selected for the condition variable attribute ATTR.  */
+pthread_condattr_getclock :: (__attr: *pthread_condattr_t, __clock_id: *s32) -> s32 #foreign libpthread;
+
+/* Set the clock selected for the condition variable attribute ATTR.  */
+pthread_condattr_setclock :: (__attr: *pthread_condattr_t, __clock_id: s32) -> s32 #foreign libpthread;
+
+/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
+be shared between different processes.  */
+pthread_spin_init :: (__lock: *pthread_spinlock_t, __pshared: s32) -> s32 #foreign libpthread;
+
+/* Destroy the spinlock LOCK.  */
+pthread_spin_destroy :: (__lock: *pthread_spinlock_t) -> s32 #foreign libpthread;
+
+/* Wait until spinlock LOCK is retrieved.  */
+pthread_spin_lock :: (__lock: *pthread_spinlock_t) -> s32 #foreign libpthread;
+
+/* Try to lock spinlock LOCK.  */
+pthread_spin_trylock :: (__lock: *pthread_spinlock_t) -> s32 #foreign libpthread;
+
+/* Release spinlock LOCK.  */
+pthread_spin_unlock :: (__lock: *pthread_spinlock_t) -> s32 #foreign libpthread;
+
+/* Initialize BARRIER with the attributes in ATTR.  The barrier is
+opened when COUNT waiters arrived.  */
+pthread_barrier_init :: (__barrier: *pthread_barrier_t, __attr: *pthread_barrierattr_t, __count: u32) -> s32 #foreign libpthread;
+
+/* Destroy a previously dynamically initialized barrier BARRIER.  */
+pthread_barrier_destroy :: (__barrier: *pthread_barrier_t) -> s32 #foreign libpthread;
+
+/* Wait on barrier BARRIER.  */
+pthread_barrier_wait :: (__barrier: *pthread_barrier_t) -> s32 #foreign libpthread;
+
+/* Initialize barrier attribute ATTR.  */
+pthread_barrierattr_init :: (__attr: *pthread_barrierattr_t) -> s32 #foreign libpthread;
+
+/* Destroy previously dynamically initialized barrier attribute ATTR.  */
+pthread_barrierattr_destroy :: (__attr: *pthread_barrierattr_t) -> s32 #foreign libpthread;
+
+/* Get the process-shared flag of the barrier attribute ATTR.  */
+pthread_barrierattr_getpshared :: (__attr: *pthread_barrierattr_t, __pshared: *s32) -> s32 #foreign libpthread;
+
+/* Set the process-shared flag of the barrier attribute ATTR.  */
+pthread_barrierattr_setpshared :: (__attr: *pthread_barrierattr_t, __pshared: s32) -> s32 #foreign libpthread;
+
+/* Create a key value identifying a location in the thread-specific
+data area.  Each thread maintains a distinct thread-specific data
+area.  DESTR_FUNCTION, if non-NULL, is called with the value
+associated to that key when the key is destroyed.
+DESTR_FUNCTION is not called if the value associated is NULL when
+the key is destroyed.  */
+pthread_key_create :: (__key: *pthread_key_t, __destr_function: #type (unknown0: *void) -> void #c_call) -> s32 #foreign libpthread;
+
+/* Destroy KEY.  */
+pthread_key_delete :: (__key: pthread_key_t) -> s32 #foreign libpthread;
+
+/* Return current value of the thread-specific data slot identified by KEY.  */
+pthread_getspecific :: (__key: pthread_key_t) -> *void #foreign libpthread;
+
+/* Store POINTER in the thread-specific data slot identified by KEY. */
+pthread_setspecific :: (__key: pthread_key_t, __pointer: *void) -> s32 #foreign libpthread;
+
+/* Get ID of CPU-time clock for thread THREAD_ID.  */
+pthread_getcpuclockid :: (__thread_id: pthread_t, __clock_id: *s32) -> s32 #foreign libpthread;
+
+sem_t :: union {
+    __size:  [32] u8;
+    __align: s64;
+}
+
+/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
+with other processes.  */
+sem_init :: (__sem: *sem_t, __pshared: s32, __value: u32) -> s32 #foreign libpthread;
+
+/* Free resources associated with semaphore object SEM.  */
+sem_destroy :: (__sem: *sem_t) -> s32 #foreign libpthread;
+
+/* Open a named semaphore NAME with open flags OFLAG.  */
+sem_open :: (__name: *u8, __oflag: s32, __args: ..Any) -> *sem_t #foreign libpthread;
+
+/* Close descriptor for named semaphore SEM.  */
+sem_close :: (__sem: *sem_t) -> s32 #foreign libpthread;
+
+/* Remove named semaphore NAME.  */
+sem_unlink :: (__name: *u8) -> s32 #foreign libpthread;
+
+/* Wait for SEM being posted.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+sem_wait :: (__sem: *sem_t) -> s32 #foreign libpthread;
+
+sem_timedwait :: (__sem: *sem_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+sem_clockwait :: (__sem: *sem_t, clock: clockid_t, __abstime: *timespec) -> s32 #foreign libpthread;
+
+/* Test whether SEM is posted.  */
+sem_trywait :: (__sem: *sem_t) -> s32 #foreign libpthread;
+
+/* Post SEM.  */
+sem_post :: (__sem: *sem_t) -> s32 #foreign libpthread;
+
+/* Get current value of SEM and store it in *SVAL.  */
+sem_getvalue :: (__sem: *sem_t, __sval: *s32) -> s32 #foreign libpthread;
+
+jmp_buf :: [1] __jmp_buf_tag;
+
+/* Store the calling environment in ENV, also saving the signal mask.
+Return 0.  */
+setjmp :: (__env: *jmp_buf) -> s32 #foreign libpthread;
+
+/* Store the calling environment in ENV, not saving the signal mask.
+Return 0.  */
+_setjmp :: (__env: *[1] __jmp_buf_tag) -> s32 #foreign libpthread;
+
+/* Jump to the environment saved in ENV, making the
+`setjmp' call there return VAL, or 1 if VAL is 0.  */
+longjmp :: (__env: *[1] __jmp_buf_tag, __val: s32) -> void #foreign libpthread;
+
+/* Same.  Usually `_longjmp' is used with `_setjmp', which does not save
+the signal mask.  But it is how ENV was saved that determines whether
+`longjmp' restores the mask; `_longjmp' is just an alias.  */
+_longjmp :: (__env: *[1] __jmp_buf_tag, __val: s32) -> void #foreign libpthread;
+
+/* Use the same type for `jmp_buf' and `sigjmp_buf'.
+The `__mask_was_saved' flag determines whether
+or not `longjmp' will restore the signal mask.  */
+sigjmp_buf :: [1] __jmp_buf_tag;
+
+/* Jump to the environment saved in ENV, making the
+sigsetjmp call there return VAL, or 1 if VAL is 0.
+Restore the signal mask if that sigsetjmp call saved it.
+This is just an alias `longjmp'.  */
+siglongjmp :: (__env: *sigjmp_buf, __val: s32) -> void #foreign libpthread;
+
+#scope_file
+
+libpthread :: #library,system "libpthread";
+libc :: #library,system "libc";
diff --git a/modules/POSIX/bindings/linux/arm64/resource.jai b/modules/POSIX/bindings/linux/arm64/resource.jai
new file mode 100644
index 0000000..90515cf
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/resource.jai
@@ -0,0 +1,197 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+RLIM_INFINITY :: cast,trunc(u64) -1;
+
+RLIM64_INFINITY :: 0xffffffffffffffff;
+
+RLIM_SAVED_MAX :: RLIM_INFINITY;
+RLIM_SAVED_CUR :: RLIM_INFINITY;
+
+__rusage_defined :: 1;
+
+PRIO_MIN :: -20;
+PRIO_MAX :: 20;
+
+RLIMIT_RESOURCE :: enum u32 {
+    RLIMIT_CPU        :: 0;
+
+    RLIMIT_FSIZE      :: 1;
+
+    RLIMIT_DATA       :: 2;
+
+    RLIMIT_STACK      :: 3;
+
+    RLIMIT_CORE       :: 4;
+
+    RLIMIT_RSS        :: 5;
+
+    RLIMIT_NOFILE     :: 7;
+    RLIMIT_OFILE      :: 7;
+
+    RLIMIT_AS         :: 9;
+
+    RLIMIT_NPROC      :: 6;
+
+    RLIMIT_MEMLOCK    :: 8;
+
+    RLIMIT_LOCKS      :: 10;
+
+    RLIMIT_SIGPENDING :: 11;
+
+    RLIMIT_MSGQUEUE   :: 12;
+
+    RLIMIT_NICE       :: 13;
+
+    RLIMIT_RTPRIO     :: 14;
+
+    RLIMIT_RTTIME     :: 15;
+
+    RLIMIT_NLIMITS    :: 16;
+    RLIM_NLIMITS      :: 16;
+}
+
+rlim_t :: u64;
+
+rlim64_t :: u64;
+
+rlimit :: struct {
+    rlim_cur: rlim_t;
+
+    rlim_max: rlim_t;
+}
+
+rlimit64 :: struct {
+    rlim_cur: rlim64_t;
+
+    rlim_max: rlim64_t;
+}
+
+RUSAGE :: enum s32 {
+    SELF     :: 0;
+
+    CHILDREN :: -1;
+
+    THREAD   :: 1;
+}
+
+rusage :: struct {
+    ru_utime: timeval;
+
+    ru_stime: timeval;
+
+    union {
+        ru_maxrss:        s64;
+        __ru_maxrss_word: s64;
+    }
+
+    union {
+        ru_ixrss:        s64;
+        __ru_ixrss_word: s64;
+    }
+
+    union {
+        ru_idrss:        s64;
+        __ru_idrss_word: s64;
+    }
+
+    union {
+        ru_isrss:        s64;
+        __ru_isrss_word: s64;
+    }
+
+    union {
+        ru_minflt:        s64;
+        __ru_minflt_word: s64;
+    }
+
+    union {
+        ru_majflt:        s64;
+        __ru_majflt_word: s64;
+    }
+
+    union {
+        ru_nswap:        s64;
+        __ru_nswap_word: s64;
+    }
+
+    union {
+        ru_inblock:        s64;
+        __ru_inblock_word: s64;
+    }
+
+    union {
+        ru_oublock:        s64;
+        __ru_oublock_word: s64;
+    }
+
+    union {
+        ru_msgsnd:        s64;
+        __ru_msgsnd_word: s64;
+    }
+
+    union {
+        ru_msgrcv:        s64;
+        __ru_msgrcv_word: s64;
+    }
+
+    union {
+        ru_nsignals:        s64;
+        __ru_nsignals_word: s64;
+    }
+
+    union {
+        ru_nvcsw:        s64;
+        __ru_nvcsw_word: s64;
+    }
+
+    union {
+        ru_nivcsw:        s64;
+        __ru_nivcsw_word: s64;
+    }
+}
+
+PRIO :: enum u32 {
+    PROCESS :: 0;
+
+    PGRP    :: 1;
+
+    USER    :: 2;
+}
+
+prlimit :: (__pid: s32, __resource: RLIMIT_RESOURCE, __new_limit: *rlimit, __old_limit: *rlimit) -> s32 #foreign libc;
+
+prlimit64 :: (__pid: s32, __resource: RLIMIT_RESOURCE, __new_limit: *rlimit64, __old_limit: *rlimit64) -> s32 #foreign libc;
+
+id_t :: u32;
+
+getrlimit :: (__resource: RLIMIT_RESOURCE, __rlimits: *rlimit) -> s32 #foreign libc;
+
+getrlimit64 :: (__resource: RLIMIT_RESOURCE, __rlimits: *rlimit64) -> s32 #foreign libc;
+
+setrlimit :: (__resource: RLIMIT_RESOURCE, __rlimits: *rlimit) -> s32 #foreign libc;
+
+setrlimit64 :: (__resource: RLIMIT_RESOURCE, __rlimits: *rlimit64) -> s32 #foreign libc;
+
+/* Return resource usage information on process indicated by WHO
+and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
+getrusage :: (__who: RUSAGE, __usage: *rusage) -> s32 #foreign libc;
+
+/* Return the highest priority of any process specified by WHICH and WHO
+(see above); if WHO is zero, the current process, process group, or user
+(as specified by WHO) is used.  A lower priority number means higher
+priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  */
+getpriority :: (__which: PRIO, __who: id_t) -> s32 #foreign libc;
+
+/* Set the priority of all processes specified by WHICH and WHO (see above)
+to PRIO.  Returns 0 on success, -1 on errors.  */
+setpriority :: (__which: PRIO, __who: id_t, __prio: s32) -> s32 #foreign libc;
+
+#scope_file
+
+libc :: #library,system "libc";
diff --git a/modules/POSIX/bindings/linux/arm64/stdio.jai b/modules/POSIX/bindings/linux/arm64/stdio.jai
new file mode 100644
index 0000000..8823620
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/stdio.jai
@@ -0,0 +1,1448 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+_GNU_SOURCE :: 1;
+_IOFBF :: 0;
+_IOLBF :: 1;
+_IONBF :: 2;
+
+BUFSIZ :: 8192;
+
+EOF :: -1;
+
+SEEK_SET :: 0;
+SEEK_CUR :: 1;
+SEEK_END :: 2;
+
+SEEK_DATA :: 3;
+SEEK_HOLE :: 4;
+
+P_tmpdir :: "/tmp";
+
+_PRINTF_NAN_LEN_MAX :: 4;
+
+RENAME_NOREPLACE :: 1 << 0;
+RENAME_EXCHANGE :: 1 << 1;
+RENAME_WHITEOUT :: 1 << 2;
+
+__O_DIRECTORY :: 0x4000 /* 040000 */;
+__O_NOFOLLOW :: 0x8000 /* 0100000 */;
+__O_DIRECT :: 0x10000 /* 0200000 */;
+
+__O_LARGEFILE :: 0;
+
+F_GETLK64 :: 5;
+F_SETLK64 :: 6;
+F_SETLKW64 :: 7;
+
+O_ACCMODE :: 0x3 /* 0003 */;
+O_RDONLY :: 0x0 /* 00 */;
+O_WRONLY :: 0x1 /* 01 */;
+O_RDWR :: 0x2 /* 02 */;
+
+O_CREAT :: 0x40 /* 0100 */;
+
+O_EXCL :: 0x80 /* 0200 */;
+
+O_NOCTTY :: 0x100 /* 0400 */;
+
+O_TRUNC :: 0x200 /* 01000 */;
+
+O_APPEND :: 0x400 /* 02000 */;
+
+O_NONBLOCK :: 0x800 /* 04000 */;
+
+O_NDELAY :: O_NONBLOCK;
+
+O_SYNC :: 0x101000 /* 04010000 */;
+
+O_FSYNC :: O_SYNC;
+
+O_ASYNC :: 0x2000 /* 020000 */;
+
+__O_CLOEXEC :: 0x80000 /* 02000000 */;
+
+__O_NOATIME :: 0x40000 /* 01000000 */;
+
+__O_PATH :: 0x200000 /* 010000000 */;
+
+__O_DSYNC :: 0x1000 /* 010000 */;
+
+__O_TMPFILE :: 0x400000 /* 020000000 */ | __O_DIRECTORY;
+
+F_GETLK :: 5;
+F_SETLK :: 6;
+F_SETLKW :: 7;
+
+F_OFD_GETLK :: 36;
+F_OFD_SETLK :: 37;
+F_OFD_SETLKW :: 38;
+
+O_LARGEFILE :: __O_LARGEFILE;
+
+O_DIRECTORY :: __O_DIRECTORY;
+O_NOFOLLOW :: __O_NOFOLLOW;
+O_CLOEXEC :: __O_CLOEXEC;
+
+O_DIRECT :: __O_DIRECT;
+O_NOATIME :: __O_NOATIME;
+O_PATH :: __O_PATH;
+O_TMPFILE :: __O_TMPFILE;
+
+O_DSYNC :: __O_DSYNC;
+
+O_RSYNC :: O_SYNC;
+
+F_DUPFD :: 0;
+F_GETFD :: 1;
+F_SETFD :: 2;
+F_GETFL :: 3;
+F_SETFL :: 4;
+
+__F_SETOWN :: 8;
+__F_GETOWN :: 9;
+
+F_SETOWN :: __F_SETOWN;
+F_GETOWN :: __F_GETOWN;
+
+__F_SETSIG :: 10;
+__F_GETSIG :: 11;
+
+__F_SETOWN_EX :: 15;
+__F_GETOWN_EX :: 16;
+
+F_SETSIG :: __F_SETSIG;
+F_GETSIG :: __F_GETSIG;
+F_SETOWN_EX :: __F_SETOWN_EX;
+F_GETOWN_EX :: __F_GETOWN_EX;
+
+F_SETLEASE :: 1024;
+F_GETLEASE :: 1025;
+F_NOTIFY :: 1026;
+F_SETPIPE_SZ :: 1031;
+F_GETPIPE_SZ :: 1032;
+F_ADD_SEALS :: 1033;
+F_GET_SEALS :: 1034;
+
+F_GET_RW_HINT :: 1035;
+F_SET_RW_HINT :: 1036;
+F_GET_FILE_RW_HINT :: 1037;
+F_SET_FILE_RW_HINT :: 1038;
+
+F_DUPFD_CLOEXEC :: 1030;
+
+FD_CLOEXEC :: 1;
+
+F_RDLCK :: 0;
+F_WRLCK :: 1;
+F_UNLCK :: 2;
+
+F_EXLCK :: 4;
+F_SHLCK :: 8;
+
+LOCK_SH :: 1;
+LOCK_EX :: 2;
+LOCK_NB :: 4;
+
+LOCK_UN :: 8;
+
+LOCK_MAND :: 32;
+LOCK_READ :: 64;
+LOCK_WRITE :: 128;
+LOCK_RW :: 192;
+
+DN_ACCESS :: 0x00000001;
+DN_MODIFY :: 0x00000002;
+DN_CREATE :: 0x00000004;
+DN_DELETE :: 0x00000008;
+DN_RENAME :: 0x00000010;
+DN_ATTRIB :: 0x00000020;
+DN_MULTISHOT :: 0x80000000;
+
+F_SEAL_SEAL :: 0x0001;
+F_SEAL_SHRINK :: 0x0002;
+F_SEAL_GROW :: 0x0004;
+F_SEAL_WRITE :: 0x0008;
+F_SEAL_FUTURE_WRITE :: 0x0010;
+
+RWH_WRITE_LIFE_NOT_SET :: 0;
+RWF_WRITE_LIFE_NOT_SET :: RWH_WRITE_LIFE_NOT_SET;
+RWH_WRITE_LIFE_NONE :: 1;
+RWH_WRITE_LIFE_SHORT :: 2;
+RWH_WRITE_LIFE_MEDIUM :: 3;
+RWH_WRITE_LIFE_LONG :: 4;
+RWH_WRITE_LIFE_EXTREME :: 5;
+
+FAPPEND :: O_APPEND;
+FFSYNC :: O_FSYNC;
+FASYNC :: O_ASYNC;
+FNONBLOCK :: O_NONBLOCK;
+FNDELAY :: O_NDELAY;
+
+__POSIX_FADV_DONTNEED :: 4;
+__POSIX_FADV_NOREUSE :: 5;
+
+POSIX_FADV_NORMAL :: 0;
+POSIX_FADV_RANDOM :: 1;
+POSIX_FADV_SEQUENTIAL :: 2;
+POSIX_FADV_WILLNEED :: 3;
+POSIX_FADV_DONTNEED :: __POSIX_FADV_DONTNEED;
+POSIX_FADV_NOREUSE :: __POSIX_FADV_NOREUSE;
+
+SYNC_FILE_RANGE_WAIT_BEFORE :: 1;
+
+SYNC_FILE_RANGE_WRITE :: 2;
+
+SYNC_FILE_RANGE_WAIT_AFTER :: 4;
+
+SYNC_FILE_RANGE_WRITE_AND_WAIT :: SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WAIT_AFTER;
+
+SPLICE_F_MOVE :: 1;
+SPLICE_F_NONBLOCK :: 2;
+
+SPLICE_F_MORE :: 4;
+SPLICE_F_GIFT :: 8;
+
+MAX_HANDLE_SZ :: 128;
+
+__S_IFMT :: 0xf000 /* 0170000 */;
+
+__S_IFDIR :: 0x4000 /* 0040000 */;
+__S_IFCHR :: 0x2000 /* 0020000 */;
+__S_IFBLK :: 0x6000 /* 0060000 */;
+__S_IFREG :: 0x8000 /* 0100000 */;
+__S_IFIFO :: 0x1000 /* 0010000 */;
+__S_IFLNK :: 0xa000 /* 0120000 */;
+__S_IFSOCK :: 0xc000 /* 0140000 */;
+
+__S_ISUID :: 0x800 /* 04000 */;
+__S_ISGID :: 0x400 /* 02000 */;
+__S_ISVTX :: 0x200 /* 01000 */;
+__S_IREAD :: 0x100 /* 0400 */;
+__S_IWRITE :: 0x80 /* 0200 */;
+__S_IEXEC :: 0x40 /* 0100 */;
+
+UTIME_NOW :: (1 << 30) - 1;
+UTIME_OMIT :: (1 << 30) - 2;
+
+S_IFMT :: __S_IFMT;
+S_IFDIR :: __S_IFDIR;
+S_IFCHR :: __S_IFCHR;
+S_IFBLK :: __S_IFBLK;
+S_IFREG :: __S_IFREG;
+
+S_IFIFO :: __S_IFIFO;
+
+S_IFLNK :: __S_IFLNK;
+
+S_IFSOCK :: __S_IFSOCK;
+
+S_ISUID :: __S_ISUID;
+S_ISGID :: __S_ISGID;
+
+S_ISVTX :: __S_ISVTX;
+
+S_IRUSR :: __S_IREAD;
+S_IWUSR :: __S_IWRITE;
+S_IXUSR :: __S_IEXEC;
+
+S_IRWXU :: __S_IREAD|__S_IWRITE|__S_IEXEC;
+
+S_IRGRP :: S_IRUSR >> 3;
+S_IWGRP :: S_IWUSR >> 3;
+S_IXGRP :: S_IXUSR >> 3;
+
+S_IRWXG :: S_IRWXU >> 3;
+
+S_IROTH :: S_IRGRP >> 3;
+S_IWOTH :: S_IWGRP >> 3;
+S_IXOTH :: S_IXGRP >> 3;
+
+S_IRWXO :: S_IRWXG >> 3;
+
+R_OK :: 4;
+W_OK :: 2;
+X_OK :: 1;
+F_OK :: 0;
+
+AT_FDCWD :: -100;
+
+AT_SYMLINK_NOFOLLOW :: 0x100;
+AT_REMOVEDIR :: 0x200;
+
+AT_SYMLINK_FOLLOW :: 0x400;
+
+AT_NO_AUTOMOUNT :: 0x800;
+
+AT_EMPTY_PATH :: 0x1000;
+AT_STATX_SYNC_TYPE :: 0x6000;
+AT_STATX_SYNC_AS_STAT :: 0x0000;
+AT_STATX_FORCE_SYNC :: 0x2000;
+AT_STATX_DONT_SYNC :: 0x4000;
+AT_RECURSIVE :: 0x8000;
+
+AT_EACCESS :: 0x200;
+
+F_ULOCK :: 0;
+F_LOCK :: 1;
+F_TLOCK :: 2;
+F_TEST :: 3;
+
+S_IREAD :: S_IRUSR;
+S_IWRITE :: S_IWUSR;
+S_IEXEC :: S_IXUSR;
+
+ACCESSPERMS :: S_IRWXU|S_IRWXG|S_IRWXO;
+ALLPERMS :: S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO;
+DEFFILEMODE :: S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
+
+S_BLKSIZE :: 512;
+
+STATX_TYPE :: 0x00000001;
+STATX_MODE :: 0x00000002;
+STATX_NLINK :: 0x00000004;
+STATX_UID :: 0x00000008;
+STATX_GID :: 0x00000010;
+STATX_ATIME :: 0x00000020;
+STATX_MTIME :: 0x00000040;
+STATX_CTIME :: 0x00000080;
+STATX_INO :: 0x00000100;
+STATX_SIZE :: 0x00000200;
+STATX_BLOCKS :: 0x00000400;
+STATX_BASIC_STATS :: 0x000007ff;
+STATX_BTIME :: 0x00000800;
+STATX_MNT_ID :: 0x00001000;
+STATX_DIOALIGN :: 0x00002000;
+
+STATX__RESERVED :: 0x80000000;
+
+STATX_ALL :: 0x00000fff;
+
+STATX_ATTR_COMPRESSED :: 0x00000004;
+STATX_ATTR_IMMUTABLE :: 0x00000010;
+STATX_ATTR_APPEND :: 0x00000020;
+STATX_ATTR_NODUMP :: 0x00000040;
+STATX_ATTR_ENCRYPTED :: 0x00000800;
+STATX_ATTR_AUTOMOUNT :: 0x00001000;
+STATX_ATTR_MOUNT_ROOT :: 0x00002000;
+STATX_ATTR_VERITY :: 0x00100000;
+STATX_ATTR_DAX :: 0x00200000;
+
+TCGETS :: 0x5401;
+TCSETS :: 0x5402;
+TCSETSW :: 0x5403;
+TCSETSF :: 0x5404;
+TCGETA :: 0x5405;
+TCSETA :: 0x5406;
+TCSETAW :: 0x5407;
+TCSETAF :: 0x5408;
+TCSBRK :: 0x5409;
+TCXONC :: 0x540A;
+TCFLSH :: 0x540B;
+TIOCEXCL :: 0x540C;
+TIOCNXCL :: 0x540D;
+TIOCSCTTY :: 0x540E;
+TIOCGPGRP :: 0x540F;
+TIOCSPGRP :: 0x5410;
+TIOCOUTQ :: 0x5411;
+TIOCSTI :: 0x5412;
+TIOCGWINSZ :: 0x5413;
+TIOCSWINSZ :: 0x5414;
+TIOCMGET :: 0x5415;
+TIOCMBIS :: 0x5416;
+TIOCMBIC :: 0x5417;
+TIOCMSET :: 0x5418;
+TIOCGSOFTCAR :: 0x5419;
+TIOCSSOFTCAR :: 0x541A;
+FIONREAD :: 0x541B;
+TIOCINQ :: FIONREAD;
+TIOCLINUX :: 0x541C;
+TIOCCONS :: 0x541D;
+TIOCGSERIAL :: 0x541E;
+TIOCSSERIAL :: 0x541F;
+TIOCPKT :: 0x5420;
+FIONBIO :: 0x5421;
+TIOCNOTTY :: 0x5422;
+TIOCSETD :: 0x5423;
+TIOCGETD :: 0x5424;
+TCSBRKP :: 0x5425;
+TIOCSBRK :: 0x5427;
+TIOCCBRK :: 0x5428;
+TIOCGSID :: 0x5429;
+
+TIOCGRS485 :: 0x542E;
+
+TIOCSRS485 :: 0x542F;
+
+TCGETX :: 0x5432;
+TCSETX :: 0x5433;
+TCSETXF :: 0x5434;
+TCSETXW :: 0x5435;
+
+TIOCVHANGUP :: 0x5437;
+
+FIONCLEX :: 0x5450;
+FIOCLEX :: 0x5451;
+FIOASYNC :: 0x5452;
+TIOCSERCONFIG :: 0x5453;
+TIOCSERGWILD :: 0x5454;
+TIOCSERSWILD :: 0x5455;
+TIOCGLCKTRMIOS :: 0x5456;
+TIOCSLCKTRMIOS :: 0x5457;
+TIOCSERGSTRUCT :: 0x5458;
+TIOCSERGETLSR :: 0x5459;
+TIOCSERGETMULTI :: 0x545A;
+TIOCSERSETMULTI :: 0x545B;
+
+TIOCMIWAIT :: 0x545C;
+TIOCGICOUNT :: 0x545D;
+
+FIOQSIZE :: 0x5460;
+
+TIOCPKT_DATA :: 0;
+TIOCPKT_FLUSHREAD :: 1;
+TIOCPKT_FLUSHWRITE :: 2;
+TIOCPKT_STOP :: 4;
+TIOCPKT_START :: 8;
+TIOCPKT_NOSTOP :: 16;
+TIOCPKT_DOSTOP :: 32;
+TIOCPKT_IOCTL :: 64;
+
+TIOCSER_TEMT :: 0x01;
+
+SIOCADDRT :: 0x890B;
+SIOCDELRT :: 0x890C;
+SIOCRTMSG :: 0x890D;
+
+SIOCGIFNAME :: 0x8910;
+SIOCSIFLINK :: 0x8911;
+SIOCGIFCONF :: 0x8912;
+SIOCGIFFLAGS :: 0x8913;
+SIOCSIFFLAGS :: 0x8914;
+SIOCGIFADDR :: 0x8915;
+SIOCSIFADDR :: 0x8916;
+SIOCGIFDSTADDR :: 0x8917;
+SIOCSIFDSTADDR :: 0x8918;
+SIOCGIFBRDADDR :: 0x8919;
+SIOCSIFBRDADDR :: 0x891a;
+SIOCGIFNETMASK :: 0x891b;
+SIOCSIFNETMASK :: 0x891c;
+SIOCGIFMETRIC :: 0x891d;
+SIOCSIFMETRIC :: 0x891e;
+SIOCGIFMEM :: 0x891f;
+SIOCSIFMEM :: 0x8920;
+SIOCGIFMTU :: 0x8921;
+SIOCSIFMTU :: 0x8922;
+SIOCSIFNAME :: 0x8923;
+SIOCSIFHWADDR :: 0x8924;
+SIOCGIFENCAP :: 0x8925;
+SIOCSIFENCAP :: 0x8926;
+SIOCGIFHWADDR :: 0x8927;
+SIOCGIFSLAVE :: 0x8929;
+SIOCSIFSLAVE :: 0x8930;
+SIOCADDMULTI :: 0x8931;
+SIOCDELMULTI :: 0x8932;
+SIOCGIFINDEX :: 0x8933;
+SIOGIFINDEX :: SIOCGIFINDEX;
+SIOCSIFPFLAGS :: 0x8934;
+SIOCGIFPFLAGS :: 0x8935;
+SIOCDIFADDR :: 0x8936;
+SIOCSIFHWBROADCAST :: 0x8937;
+SIOCGIFCOUNT :: 0x8938;
+
+SIOCGIFBR :: 0x8940;
+SIOCSIFBR :: 0x8941;
+
+SIOCGIFTXQLEN :: 0x8942;
+SIOCSIFTXQLEN :: 0x8943;
+
+SIOCDARP :: 0x8953;
+SIOCGARP :: 0x8954;
+SIOCSARP :: 0x8955;
+
+SIOCDRARP :: 0x8960;
+SIOCGRARP :: 0x8961;
+SIOCSRARP :: 0x8962;
+
+SIOCGIFMAP :: 0x8970;
+SIOCSIFMAP :: 0x8971;
+
+SIOCADDDLCI :: 0x8980;
+SIOCDELDLCI :: 0x8981;
+
+SIOCDEVPRIVATE :: 0x89F0;
+
+SIOCPROTOPRIVATE :: 0x89E0;
+
+__mbstate_t :: struct {
+    __count: s32;
+    __value: union {
+        __wch:  u32;
+        __wchb: [4] u8;
+    };
+}
+
+_G_fpos_t :: struct {
+    __pos:   s64;
+    __state: __mbstate_t;
+}
+
+_G_fpos64_t :: struct {
+    __pos:   s64;
+    __state: __mbstate_t;
+}
+
+cookie_read_function_t :: #type (__cookie: *void, __buf: *u8, __nbytes: u64) -> s64 #c_call;
+
+cookie_write_function_t :: #type (__cookie: *void, __buf: *u8, __nbytes: u64) -> s64 #c_call;
+
+cookie_seek_function_t :: #type (__cookie: *void, __pos: *s64, __w: s32) -> s32 #c_call;
+
+cookie_close_function_t :: #type (__cookie: *void) -> s32 #c_call;
+
+_IO_cookie_io_functions_t :: struct {
+    read:  cookie_read_function_t;
+    write: cookie_write_function_t;
+    seek:  cookie_seek_function_t;
+    close: cookie_close_function_t;
+}
+
+cookie_io_functions_t :: _IO_cookie_io_functions_t;
+
+fpos_t :: _G_fpos_t;
+
+fpos64_t :: _G_fpos64_t;
+
+stdin: *FILE #elsewhere libc; /* Standard input stream.  */
+stdout: *FILE #elsewhere libc; /* Standard output stream.  */
+stderr: *FILE #elsewhere libc; /* Standard error output stream.  */
+
+/* Remove file FILENAME.  */
+_remove :: (__filename: *u8) -> s32 #foreign libc "remove";
+
+/* Rename file OLD to NEW.  */
+rename :: (__old: *u8, __new: *u8) -> s32 #foreign libc;
+
+/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
+renameat :: (__oldfd: s32, __old: *u8, __newfd: s32, __new: *u8) -> s32 #foreign libc;
+
+/* Rename file OLD relative to OLDFD to NEW relative to NEWFD, with
+additional flags.  */
+renameat2 :: (__oldfd: s32, __old: *u8, __newfd: s32, __new: *u8, __flags: u32) -> s32 #foreign libc;
+
+/* Close STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fclose :: (__stream: *FILE) -> s32 #foreign libc;
+
+tmpfile :: () -> *FILE #foreign libc;
+
+tmpfile64 :: () -> *FILE #foreign libc;
+
+/* Generate a temporary filename.  */
+tmpnam :: (unknown0: *[20] u8) -> *u8 #foreign libc;
+
+/* This is the reentrant variant of `tmpnam'.  The only difference is
+that it does not allow S to be NULL.  */
+tmpnam_r :: (__s: *[20] u8) -> *u8 #foreign libc;
+
+/* Generate a unique temporary filename using up to five characters of PFX
+if it is not NULL.  The directory to put this file in is searched for
+as follows: First the environment variable "TMPDIR" is checked.
+If it contains the name of a writable directory, that directory is used.
+If not and if DIR is not NULL, that value is checked.  If that fails,
+P_tmpdir is tried and finally "/tmp".  The storage for the filename
+is allocated by `malloc'.  */
+tempnam :: (__dir: *u8, __pfx: *u8) -> *u8 #foreign libc;
+
+/* Flush STREAM, or all streams if STREAM is NULL.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fflush :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Faster versions when locking is not required.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fflush_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Close all streams.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fcloseall :: () -> s32 #foreign libc;
+
+/* Open a file and create a new stream for it.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fopen :: (__filename: *u8, __modes: *u8) -> *FILE #foreign libc;
+
+/* Open a file, replacing an existing stream with it.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+freopen :: (__filename: *u8, __modes: *u8, __stream: *FILE) -> *FILE #foreign libc;
+
+fopen64 :: (__filename: *u8, __modes: *u8) -> *FILE #foreign libc;
+
+freopen64 :: (__filename: *u8, __modes: *u8, __stream: *FILE) -> *FILE #foreign libc;
+
+/* Create a new stream that refers to an existing system file descriptor.  */
+fdopen :: (__fd: s32, __modes: *u8) -> *FILE #foreign libc;
+
+/* Create a new stream that refers to the given magic cookie,
+and uses the given functions for input and output.  */
+fopencookie :: (__magic_cookie: *void, __modes: *u8, __io_funcs: cookie_io_functions_t) -> *FILE #foreign libc;
+
+/* Create a new stream that refers to a memory buffer.  */
+fmemopen :: (__s: *void, __len: u64, __modes: *u8) -> *FILE #foreign libc;
+
+/* Open a stream that writes into a malloc'd buffer that is expanded as
+necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
+and the number of characters written on fflush or fclose.  */
+open_memstream :: (__bufloc: **u8, __sizeloc: *u64) -> *FILE #foreign libc;
+
+/* If BUF is NULL, make STREAM unbuffered.
+Else make it use buffer BUF, of size BUFSIZ.  */
+setbuf :: (__stream: *FILE, __buf: *u8) -> void #foreign libc;
+
+/* Make STREAM use buffering mode MODE.
+If BUF is not NULL, use N bytes of it for buffering;
+else allocate an internal buffer N bytes long.  */
+setvbuf :: (__stream: *FILE, __buf: *u8, __modes: s32, __n: u64) -> s32 #foreign libc;
+
+/* If BUF is NULL, make STREAM unbuffered.
+Else make it use SIZE bytes of BUF for buffering.  */
+setbuffer :: (__stream: *FILE, __buf: *u8, __size: u64) -> void #foreign libc;
+
+/* Make STREAM line-buffered.  */
+setlinebuf :: (__stream: *FILE) -> void #foreign libc;
+
+/* Write formatted output to STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fprintf :: (__stream: *FILE, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Write formatted output to stdout.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+printf :: (__format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Write formatted output to S.  */
+sprintf :: (__s: *u8, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Maximum chars of output to write in MAXLEN.  */
+snprintf :: (__s: *u8, __maxlen: u64, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+__asprintf :: (__ptr: **u8, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
+
+asprintf :: (__ptr: **u8, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
+
+dprintf :: (__fd: s32, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Read formatted input from STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fscanf :: (__stream: *FILE, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Read formatted input from stdin.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+scanf :: (__format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Read formatted input from S.  */
+sscanf :: (__s: *u8, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Read a character from STREAM.
+
+These functions are possible cancellation points and therefore not
+marked with __THROW.  */
+fgetc :: (__stream: *FILE) -> s32 #foreign libc;
+getc :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Read a character from stdin.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getchar :: () -> s32 #foreign libc;
+
+/* These are defined in POSIX.1:1996.
+
+These functions are possible cancellation points and therefore not
+marked with __THROW.  */
+getc_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+getchar_unlocked :: () -> s32 #foreign libc;
+
+/* Faster version when locking is not necessary.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fgetc_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Write a character to STREAM.
+
+These functions are possible cancellation points and therefore not
+marked with __THROW.
+
+These functions is a possible cancellation point and therefore not
+marked with __THROW.  */
+fputc :: (__c: s32, __stream: *FILE) -> s32 #foreign libc;
+putc :: (__c: s32, __stream: *FILE) -> s32 #foreign libc;
+
+/* Write a character to stdout.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+putchar :: (__c: s32) -> s32 #foreign libc;
+
+/* Faster version when locking is not necessary.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fputc_unlocked :: (__c: s32, __stream: *FILE) -> s32 #foreign libc;
+
+/* These are defined in POSIX.1:1996.
+
+These functions are possible cancellation points and therefore not
+marked with __THROW.  */
+putc_unlocked :: (__c: s32, __stream: *FILE) -> s32 #foreign libc;
+putchar_unlocked :: (__c: s32) -> s32 #foreign libc;
+
+/* Get a word (int) from STREAM.  */
+getw :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Write a word (int) to STREAM.  */
+putw :: (__w: s32, __stream: *FILE) -> s32 #foreign libc;
+
+/* Get a newline-terminated string of finite length from STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fgets :: (__s: *u8, __n: s32, __stream: *FILE) -> *u8 #foreign libc;
+
+/* This function does the same as `fgets' but does not lock the stream.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fgets_unlocked :: (__s: *u8, __n: s32, __stream: *FILE) -> *u8 #foreign libc;
+
+/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
+(and null-terminate it). *LINEPTR is a pointer returned from malloc (or
+NULL), pointing to *N characters of space.  It is realloc'd as
+necessary.  Returns the number of characters read (not including the
+null terminator), or -1 on error or EOF.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+__getdelim :: (__lineptr: **u8, __n: *u64, __delimiter: s32, __stream: *FILE) -> s64 #foreign libc;
+
+getdelim :: (__lineptr: **u8, __n: *u64, __delimiter: s32, __stream: *FILE) -> s64 #foreign libc;
+
+/* Like `getdelim', but reads up to a newline.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getline :: (__lineptr: **u8, __n: *u64, __stream: *FILE) -> s64 #foreign libc;
+
+/* Write a string to STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fputs :: (__s: *u8, __stream: *FILE) -> s32 #foreign libc;
+
+/* Write a string, followed by a newline, to stdout.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+puts :: (__s: *u8) -> s32 #foreign libc;
+
+/* Push a character back onto the input buffer of STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+ungetc :: (__c: s32, __stream: *FILE) -> s32 #foreign libc;
+
+/* Read chunks of generic data from STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fread :: (__ptr: *void, __size: u64, __n: u64, __stream: *FILE) -> u64 #foreign libc;
+
+/* Write chunks of generic data to STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fwrite :: (__ptr: *void, __size: u64, __n: u64, __s: *FILE) -> u64 #foreign libc;
+
+/* This function does the same as `fputs' but does not lock the stream.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+fputs_unlocked :: (__s: *u8, __stream: *FILE) -> s32 #foreign libc;
+
+/* Faster versions when locking is not necessary.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+fread_unlocked :: (__ptr: *void, __size: u64, __n: u64, __stream: *FILE) -> u64 #foreign libc;
+
+fwrite_unlocked :: (__ptr: *void, __size: u64, __n: u64, __stream: *FILE) -> u64 #foreign libc;
+
+/* Seek to a certain position on STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fseek :: (__stream: *FILE, __off: s64, __whence: s32) -> s32 #foreign libc;
+
+/* Return the current position of STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+ftell :: (__stream: *FILE) -> s64 #foreign libc;
+
+/* Rewind to the beginning of STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+rewind :: (__stream: *FILE) -> void #foreign libc;
+
+/* Seek to a certain position on STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fseeko :: (__stream: *FILE, __off: s64, __whence: s32) -> s32 #foreign libc;
+
+/* Return the current position of STREAM.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+ftello :: (__stream: *FILE) -> s64 #foreign libc;
+
+/* Get STREAM's position.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fgetpos :: (__stream: *FILE, __pos: *fpos_t) -> s32 #foreign libc;
+
+/* Set STREAM's position.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+fsetpos :: (__stream: *FILE, __pos: *fpos_t) -> s32 #foreign libc;
+
+fseeko64 :: (__stream: *FILE, __off: s64, __whence: s32) -> s32 #foreign libc;
+ftello64 :: (__stream: *FILE) -> s64 #foreign libc;
+fgetpos64 :: (__stream: *FILE, __pos: *fpos64_t) -> s32 #foreign libc;
+fsetpos64 :: (__stream: *FILE, __pos: *fpos64_t) -> s32 #foreign libc;
+
+/* Clear the error and EOF indicators for STREAM.  */
+clearerr :: (__stream: *FILE) -> void #foreign libc;
+
+/* Return the EOF indicator for STREAM.  */
+feof :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Return the error indicator for STREAM.  */
+ferror :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Faster versions when locking is not required.  */
+clearerr_unlocked :: (__stream: *FILE) -> void #foreign libc;
+feof_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+ferror_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Print a message describing the meaning of the value of errno.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+perror :: (__s: *u8) -> void #foreign libc;
+
+/* Return the system file descriptor for STREAM.  */
+fileno :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Faster version when locking is not required.  */
+fileno_unlocked :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Close a stream opened by popen and return the status of its child.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+pclose :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Create a new stream connected to a pipe running the given command.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+popen :: (__command: *u8, __modes: *u8) -> *FILE #foreign libc;
+
+/* Return the name of the controlling terminal.  */
+ctermid :: (__s: *u8) -> *u8 #foreign libc;
+
+/* Return the name of the current user.  */
+cuserid :: (__s: *u8) -> *u8 #foreign libc;
+
+obstack :: struct {}
+
+/* Write formatted output to an obstack.  */
+obstack_printf :: (__obstack: *obstack, __format: *u8, __args: ..Any) -> s32 #foreign libc;
+
+/* Acquire ownership of STREAM.  */
+flockfile :: (__stream: *FILE) -> void #foreign libc;
+
+/* Try to acquire ownership of STREAM but do not block if it is not
+possible.  */
+ftrylockfile :: (__stream: *FILE) -> s32 #foreign libc;
+
+/* Relinquish the ownership granted for STREAM.  */
+funlockfile :: (__stream: *FILE) -> void #foreign libc;
+
+/* Slow-path routines used by the optimized inline functions in
+bits/stdio.h.  */
+__uflow :: (unknown0: *FILE) -> s32 #foreign libc;
+__overflow :: (unknown0: *FILE, unknown1: s32) -> s32 #foreign libc;
+
+flock :: struct {
+    l_type:   s16;
+    l_whence: s16;
+    l_start:  s64;
+    l_len:    s64;
+    l_pid:    s32;
+}
+
+flock64 :: struct {
+    l_type:   s16;
+    l_whence: s16;
+    l_start:  s64;
+    l_len:    s64;
+    l_pid:    s32;
+}
+
+__pid_type :: enum u32 {
+    TID  :: 0;
+    PID  :: 1;
+    PGRP :: 2;
+    GID  :: 2;
+
+    F_OWNER_TID  :: TID;
+    F_OWNER_PID  :: PID;
+    F_OWNER_PGRP :: PGRP;
+    F_OWNER_GID  :: GID;
+}
+
+f_owner_ex :: struct {
+    type: __pid_type;
+    pid:  s32;
+}
+
+file_handle :: struct {
+    handle_bytes: u32;
+    handle_type:  s32;
+
+    f_handle:     [0] u8;
+}
+
+readahead :: (__fd: s32, __offset: s64, __count: u64) -> s64 #foreign libc;
+
+sync_file_range :: (__fd: s32, __offset: s64, __count: s64, __flags: u32) -> s32 #foreign libc;
+
+vmsplice :: (__fdout: s32, __iov: *iovec, __count: u64, __flags: u32) -> s64 #foreign libc;
+
+splice :: (__fdin: s32, __offin: *s64, __fdout: s32, __offout: *s64, __len: u64, __flags: u32) -> s64 #foreign libc;
+
+tee :: (__fdin: s32, __fdout: s32, __len: u64, __flags: u32) -> s64 #foreign libc;
+
+fallocate :: (__fd: s32, __mode: s32, __offset: s64, __len: s64) -> s32 #foreign libc;
+
+fallocate64 :: (__fd: s32, __mode: s32, __offset: s64, __len: s64) -> s32 #foreign libc;
+
+name_to_handle_at :: (__dfd: s32, __name: *u8, __handle: *file_handle, __mnt_id: *s32, __flags: s32) -> s32 #foreign libc;
+
+open_by_handle_at :: (__mountdirfd: s32, __handle: *file_handle, __flags: s32) -> s32 #foreign libc;
+
+mode_t :: u32;
+
+pid_t :: s32;
+
+stat_t :: struct {
+    st_dev:           u64;
+    st_ino:           u64;
+    st_mode:          u32;
+    st_nlink:         u32;
+    st_uid:           u32;
+    st_gid:           u32;
+    st_rdev:          u64;
+    __pad1:           u64;
+    st_size:          s64;
+    st_blksize:       s32;
+    __pad2:           s32;
+    st_blocks:        s64;
+
+    st_atime:         timespec;
+    st_mtime:         timespec;
+    st_ctime:         timespec;
+
+    __glibc_reserved: [2] s32;
+}
+
+stat64_t :: struct {
+    st_dev:           u64;
+    st_ino:           u64;
+    st_mode:          u32;
+    st_nlink:         u32;
+    st_uid:           u32;
+    st_gid:           u32;
+    st_rdev:          u64;
+    __pad1:           u64;
+    st_size:          s64;
+    st_blksize:       s32;
+    __pad2:           s32;
+    st_blocks:        s64;
+
+    st_atime:         timespec;
+    st_mtime:         timespec;
+    st_ctime:         timespec;
+
+    __glibc_reserved: [2] s32;
+}
+
+fcntl :: (__fd: s32, __cmd: s32, __args: ..Any) -> s32 #foreign libc;
+
+fcntl64 :: (__fd: s32, __cmd: s32, __args: ..Any) -> s32 #foreign libc;
+
+open :: (__file: *u8, __oflag: s32, __args: ..Any) -> s32 #foreign libc;
+
+open64 :: (__file: *u8, __oflag: s32, __args: ..Any) -> s32 #foreign libc;
+
+openat :: (__fd: s32, __file: *u8, __oflag: s32, __args: ..Any) -> s32 #foreign libc;
+
+openat64 :: (__fd: s32, __file: *u8, __oflag: s32, __args: ..Any) -> s32 #foreign libc;
+
+creat :: (__file: *u8, __mode: mode_t) -> s32 #foreign libc;
+
+creat64 :: (__file: *u8, __mode: mode_t) -> s32 #foreign libc;
+
+lockf :: (__fd: s32, __cmd: s32, __len: s64) -> s32 #foreign libc;
+
+lockf64 :: (__fd: s32, __cmd: s32, __len: s64) -> s32 #foreign libc;
+
+posix_fadvise :: (__fd: s32, __offset: s64, __len: s64, __advise: s32) -> s32 #foreign libc;
+
+posix_fadvise64 :: (__fd: s32, __offset: s64, __len: s64, __advise: s32) -> s32 #foreign libc;
+
+posix_fallocate :: (__fd: s32, __offset: s64, __len: s64) -> s32 #foreign libc;
+
+posix_fallocate64 :: (__fd: s32, __offset: s64, __len: s64) -> s32 #foreign libc;
+
+dev_t :: u64;
+
+gid_t :: u32;
+
+ino_t :: u64;
+
+nlink_t :: u32;
+
+uid_t :: u32;
+
+blkcnt_t :: s64;
+
+blksize_t :: s32;
+
+/* Get file attributes for FILE and put them in BUF.  */
+stat :: (__file: *u8, __buf: *stat_t) -> s32 #foreign libc;
+
+/* Get file attributes for the file, device, pipe, or socket
+that file descriptor FD is open on and put them in BUF.  */
+fstat :: (__fd: s32, __buf: *stat_t) -> s32 #foreign libc;
+
+stat64 :: (__file: *u8, __buf: *stat64_t) -> s32 #foreign libc;
+
+fstat64 :: (__fd: s32, __buf: *stat64_t) -> s32 #foreign libc;
+
+fstatat :: (__fd: s32, __file: *u8, __buf: *stat_t, __flag: s32) -> s32 #foreign libc;
+
+fstatat64 :: (__fd: s32, __file: *u8, __buf: *stat64_t, __flag: s32) -> s32 #foreign libc;
+
+/* Get file attributes about FILE and put them in BUF.
+If FILE is a symbolic link, do not follow it.  */
+lstat :: (__file: *u8, __buf: *stat_t) -> s32 #foreign libc;
+
+lstat64 :: (__file: *u8, __buf: *stat64_t) -> s32 #foreign libc;
+
+/* Set file access permissions for FILE to MODE.
+If FILE is a symbolic link, this affects its target instead.  */
+chmod :: (__file: *u8, __mode: u32) -> s32 #foreign libc;
+
+/* Set file access permissions for FILE to MODE.
+If FILE is a symbolic link, this affects the link itself
+rather than its target.  */
+lchmod :: (__file: *u8, __mode: u32) -> s32 #foreign libc;
+
+fchmod :: (__fd: s32, __mode: u32) -> s32 #foreign libc;
+
+/* Set file access permissions of FILE relative to
+the directory FD is open on.  */
+fchmodat :: (__fd: s32, __file: *u8, __mode: u32, __flag: s32) -> s32 #foreign libc;
+
+/* Set the file creation mask of the current process to MASK,
+and return the old creation mask.  */
+umask :: (__mask: u32) -> u32 #foreign libc;
+
+/* Create a new directory named PATH, with permission bits MODE.  */
+mkdir :: (__path: *u8, __mode: u32) -> s32 #foreign libc;
+
+/* Like mkdir, create a new directory with permission bits MODE.  But
+interpret relative PATH names relative to the directory associated
+with FD.  */
+mkdirat :: (__fd: s32, __path: *u8, __mode: u32) -> s32 #foreign libc;
+
+mknod :: (__path: *u8, __mode: u32, __dev: u64) -> s32 #foreign libc;
+
+/* Like mknod, create a new device file with permission bits MODE and
+device number DEV.  But interpret relative PATH names relative to
+the directory associated with FD.  */
+mknodat :: (__fd: s32, __path: *u8, __mode: u32, __dev: u64) -> s32 #foreign libc;
+
+/* Create a new FIFO named PATH, with permission bits MODE.  */
+mkfifo :: (__path: *u8, __mode: u32) -> s32 #foreign libc;
+
+/* Like mkfifo, create a new FIFO with permission bits MODE.  But
+interpret relative PATH names relative to the directory associated
+with FD.  */
+mkfifoat :: (__fd: s32, __path: *u8, __mode: u32) -> s32 #foreign libc;
+
+/* Set file access and modification times relative to directory file
+descriptor.  */
+utimensat :: (__fd: s32, __path: *u8, __times: *[2] timespec, __flags: s32) -> s32 #foreign libc;
+
+/* Set file access and modification times of the file associated with FD.  */
+futimens :: (__fd: s32, __times: *[2] timespec) -> s32 #foreign libc;
+
+statx_timestamp :: struct {
+    tv_sec:     s64;
+    tv_nsec:    u32;
+    __reserved: s32;
+}
+
+statx_t :: struct {
+    stx_mask:             u32;
+    stx_blksize:          u32;
+    stx_attributes:       u64;
+
+    stx_nlink:            u32;
+    stx_uid:              u32;
+    stx_gid:              u32;
+    stx_mode:             u16;
+    __spare0:             [1] u16;
+
+    stx_ino:              u64;
+    stx_size:             u64;
+    stx_blocks:           u64;
+    stx_attributes_mask:  u64;
+
+    stx_atime:            statx_timestamp;
+    stx_btime:            statx_timestamp;
+    stx_ctime:            statx_timestamp;
+    stx_mtime:            statx_timestamp;
+
+    stx_rdev_major:       u32;
+    stx_rdev_minor:       u32;
+    stx_dev_major:        u32;
+    stx_dev_minor:        u32;
+
+    stx_mnt_id:           u64;
+    stx_dio_mem_align:    u32;
+    stx_dio_offset_align: u32;
+
+    __spare3:             [12] u64;
+}
+
+ioctl :: (__fd: s32, __request: u64, __args: ..Any) -> s32 #foreign libc;
+
+/* Asynchronous I/O control block.  */
+aiocb :: struct {
+    aio_fildes:       s32; /* File descriptor.  */
+    aio_lio_opcode:   s32; /* Operation to be performed.  */
+    aio_reqprio:      s32; /* Request priority offset.  */
+    aio_buf:          *void; /* Location of buffer.  */
+    aio_nbytes:       u64; /* Length of transfer.  */
+    aio_sigevent:     sigevent; /* Signal number and value.  */
+
+    /* Internal members.  */
+    __next_prio:      *aiocb;
+    __abs_prio:       s32;
+    __policy:         s32;
+    __error_code:     s32;
+    __return_value:   s64;
+
+    aio_offset:       s64; /* File offset.  */
+    __pad:            [0] u8;
+
+    __glibc_reserved: [32] u8;
+}
+
+aiocb64 :: struct {
+    aio_fildes:       s32; /* File descriptor.  */
+    aio_lio_opcode:   s32; /* Operation to be performed.  */
+    aio_reqprio:      s32; /* Request priority offset.  */
+    aio_buf:          *void; /* Location of buffer.  */
+    aio_nbytes:       u64; /* Length of transfer.  */
+    aio_sigevent:     sigevent; /* Signal number and value.  */
+
+    /* Internal members.  */
+    __next_prio:      *aiocb;
+    __abs_prio:       s32;
+    __policy:         s32;
+    __error_code:     s32;
+    __return_value:   s64;
+
+    aio_offset:       s64; /* File offset.  */
+    __glibc_reserved: [32] u8;
+}
+
+/* To optimize the implementation one can use the following struct.  */
+aioinit :: struct {
+    aio_threads:   s32; /* Maximum number of threads.  */
+    aio_num:       s32; /* Number of expected simultaneous requests.  */
+    aio_locks:     s32; /* Not used.  */
+    aio_usedba:    s32; /* Not used.  */
+    aio_debug:     s32; /* Not used.  */
+    aio_numusers:  s32; /* Not used.  */
+    /* Number of seconds before idle thread
+    terminates.  */
+    aio_idle_time: s32;
+
+    aio_reserved:  s32;
+}
+
+/* Return values of the aio_cancel function.  */
+AIO :: enum u32 {
+    CANCELED    :: 0;
+
+    NOTCANCELED :: 1;
+
+    ALLDONE     :: 2;
+
+    AIO_CANCELED    :: CANCELED;
+
+    AIO_NOTCANCELED :: NOTCANCELED;
+
+    AIO_ALLDONE     :: ALLDONE;
+}
+
+/* Operation codes for `aio_lio_opcode'.  */
+LIO :: enum u32 {
+    READ  :: 0;
+
+    WRITE :: 1;
+
+    NOP   :: 2;
+
+    LIO_READ  :: READ;
+
+    LIO_WRITE :: WRITE;
+
+    LIO_NOP   :: NOP;
+}
+
+/* Synchronization options for `lio_listio' function.  */
+LIO_1 :: enum u32 {
+    WAIT   :: 0;
+
+    NOWAIT :: 1;
+
+    LIO_WAIT   :: WAIT;
+
+    LIO_NOWAIT :: NOWAIT;
+}
+
+aio_init :: (__init: *aioinit) -> void #foreign libc;
+
+/* Enqueue read request for given number of bytes and the given priority.  */
+aio_read :: (__aiocbp: *aiocb) -> s32 #foreign libc;
+
+/* Enqueue write request for given number of bytes and the given priority.  */
+aio_write :: (__aiocbp: *aiocb) -> s32 #foreign libc;
+
+/* Initiate list of I/O requests.  */
+lio_listio :: (__mode: s32, __list: **aiocb, __nent: s32, __sig: *sigevent) -> s32 #foreign libc;
+
+/* Retrieve error status associated with AIOCBP.  */
+aio_error :: (__aiocbp: *aiocb) -> s32 #foreign libc;
+
+/* Return status associated with AIOCBP.  */
+aio_return :: (__aiocbp: *aiocb) -> s64 #foreign libc;
+
+/* Try to cancel asynchronous I/O requests outstanding against file
+descriptor FILDES.  */
+aio_cancel :: (__fildes: s32, __aiocbp: *aiocb) -> s32 #foreign libc;
+
+/* Suspend calling thread until at least one of the asynchronous I/O
+operations referenced by LIST has completed.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+aio_suspend :: (__list: **aiocb, __nent: s32, __timeout: *timespec) -> s32 #foreign libc;
+
+/* Force all operations associated with file desriptor described by
+`aio_fildes' member of AIOCBP.  */
+aio_fsync :: (__operation: s32, __aiocbp: *aiocb) -> s32 #foreign libc;
+
+aio_read64 :: (__aiocbp: *aiocb64) -> s32 #foreign libc;
+aio_write64 :: (__aiocbp: *aiocb64) -> s32 #foreign libc;
+
+lio_listio64 :: (__mode: s32, __list: **aiocb64, __nent: s32, __sig: *sigevent) -> s32 #foreign libc;
+
+aio_error64 :: (__aiocbp: *aiocb64) -> s32 #foreign libc;
+
+aio_return64 :: (__aiocbp: *aiocb64) -> s64 #foreign libc;
+
+aio_cancel64 :: (__fildes: s32, __aiocbp: *aiocb64) -> s32 #foreign libc;
+
+aio_suspend64 :: (__list: **aiocb64, __nent: s32, __timeout: *timespec) -> s32 #foreign libc;
+
+aio_fsync64 :: (__operation: s32, __aiocbp: *aiocb64) -> s32 #foreign libc;
+
+EFD :: enum u32 {
+    SEMAPHORE :: 1;
+
+    CLOEXEC   :: 524288;
+
+    NONBLOCK  :: 2048;
+
+    EFD_SEMAPHORE :: SEMAPHORE;
+
+    EFD_CLOEXEC   :: CLOEXEC;
+
+    EFD_NONBLOCK  :: NONBLOCK;
+}
+
+/* Type for event counter.  */
+eventfd_t :: u64;
+
+/* Return file descriptor for generic event channel.  Set initial
+value to COUNT.  */
+eventfd :: (__count: u32, __flags: s32) -> s32 #foreign libc;
+
+/* Read event counter and possibly wait for events.  */
+eventfd_read :: (__fd: s32, __value: *eventfd_t) -> s32 #foreign libc;
+
+/* Increment event counter.  */
+eventfd_write :: (__fd: s32, __value: eventfd_t) -> s32 #foreign libc;
+
+TFD :: enum u32 {
+    CLOEXEC  :: 524288;
+
+    NONBLOCK :: 2048;
+
+    TFD_CLOEXEC  :: CLOEXEC;
+
+    TFD_NONBLOCK :: NONBLOCK;
+}
+
+/* Bits to be set in the FLAGS parameter of `timerfd_settime'.  */
+TFD_TIMER :: enum u32 {
+    ABSTIME       :: 1;
+
+    CANCEL_ON_SET :: 2;
+
+    TFD_TIMER_ABSTIME       :: ABSTIME;
+
+    TFD_TIMER_CANCEL_ON_SET :: CANCEL_ON_SET;
+}
+
+/* Return file descriptor for new interval timer source.  */
+timerfd_create :: (__clock_id: s32, __flags: s32) -> s32 #foreign libc;
+
+/* Set next expiration time of interval timer source UFD to UTMR.  If
+FLAGS has the TFD_TIMER_ABSTIME flag set the timeout value is
+absolute.  Optionally return the old expiration time in OTMR.  */
+timerfd_settime :: (__ufd: s32, __flags: s32, __utmr: *itimerspec, __otmr: *itimerspec) -> s32 #foreign libc;
+
+/* Return the next expiration time of UFD.  */
+timerfd_gettime :: (__ufd: s32, __otmr: *itimerspec) -> s32 #foreign libc;
+
+SFD :: enum u32 {
+    CLOEXEC  :: 524288;
+
+    NONBLOCK :: 2048;
+
+    SFD_CLOEXEC  :: CLOEXEC;
+
+    SFD_NONBLOCK :: NONBLOCK;
+}
+
+signalfd_siginfo :: struct {
+    ssi_signo:     u32;
+    ssi_errno:     s32;
+    ssi_code:      s32;
+    ssi_pid:       u32;
+    ssi_uid:       u32;
+    ssi_fd:        s32;
+    ssi_tid:       u32;
+    ssi_band:      u32;
+    ssi_overrun:   u32;
+    ssi_trapno:    u32;
+    ssi_status:    s32;
+    ssi_int:       s32;
+    ssi_ptr:       u64;
+    ssi_utime:     u64;
+    ssi_stime:     u64;
+    ssi_addr:      u64;
+    ssi_addr_lsb:  u16;
+    __pad2:        u16;
+    ssi_syscall:   s32;
+    ssi_call_addr: u64;
+    ssi_arch:      u32;
+    __pad:         [28] u8;
+}
+
+/* Request notification for delivery of signals in MASK to be
+performed using descriptor FD.*/
+signalfd :: (__fd: s32, __mask: *sigset_t, __flags: s32) -> s32 #foreign libc;
+
+#scope_file
+
+libc :: #library,system "libc";
+librt :: #library,system "librt";
+
+USE_GNU :: true;
+
+#scope_export
+
+FILE :: _IO_FILE;
+_IO_FILE :: struct {};
+
+#if !USE_GNU {
+ftello64 :: ftello;
+}
+
+
+
diff --git a/modules/POSIX/bindings/linux/arm64/stdlib.jai b/modules/POSIX/bindings/linux/arm64/stdlib.jai
new file mode 100644
index 0000000..7d2caaf
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/stdlib.jai
@@ -0,0 +1,56 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
+getenv :: (__name: *u8) -> *u8 #foreign libc;
+
+/* Set NAME to VALUE in the environment.
+If REPLACE is nonzero, overwrite an existing value.  */
+setenv :: (__name: *u8, __value: *u8, __replace: s32) -> s32 #foreign libc;
+
+/* Remove the variable NAME from the environment.  */
+unsetenv :: (__name: *u8) -> s32 #foreign libc;
+
+/* Generate a unique temporary file name from TEMPLATE.
+The last six characters of TEMPLATE must be "XXXXXX";
+they are replaced with a string that makes the file name unique.
+Always returns TEMPLATE, it's either a temporary file name or a null
+string if it cannot get a unique file name.  */
+mktemp :: (__template: *u8) -> *u8 #foreign libc;
+
+mkstemp :: (__template: *u8) -> s32 #foreign libc;
+
+mkstemps :: (__template: *u8, __suffixlen: s32) -> s32 #foreign libc;
+
+/* Create a unique temporary directory from TEMPLATE.
+The last six characters of TEMPLATE must be "XXXXXX";
+they are replaced with a string that makes the directory name unique.
+Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+The directory is created mode 700.  */
+mkdtemp :: (__template: *u8) -> *u8 #foreign libc;
+
+mkostemp :: (__template: *u8, __flags: s32) -> s32 #foreign libc;
+
+mkostemps :: (__template: *u8, __suffixlen: s32, __flags: s32) -> s32 #foreign libc;
+
+/* Execute the given line as a shell command.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+system :: (__command: *u8) -> s32 #foreign libc;
+
+/* Return the canonical absolute name of file NAME.  If RESOLVED is
+null, the result is malloc'd; otherwise, if the canonical name is
+PATH_MAX chars or more, returns null with `errno' set to
+ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
+returns the name in RESOLVED.  */
+realpath :: (__name: *u8, __resolved: *u8) -> *u8 #foreign libc;
+
+#scope_file
+
+libc :: #library,system "libc";
diff --git a/modules/POSIX/bindings/linux/arm64/syscall.jai b/modules/POSIX/bindings/linux/arm64/syscall.jai
new file mode 100644
index 0000000..8a2bdf8
--- /dev/null
+++ b/modules/POSIX/bindings/linux/arm64/syscall.jai
@@ -0,0 +1,635 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+SYS_accept :: 202;
+
+SYS_accept4 :: 242;
+
+SYS_acct :: 89;
+
+SYS_add_key :: 217;
+
+SYS_adjtimex :: 171;
+
+SYS_bind :: 200;
+
+SYS_bpf :: 280;
+
+SYS_brk :: 214;
+
+SYS_capget :: 90;
+
+SYS_capset :: 91;
+
+SYS_chdir :: 49;
+
+SYS_chroot :: 51;
+
+SYS_clock_adjtime :: 266;
+
+SYS_clock_getres :: 114;
+
+SYS_clock_gettime :: 113;
+
+SYS_clock_nanosleep :: 115;
+
+SYS_clock_settime :: 112;
+
+SYS_clone :: 220;
+
+SYS_clone3 :: 435;
+
+SYS_close :: 57;
+
+SYS_close_range :: 436;
+
+SYS_connect :: 203;
+
+SYS_copy_file_range :: 285;
+
+SYS_delete_module :: 106;
+
+SYS_dup :: 23;
+
+SYS_dup3 :: 24;
+
+SYS_epoll_create1 :: 20;
+
+SYS_epoll_ctl :: 21;
+
+SYS_epoll_pwait :: 22;
+
+SYS_epoll_pwait2 :: 441;
+
+SYS_eventfd2 :: 19;
+
+SYS_execve :: 221;
+
+SYS_execveat :: 281;
+
+SYS_exit :: 93;
+
+SYS_exit_group :: 94;
+
+SYS_faccessat :: 48;
+
+SYS_faccessat2 :: 439;
+
+SYS_fadvise64 :: 223;
+
+SYS_fallocate :: 47;
+
+SYS_fanotify_init :: 262;
+
+SYS_fanotify_mark :: 263;
+
+SYS_fchdir :: 50;
+
+SYS_fchmod :: 52;
+
+SYS_fchmodat :: 53;
+
+SYS_fchown :: 55;
+
+SYS_fchownat :: 54;
+
+SYS_fcntl :: 25;
+
+SYS_fdatasync :: 83;
+
+SYS_fgetxattr :: 10;
+
+SYS_finit_module :: 273;
+
+SYS_flistxattr :: 13;
+
+SYS_flock :: 32;
+
+SYS_fremovexattr :: 16;
+
+SYS_fsconfig :: 431;
+
+SYS_fsetxattr :: 7;
+
+SYS_fsmount :: 432;
+
+SYS_fsopen :: 430;
+
+SYS_fspick :: 433;
+
+SYS_fstat :: 80;
+
+SYS_fstatfs :: 44;
+
+SYS_fsync :: 82;
+
+SYS_ftruncate :: 46;
+
+SYS_futex :: 98;
+
+SYS_futex_waitv :: 449;
+
+SYS_get_mempolicy :: 236;
+
+SYS_get_robust_list :: 100;
+
+SYS_getcpu :: 168;
+
+SYS_getcwd :: 17;
+
+SYS_getdents64 :: 61;
+
+SYS_getegid :: 177;
+
+SYS_geteuid :: 175;
+
+SYS_getgid :: 176;
+
+SYS_getgroups :: 158;
+
+SYS_getitimer :: 102;
+
+SYS_getpeername :: 205;
+
+SYS_getpgid :: 155;
+
+SYS_getpid :: 172;
+
+SYS_getppid :: 173;
+
+SYS_getpriority :: 141;
+
+SYS_getrandom :: 278;
+
+SYS_getresgid :: 150;
+
+SYS_getresuid :: 148;
+
+SYS_getrlimit :: 163;
+
+SYS_getrusage :: 165;
+
+SYS_getsid :: 156;
+
+SYS_getsockname :: 204;
+
+SYS_getsockopt :: 209;
+
+SYS_gettid :: 178;
+
+SYS_gettimeofday :: 169;
+
+SYS_getuid :: 174;
+
+SYS_getxattr :: 8;
+
+SYS_init_module :: 105;
+
+SYS_inotify_add_watch :: 27;
+
+SYS_inotify_init1 :: 26;
+
+SYS_inotify_rm_watch :: 28;
+
+SYS_io_cancel :: 3;
+
+SYS_io_destroy :: 1;
+
+SYS_io_getevents :: 4;
+
+SYS_io_pgetevents :: 292;
+
+SYS_io_setup :: 0;
+
+SYS_io_submit :: 2;
+
+SYS_io_uring_enter :: 426;
+
+SYS_io_uring_register :: 427;
+
+SYS_io_uring_setup :: 425;
+
+SYS_ioctl :: 29;
+
+SYS_ioprio_get :: 31;
+
+SYS_ioprio_set :: 30;
+
+SYS_kcmp :: 272;
+
+SYS_kexec_file_load :: 294;
+
+SYS_kexec_load :: 104;
+
+SYS_keyctl :: 219;
+
+SYS_kill :: 129;
+
+SYS_landlock_add_rule :: 445;
+
+SYS_landlock_create_ruleset :: 444;
+
+SYS_landlock_restrict_self :: 446;
+
+SYS_lgetxattr :: 9;
+
+SYS_linkat :: 37;
+
+SYS_listen :: 201;
+
+SYS_listxattr :: 11;
+
+SYS_llistxattr :: 12;
+
+SYS_lookup_dcookie :: 18;
+
+SYS_lremovexattr :: 15;
+
+SYS_lseek :: 62;
+
+SYS_lsetxattr :: 6;
+
+SYS_madvise :: 233;
+
+SYS_mbind :: 235;
+
+SYS_membarrier :: 283;
+
+SYS_memfd_create :: 279;
+
+SYS_memfd_secret :: 447;
+
+SYS_migrate_pages :: 238;
+
+SYS_mincore :: 232;
+
+SYS_mkdirat :: 34;
+
+SYS_mknodat :: 33;
+
+SYS_mlock :: 228;
+
+SYS_mlock2 :: 284;
+
+SYS_mlockall :: 230;
+
+SYS_mmap :: 222;
+
+SYS_mount :: 40;
+
+SYS_mount_setattr :: 442;
+
+SYS_move_mount :: 429;
+
+SYS_move_pages :: 239;
+
+SYS_mprotect :: 226;
+
+SYS_mq_getsetattr :: 185;
+
+SYS_mq_notify :: 184;
+
+SYS_mq_open :: 180;
+
+SYS_mq_timedreceive :: 183;
+
+SYS_mq_timedsend :: 182;
+
+SYS_mq_unlink :: 181;
+
+SYS_mremap :: 216;
+
+SYS_msgctl :: 187;
+
+SYS_msgget :: 186;
+
+SYS_msgrcv :: 188;
+
+SYS_msgsnd :: 189;
+
+SYS_msync :: 227;
+
+SYS_munlock :: 229;
+
+SYS_munlockall :: 231;
+
+SYS_munmap :: 215;
+
+SYS_name_to_handle_at :: 264;
+
+SYS_nanosleep :: 101;
+
+SYS_newfstatat :: 79;
+
+SYS_nfsservctl :: 42;
+
+SYS_open_by_handle_at :: 265;
+
+SYS_open_tree :: 428;
+
+SYS_openat :: 56;
+
+SYS_openat2 :: 437;
+
+SYS_perf_event_open :: 241;
+
+SYS_personality :: 92;
+
+SYS_pidfd_getfd :: 438;
+
+SYS_pidfd_open :: 434;
+
+SYS_pidfd_send_signal :: 424;
+
+SYS_pipe2 :: 59;
+
+SYS_pivot_root :: 41;
+
+SYS_pkey_alloc :: 289;
+
+SYS_pkey_free :: 290;
+
+SYS_pkey_mprotect :: 288;
+
+SYS_ppoll :: 73;
+
+SYS_prctl :: 167;
+
+SYS_pread64 :: 67;
+
+SYS_preadv :: 69;
+
+SYS_preadv2 :: 286;
+
+SYS_prlimit64 :: 261;
+
+SYS_process_madvise :: 440;
+
+SYS_process_mrelease :: 448;
+
+SYS_process_vm_readv :: 270;
+
+SYS_process_vm_writev :: 271;
+
+SYS_pselect6 :: 72;
+
+SYS_ptrace :: 117;
+
+SYS_pwrite64 :: 68;
+
+SYS_pwritev :: 70;
+
+SYS_pwritev2 :: 287;
+
+SYS_quotactl :: 60;
+
+SYS_quotactl_fd :: 443;
+
+SYS_read :: 63;
+
+SYS_readahead :: 213;
+
+SYS_readlinkat :: 78;
+
+SYS_readv :: 65;
+
+SYS_reboot :: 142;
+
+SYS_recvfrom :: 207;
+
+SYS_recvmmsg :: 243;
+
+SYS_recvmsg :: 212;
+
+SYS_remap_file_pages :: 234;
+
+SYS_removexattr :: 14;
+
+SYS_renameat :: 38;
+
+SYS_renameat2 :: 276;
+
+SYS_request_key :: 218;
+
+SYS_restart_syscall :: 128;
+
+SYS_rseq :: 293;
+
+SYS_rt_sigaction :: 134;
+
+SYS_rt_sigpending :: 136;
+
+SYS_rt_sigprocmask :: 135;
+
+SYS_rt_sigqueueinfo :: 138;
+
+SYS_rt_sigreturn :: 139;
+
+SYS_rt_sigsuspend :: 133;
+
+SYS_rt_sigtimedwait :: 137;
+
+SYS_rt_tgsigqueueinfo :: 240;
+
+SYS_sched_get_priority_max :: 125;
+
+SYS_sched_get_priority_min :: 126;
+
+SYS_sched_getaffinity :: 123;
+
+SYS_sched_getattr :: 275;
+
+SYS_sched_getparam :: 121;
+
+SYS_sched_getscheduler :: 120;
+
+SYS_sched_rr_get_interval :: 127;
+
+SYS_sched_setaffinity :: 122;
+
+SYS_sched_setattr :: 274;
+
+SYS_sched_setparam :: 118;
+
+SYS_sched_setscheduler :: 119;
+
+SYS_sched_yield :: 124;
+
+SYS_seccomp :: 277;
+
+SYS_semctl :: 191;
+
+SYS_semget :: 190;
+
+SYS_semop :: 193;
+
+SYS_semtimedop :: 192;
+
+SYS_sendfile :: 71;
+
+SYS_sendmmsg :: 269;
+
+SYS_sendmsg :: 211;
+
+SYS_sendto :: 206;
+
+SYS_set_mempolicy :: 237;
+
+SYS_set_mempolicy_home_node :: 450;
+
+SYS_set_robust_list :: 99;
+
+SYS_set_tid_address :: 96;
+
+SYS_setdomainname :: 162;
+
+SYS_setfsgid :: 152;
+
+SYS_setfsuid :: 151;
+
+SYS_setgid :: 144;
+
+SYS_setgroups :: 159;
+
+SYS_sethostname :: 161;
+
+SYS_setitimer :: 103;
+
+SYS_setns :: 268;
+
+SYS_setpgid :: 154;
+
+SYS_setpriority :: 140;
+
+SYS_setregid :: 143;
+
+SYS_setresgid :: 149;
+
+SYS_setresuid :: 147;
+
+SYS_setreuid :: 145;
+
+SYS_setrlimit :: 164;
+
+SYS_setsid :: 157;
+
+SYS_setsockopt :: 208;
+
+SYS_settimeofday :: 170;
+
+SYS_setuid :: 146;
+
+SYS_setxattr :: 5;
+
+SYS_shmat :: 196;
+
+SYS_shmctl :: 195;
+
+SYS_shmdt :: 197;
+
+SYS_shmget :: 194;
+
+SYS_shutdown :: 210;
+
+SYS_sigaltstack :: 132;
+
+SYS_signalfd4 :: 74;
+
+SYS_socket :: 198;
+
+SYS_socketpair :: 199;
+
+SYS_splice :: 76;
+
+SYS_statfs :: 43;
+
+SYS_statx :: 291;
+
+SYS_swapoff :: 225;
+
+SYS_swapon :: 224;
+
+SYS_symlinkat :: 36;
+
+SYS_sync :: 81;
+
+SYS_sync_file_range :: 84;
+
+SYS_syncfs :: 267;
+
+SYS_sysinfo :: 179;
+
+SYS_syslog :: 116;
+
+SYS_tee :: 77;
+
+SYS_tgkill :: 131;
+
+SYS_timer_create :: 107;
+
+SYS_timer_delete :: 111;
+
+SYS_timer_getoverrun :: 109;
+
+SYS_timer_gettime :: 108;
+
+SYS_timer_settime :: 110;
+
+SYS_timerfd_create :: 85;
+
+SYS_timerfd_gettime :: 87;
+
+SYS_timerfd_settime :: 86;
+
+SYS_times :: 153;
+
+SYS_tkill :: 130;
+
+SYS_truncate :: 45;
+
+SYS_umask :: 166;
+
+SYS_umount2 :: 39;
+
+SYS_uname :: 160;
+
+SYS_unlinkat :: 35;
+
+SYS_unshare :: 97;
+
+SYS_userfaultfd :: 282;
+
+SYS_utimensat :: 88;
+
+SYS_vhangup :: 58;
+
+SYS_vmsplice :: 75;
+
+SYS_wait4 :: 260;
+
+SYS_waitid :: 95;
+
+SYS_write :: 64;
+
+SYS_writev :: 66;
+
+/* Invoke `system call' number SYSNO, passing it the remaining arguments.
+This is completely system-dependent, and not often useful.
+
+In Unix, `syscall' sets `errno' for all errors and most calls return -1
+for errors; in many systems you cannot pass arguments or get return
+values for all system calls (`pipe', `fork', and `getppid' typically
+among them).
+
+In Mach, all system calls take normal arguments and always return an
+error code (zero for success).  */
+syscall :: (__sysno: s64, __args: ..Any) -> s64 #foreign libc;
+
+#scope_file
+
+libc :: #library,system "libc";
diff --git a/modules/POSIX/generate.jai b/modules/POSIX/generate.jai
index bc542d6..6c9fbad 100644
--- a/modules/POSIX/generate.jai
+++ b/modules/POSIX/generate.jai
@@ -24,6 +24,7 @@ ENABLE_GNU_SOURCE :: true; // Enable this and re-run the generator to get Linux
 }
 
 already_generated: Table(string, bool);
+cross_compiler_sysroot: string;
 
 generate_bindings :: (args: [] string) -> bool {
     target_android := array_find(args, "-android");
@@ -38,7 +39,11 @@ generate_bindings :: (args: [] string) -> bool {
 
     bindings_directory: string;
     if os_target == {
-        case .LINUX;   bindings_directory = "bindings/linux";
+        case .LINUX;
+            if cpu_target == {
+                case .X64;   bindings_directory = "bindings/linux/x64";
+                case .ARM64; bindings_directory = "bindings/linux/arm64";
+            }
         case .MACOS;
             if cpu_target == {
                 case .X64;   bindings_directory = "bindings/macos/x64";
@@ -52,9 +57,21 @@ generate_bindings :: (args: [] string) -> bool {
     }
     assert(bindings_directory != "", "Unsupported OS/CPU");
 
+    success := true;
+
+    if os_target != OS || cpu_target != CPU {
+        passed_cross_sysroot, cross_sysroot_index := array_find(args, "-cross_compiler_sysroot");
+        if passed_cross_sysroot && cross_sysroot_index < args.count-1 {
+            cross_compiler_sysroot = args[cross_sysroot_index + 1];
+        }
+        else {
+            log_error("Since we're trying to generate bindings for a cross-compile target, please pass a system root folder with -cross_compiler_sysroot.");
+            success = false;
+        }
+    }
+
     make_directory_if_it_does_not_exist(bindings_directory, recursive = true);
 
-    success := true;
     success &&= generate_stdio_bindings(   os_target, cpu_target, bindings_directory);
     success &&= generate_stdlib_bindings(  os_target, cpu_target, bindings_directory);
     success &&= generate_syscall_bindings( os_target, cpu_target, bindings_directory);
@@ -72,14 +89,14 @@ generate_base_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_dire
 
     options.generate_printf_wrappers = false;
 
-    libc_path, libc_platform_path := get_libc_paths(os, cpu);
+    libc_path, libc_platform_path := posix_get_libc_paths(os, cpu);
 
-    sys_path := ifx os == .LINUX then libc_platform_path else libc_path;
+    sys_path := ifx os == .LINUX && cpu == CPU then libc_platform_path else libc_path;
 
     if os == .LINUX {
         array_add(*options.system_library_names,
-            "libdl", // dlopen, etc.
-            "librt", // shm_*
+            "libdl.so.2", // dlopen, etc.
+            "librt.so.1", // shm_*
         );
     }
     if os == .ANDROID {
@@ -242,6 +259,17 @@ generate_base_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_dire
             "_xmmreg",
             "timex",
         );
+
+        if cpu == .ARM64 {
+            array_add(*options.system_types_to_include,
+                "elf_fpregset_t",
+                "elf_greg_t",
+                "elf_gregset_t",
+                "idtype_t",
+                "ipc_perm",
+                "shmid_ds",
+            );
+        }
     }
     if os == .ANDROID {
         array_add(*options.system_types_to_include,
@@ -506,11 +534,11 @@ generate_stdio_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_dir
     output_path := tprint("%/stdio.jai", bindings_directory);
     options := get_common_options(os, cpu);
 
-    libc_path, libc_platform_path := get_libc_paths(os, cpu);
-    sys_path := ifx os == .LINUX then libc_platform_path else libc_path;
+    libc_path, libc_platform_path := posix_get_libc_paths(os, cpu);
+    sys_path := ifx os == .LINUX && cpu == CPU then libc_platform_path else libc_path;
 
     if os == .LINUX {
-        array_add(*options.system_library_names, "librt"); // aio_*
+        array_add(*options.system_library_names, "librt.so.1"); // aio_*
     }
     array_add(*options.source_files,
         tprint("%/stdio.h", libc_path),
@@ -572,6 +600,16 @@ generate_stdio_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_dir
             "__mbstate_t",
             "_IO_cookie_io_functions_t", // fopencookie
         );
+
+        if cpu == .ARM64 {
+            array_add(*options.system_types_to_include,
+                "cookie_close_function_t",
+                "cookie_io_functions_t",
+                "cookie_read_function_t",
+                "cookie_seek_function_t",
+                "cookie_write_function_t",
+            );
+        }
     }
     #if ENABLE_GNU_SOURCE {
         array_add(*options.system_types_to_include,
@@ -584,7 +622,12 @@ generate_stdio_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_dir
 
     options.visitor = stdio_visitor;
     if os == {
-        case .LINUX; options.footer = sprint(STDIO_LINUX_FOOTER_TEMPLATE, ENABLE_GNU_SOURCE);
+        case .LINUX;
+            options.footer = sprint(
+                STDIO_LINUX_FOOTER_TEMPLATE,
+                ENABLE_GNU_SOURCE,
+                ifx cpu == .ARM64 then "" else STDIO_LINUX_FOOTER_SYSCALL_WRAPPERS,
+            );
         case .MACOS; options.footer = STDIO_MACOS_FOOTER;
     }
 
@@ -604,6 +647,12 @@ _IO_FILE :: struct {};
 ftello64 :: ftello;
 }
 
+%
+
+END
+
+STDIO_LINUX_FOOTER_SYSCALL_WRAPPERS :: #string END
+
 // for some reason a handfull of syscalls on Linux arent available in libc.so by default
 // (they exist as a static link in) so we need to wrap syscall for these to work...
 stat  :: (path: *u8, buf: *stat_t) -> s64 { return syscall(SYS_stat, path, buf); }
@@ -637,6 +686,16 @@ stdio_visitor :: (decl: *Declaration, parent_decl: *Declaration) -> Declaration_
             decl.decl_flags |= .OMIT_FROM_OUTPUT;
             return .STOP;
         }
+
+        // ARM64 hack: x64 Linux bindings don't include vsnprintf and friends, so I won't here.
+        if decl.kind == .FUNCTION &&
+           ( ( starts_with(decl.name, "v") &&
+               ( ends_with(decl.name, "printf") || ends_with(decl.name, "scanf") ) ) ||
+             contains(decl.name, "vprintf") )
+        {
+            decl.decl_flags |= .OMIT_FROM_OUTPUT;
+            return .STOP;
+        }
     } else {
         // Rename the members of stat_t to be the same on all platforms, just to reduce the number of "#if OS" clauses needed
         if parent_decl.kind == .STRUCT && (parent_decl.output_name == "stat_t" || parent_decl.output_name == "stat64_t") {
@@ -660,7 +719,7 @@ generate_stdlib_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_di
     output_path := tprint("%/stdlib.jai", bindings_directory);
     options := get_common_options(os, cpu);
 
-    libc_path := get_libc_paths(os, cpu);
+    libc_path := posix_get_libc_paths(os, cpu);
 
     array_add(*options.source_files,
         tprint("%/stdlib.h", libc_path),
@@ -712,8 +771,8 @@ generate_syscall_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_d
     output_path := tprint("%/syscall.jai", bindings_directory);
     options := get_common_options(os, cpu);
 
-    libc_path, libc_platform_path := get_libc_paths(os, cpu);
-    sys_path := ifx os == .LINUX then libc_platform_path else libc_path;
+    libc_path, libc_platform_path := posix_get_libc_paths(os, cpu);
+    sys_path := ifx os == .LINUX && cpu == CPU then libc_platform_path else libc_path;
 
     array_add(*options.source_files,
         tprint("%/unistd.h", libc_path), // for syscall()
@@ -749,10 +808,17 @@ generate_pthread_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_d
     options := get_common_options(os, cpu);
 
     if os == .LINUX {
-        array_insert_at(*options.libnames, "libpthread.so.0", 0);
+        array_insert_at(*options.system_library_names, "libpthread.so.0", 0);
+
+        if cpu == .ARM64 {
+            array_add(
+                *options.system_library_paths,
+                tprint("%/aarch64-linux-gnu/libc/lib64", cross_compiler_sysroot),
+            );
+        }
     }
 
-    libc_path := get_libc_paths(os, cpu);
+    libc_path := posix_get_libc_paths(os, cpu);
 
     array_add(*options.source_files,
         tprint("%/pthread.h",   libc_path),
@@ -839,8 +905,8 @@ generate_resource_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_
     output_path := tprint("%/resource.jai", bindings_directory);
     options := get_common_options(os, cpu);
 
-    libc_path, libc_platform_path := get_libc_paths(os, cpu);
-    if os == .LINUX {
+    libc_path, libc_platform_path := posix_get_libc_paths(os, cpu);
+    if os == .LINUX && cpu == CPU {
         array_add(*options.source_files, tprint("%/sys/resource.h", libc_platform_path));
     } else {
         array_add(*options.source_files, tprint("%/sys/resource.h", libc_path));
@@ -958,7 +1024,7 @@ generate_sysctl_bindings :: (os: Operating_System_Tag, cpu: CPU_Tag, bindings_di
     output_path := tprint("%/sysctl.jai", bindings_directory);
     options := get_common_options(os, cpu);
 
-    libc_path := get_libc_paths(os, cpu);
+    libc_path := posix_get_libc_paths(os, cpu);
     array_add(*options.source_files, tprint("%/sys/sysctl.h", libc_path));
 
     array_add(*options.system_types_to_include, "extern_proc", "P_TRACED", "pgrp", "session", "proc", "vmspace");
@@ -990,6 +1056,26 @@ get_common_options :: (os: Operating_System_Tag, cpu: CPU_Tag) -> Generate_Bindi
             #if ENABLE_GNU_SOURCE {
                 array_add(*options.extra_clang_arguments, "-D_GNU_SOURCE");
             }
+
+            if cpu == .ARM64 {
+                array_add(*options.extra_clang_arguments,
+                    "-target", "aarch64-unknown-linux-gnu",
+                    "-isysroot", cross_compiler_sysroot,
+                );
+
+                libc_path, libc_platform_path := posix_get_libc_paths(os, cpu);
+                array_add(
+                    *options.system_include_paths,
+                    libc_path,
+                    libc_platform_path,
+                    tprint("%/lib/gcc/aarch64-linux-gnu/14.2.0/include", cross_compiler_sysroot),
+                );
+                array_add(
+                    *options.system_library_paths,
+                    tprint("%/lib",                          cross_compiler_sysroot),
+                    tprint("%/aarch64-linux-gnu/libc/lib64", cross_compiler_sysroot),
+                );
+            }
         case .MACOS;
             sdk_path := get_macos_sdk_path();
             build_options := get_build_options(); // @Incomplete: run-time version
@@ -1112,6 +1198,22 @@ posix_visitor :: (decl: *Declaration, parent_decl: *Declaration) -> Declaration_
     return .RECURSE;
 }
 
+posix_get_libc_paths :: (os := OS, cpu := CPU) -> libc_path: string, libc_platform_path: string, success: bool {
+    libc_path, libc_platform_path: string;
+    success: bool;
+
+    if cpu == .ARM64 && CPU != cpu {
+        libc_path          = tprint("%/aarch64-linux-gnu/libc/usr/include/", cross_compiler_sysroot);
+        libc_platform_path = tprint("%/aarch64-linux-gnu/include",           cross_compiler_sysroot);
+        success = true;
+    }
+    else {
+        libc_path, libc_platform_path, success = get_libc_paths(os, cpu);
+    }
+
+    return libc_path, libc_platform_path, success;
+}
+
 #import "Toolchains/Android";
 #import "Toolchains/macOS";
 #import "Basic";
diff --git a/modules/POSIX/module.jai b/modules/POSIX/module.jai
index 805a173..83770ee 100644
--- a/modules/POSIX/module.jai
+++ b/modules/POSIX/module.jai
@@ -26,12 +26,21 @@ off_t    :: s64;
 
 #if OS == {
     case .LINUX;
-        #load "bindings/linux/base.jai";
-        #load "bindings/linux/stdio.jai";
-        #load "bindings/linux/stdlib.jai";
-        #load "bindings/linux/syscall.jai";
-        #load "bindings/linux/pthread.jai";
-        #load "bindings/linux/resource.jai";
+        #if CPU == .ARM64 {
+            #load "bindings/linux/arm64/base.jai";
+            #load "bindings/linux/arm64/stdio.jai";
+            #load "bindings/linux/arm64/stdlib.jai";
+            #load "bindings/linux/arm64/syscall.jai";
+            #load "bindings/linux/arm64/pthread.jai";
+            #load "bindings/linux/arm64/resource.jai";
+        } else {
+            #load "bindings/linux/base.jai";
+            #load "bindings/linux/stdio.jai";
+            #load "bindings/linux/stdlib.jai";
+            #load "bindings/linux/syscall.jai";
+            #load "bindings/linux/pthread.jai";
+            #load "bindings/linux/resource.jai";
+        }
 
     case .MACOS;
         SYSCALL_MACH_BASE :: 0x1000000;
diff --git a/modules/Simp/backend/gl.jai b/modules/Simp/backend/gl.jai
index 993434e..7dc69df 100644
--- a/modules/Simp/backend/gl.jai
+++ b/modules/Simp/backend/gl.jai
@@ -203,9 +203,9 @@ OUT_IN vec2 TextureCoords;
 OUT_IN vec4 iterated_color;
 
 #ifdef VERTEX_SHADER
-in vec4 vert_position;
-in vec4 vert_color;
-in vec2 vert_uv0;
+attribute vec4 vert_position;
+attribute vec4 vert_color;
+attribute vec2 vert_uv0;
 
 uniform mat4 projection;
 
@@ -217,14 +217,12 @@ void main() {
 #endif // VERTEX_SHADER
 
 #ifdef FRAGMENT_SHADER
-out vec4 color;
-
 uniform sampler2D text_sampler;
 uniform vec4 text_color;
 
 void main () {
-    vec4 texture_sample = texture(text_sampler, TextureCoords);
-    color = vec4(iterated_color.xyz, texture_sample.a * iterated_color.a); // text_color * texture_sample;
+    vec4 texture_sample = texture2D(text_sampler, TextureCoords);
+    gl_FragColor = vec4(iterated_color.xyz, texture_sample.a * iterated_color.a); // text_color * texture_sample;
 }
 #endif // FRAGMENT_SHADER
 END
@@ -234,8 +232,8 @@ SHADER_COLOR :: #string END
 OUT_IN vec4 iterated_color;
 
 #ifdef VERTEX_SHADER
-in vec4 vert_position;
-in vec4 vert_color;
+attribute vec4 vert_position;
+attribute vec4 vert_color;
 
 uniform mat4 projection;
 
@@ -246,10 +244,8 @@ void main() {
 #endif // VERTEX_SHADER
 
 #ifdef FRAGMENT_SHADER
-out vec4 color;
-
 void main () {
-    color = iterated_color;
+    gl_FragColor = iterated_color;
 }
 #endif // FRAGMENT_SHADER
 END
@@ -263,9 +259,9 @@ OUT_IN vec2 TexCoords;
 OUT_IN vec4 iterated_color;
 
 #ifdef VERTEX_SHADER
-in vec4 vert_position;
-in vec4 vert_color;
-in vec2 vert_uv0;
+attribute vec4 vert_position;
+attribute vec4 vert_color;
+attribute vec2 vert_uv0;
 
 uniform mat4 projection;
 
@@ -277,15 +273,13 @@ void main() {
 #endif // VERTEX_SHADER
 
 #ifdef FRAGMENT_SHADER
-out vec4 color;
-
 uniform sampler2D diffuse_texture;
 
 void main () {
     vec4 color_tex = iterated_color * texture(diffuse_texture, TexCoords);
     if (color_tex.a < 0.1) discard;
 
-    color = color_tex;
+    gl_FragColor = color_tex;
 }
 #endif // FRAGMENT_SHADER
 END
@@ -296,9 +290,9 @@ OUT_IN vec2 TexCoords;
 OUT_IN vec4 iterated_color;
 
 #ifdef VERTEX_SHADER
-in vec4 vert_position;
-in vec4 vert_color;
-in vec2 vert_uv0;
+attribute vec4 vert_position;
+attribute vec4 vert_color;
+attribute vec2 vert_uv0;
 
 uniform mat4 projection;
 
@@ -310,15 +304,13 @@ void main() {
 #endif // VERTEX_SHADER
 
 #ifdef FRAGMENT_SHADER
-out vec4 color;
-
 uniform sampler2D diffuse_texture;
 
 void main () {
-    vec4 color_tex = iterated_color * texture(diffuse_texture, TexCoords);
+    vec4 color_tex = iterated_color * texture2D(diffuse_texture, TexCoords);
     if (color_tex.a < 0.1) discard;
 
-    color = color_tex;
+    gl_FragColor = color_tex;
 }
 #endif // FRAGMENT_SHADER
 END
@@ -373,15 +365,15 @@ get_shader_program :: (shader_text: string) -> GLuint {
         END
     } else {
         PREFIX_V :: #string END
-        #version 330 core
+        #version 120
         #define VERTEX_SHADER
-        #define OUT_IN out
+        #define OUT_IN varying
         END
 
         PREFIX_F :: #string END
-        #version 330 core
+        #version 120
         #define FRAGMENT_SHADER
-        #define OUT_IN in
+        #define OUT_IN varying
         END
     }
 
diff --git a/modules/Socket/generate.jai b/modules/Socket/generate.jai
index 6f18e31..adbdadf 100644
--- a/modules/Socket/generate.jai
+++ b/modules/Socket/generate.jai
@@ -28,6 +28,8 @@ TYPE_PREFIXES_TO_OMIT :: string.[
     "__darwin_",
 ];
 
+cross_compiler_sysroot: string;
+
 #if AT_COMPILE_TIME {
     #run,stallable {
         set_build_options_dc(.{do_output=false});
@@ -40,6 +42,17 @@ TYPE_PREFIXES_TO_OMIT :: string.[
         if array_find(args, "-x64")     cpu = .X64;
         if array_find(args, "-arm64")   cpu = .ARM64;
 
+        if os != OS || cpu != CPU {
+            passed_cross_sysroot, cross_sysroot_index := array_find(args, "-cross_compiler_sysroot");
+            if passed_cross_sysroot && cross_sysroot_index < args.count-1 {
+                cross_compiler_sysroot = args[cross_sysroot_index + 1];
+            }
+            else {
+                log_error("Since we're trying to generate bindings for a cross-compile target, please pass a system root folder with -cross_compiler_sysroot.");
+                return;
+            }
+        }
+
         if !generate_bindings(os, cpu) {
             compiler_set_workspace_status(.FAILED);
         }
@@ -68,7 +81,32 @@ generate_bindings :: (target_os: Operating_System_Tag = OS, target_cpu: CPU_Tag
                 array_add(*system_library_names, "ws2_32.dll");
                 array_add(*extra_clang_arguments, "-DWIN32_LEAN_AND_MEAN");
             case .LINUX;
-                output_filename = "generated_linux.jai";
+                if cpu == .ARM64 {
+                    output_filename = "generated_linux_arm64.jai";
+                }
+                else {
+                    output_filename = "generated_linux.jai";
+                }
+
+                if cpu == .ARM64 {
+                    array_add(*options.extra_clang_arguments,
+                        "-target", "aarch64-unknown-linux-gnu",
+                        "-isysroot", cross_compiler_sysroot,
+                    );
+
+                    libc_path, libc_platform_path := socket_get_libc_paths(os, cpu);
+                    array_add(
+                        *options.system_include_paths,
+                        libc_path,
+                        libc_platform_path,
+                        tprint("%/lib/gcc/aarch64-linux-gnu/14.2.0/include", cross_compiler_sysroot),
+                    );
+                    array_add(
+                        *options.system_library_paths,
+                        tprint("%/lib",                          cross_compiler_sysroot),
+                        tprint("%/aarch64-linux-gnu/libc/lib64", cross_compiler_sysroot),
+                    );
+                }
                 array_add(*system_library_names, "libc.so.6");
             case .MACOS;
                 output_filename = "generated_macos.jai";
@@ -102,8 +140,8 @@ generate_bindings :: (target_os: Operating_System_Tag = OS, target_cpu: CPU_Tag
             array_add(*source_files, "winsock2.h", "ws2tcpip.h", "mstcpip.h");
             array_add(*path_fragments_to_treat_as_non_system_paths, "winsock2.h", "ws2def.h", "inaddr.h", "qos.h", "ws2tcpip.h", "ws2ipdef.h", "in6addr.h", "mstcpip.h");
         } else {
-            libc_path, libc_platform_path := get_libc_paths(os, cpu);
-            socket_path := ifx target_os == .LINUX then libc_platform_path else libc_path;
+            libc_path, libc_platform_path := socket_get_libc_paths(os, cpu);
+            socket_path := ifx target_os == .LINUX && cpu == CPU then libc_platform_path else libc_path;
             // For some reason, we have to use full paths or libclang will not provide _any_ comments for the declaration cursors, for no apparent reason (observed on macOS).
             array_add(*source_files,
                 tprint("%/sys/socket.h",  socket_path),
@@ -376,6 +414,22 @@ get_enum_name :: (argument_name: string, parent_name: string) -> string {
     return "";
 }
 
+socket_get_libc_paths :: (os := OS, cpu := CPU) -> libc_path: string, libc_platform_path: string, success: bool {
+    libc_path, libc_platform_path: string;
+    success: bool;
+
+    if cpu == .ARM64 && CPU != cpu {
+        libc_path          = tprint("%/aarch64-linux-gnu/libc/usr/include/", cross_compiler_sysroot);
+        libc_platform_path = tprint("%/aarch64-linux-gnu/include",           cross_compiler_sysroot);
+        success = true;
+    }
+    else {
+        libc_path, libc_platform_path, success = get_libc_paths(os, cpu);
+    }
+
+    return libc_path, libc_platform_path, success;
+}
+
 #import "Toolchains/Android";
 #import "Toolchains/macOS";
 #import "Basic";
diff --git a/modules/Socket/generated_linux_arm64.jai b/modules/Socket/generated_linux_arm64.jai
new file mode 100644
index 0000000..ae10d3b
--- /dev/null
+++ b/modules/Socket/generated_linux_arm64.jai
@@ -0,0 +1,2210 @@
+//
+// This file was auto-generated using the following command:
+//
+// jai generate.jai - -arm64 -cross_compiler_sysroot /home/.../Apps/cross-pi-gcc-14.2.0-64
+//
+
+
+
+PF_UNSPEC :: 0;
+PF_LOCAL :: 1;
+PF_UNIX :: PF_LOCAL;
+PF_FILE :: PF_LOCAL;
+PF_INET :: 2;
+PF_AX25 :: 3;
+PF_IPX :: 4;
+PF_APPLETALK :: 5;
+PF_NETROM :: 6;
+PF_BRIDGE :: 7;
+PF_ATMPVC :: 8;
+PF_X25 :: 9;
+PF_INET6 :: 10;
+PF_ROSE :: 11;
+PF_DECnet :: 12;
+PF_NETBEUI :: 13;
+PF_SECURITY :: 14;
+PF_KEY :: 15;
+PF_NETLINK :: 16;
+PF_ROUTE :: PF_NETLINK;
+PF_PACKET :: 17;
+PF_ASH :: 18;
+PF_ECONET :: 19;
+PF_ATMSVC :: 20;
+PF_RDS :: 21;
+PF_SNA :: 22;
+PF_IRDA :: 23;
+PF_PPPOX :: 24;
+PF_WANPIPE :: 25;
+PF_LLC :: 26;
+PF_IB :: 27;
+PF_MPLS :: 28;
+PF_CAN :: 29;
+PF_TIPC :: 30;
+PF_BLUETOOTH :: 31;
+PF_IUCV :: 32;
+PF_RXRPC :: 33;
+PF_ISDN :: 34;
+PF_PHONET :: 35;
+PF_IEEE802154 :: 36;
+PF_CAIF :: 37;
+PF_ALG :: 38;
+PF_NFC :: 39;
+PF_VSOCK :: 40;
+PF_KCM :: 41;
+PF_QIPCRTR :: 42;
+PF_SMC :: 43;
+PF_XDP :: 44;
+PF_MCTP :: 45;
+PF_MAX :: 46;
+
+AF_UNSPEC :: PF_UNSPEC;
+AF_LOCAL :: PF_LOCAL;
+AF_UNIX :: PF_UNIX;
+AF_FILE :: PF_FILE;
+AF_INET :: PF_INET;
+AF_AX25 :: PF_AX25;
+AF_IPX :: PF_IPX;
+AF_APPLETALK :: PF_APPLETALK;
+AF_NETROM :: PF_NETROM;
+AF_BRIDGE :: PF_BRIDGE;
+AF_ATMPVC :: PF_ATMPVC;
+AF_X25 :: PF_X25;
+AF_INET6 :: PF_INET6;
+AF_ROSE :: PF_ROSE;
+AF_DECnet :: PF_DECnet;
+AF_NETBEUI :: PF_NETBEUI;
+AF_SECURITY :: PF_SECURITY;
+AF_KEY :: PF_KEY;
+AF_NETLINK :: PF_NETLINK;
+AF_ROUTE :: PF_ROUTE;
+AF_PACKET :: PF_PACKET;
+AF_ASH :: PF_ASH;
+AF_ECONET :: PF_ECONET;
+AF_ATMSVC :: PF_ATMSVC;
+AF_RDS :: PF_RDS;
+AF_SNA :: PF_SNA;
+AF_IRDA :: PF_IRDA;
+AF_PPPOX :: PF_PPPOX;
+AF_WANPIPE :: PF_WANPIPE;
+AF_LLC :: PF_LLC;
+AF_IB :: PF_IB;
+AF_MPLS :: PF_MPLS;
+AF_CAN :: PF_CAN;
+AF_TIPC :: PF_TIPC;
+AF_BLUETOOTH :: PF_BLUETOOTH;
+AF_IUCV :: PF_IUCV;
+AF_RXRPC :: PF_RXRPC;
+AF_ISDN :: PF_ISDN;
+AF_PHONET :: PF_PHONET;
+AF_IEEE802154 :: PF_IEEE802154;
+AF_CAIF :: PF_CAIF;
+AF_ALG :: PF_ALG;
+AF_NFC :: PF_NFC;
+AF_VSOCK :: PF_VSOCK;
+AF_KCM :: PF_KCM;
+AF_QIPCRTR :: PF_QIPCRTR;
+AF_SMC :: PF_SMC;
+AF_XDP :: PF_XDP;
+AF_MCTP :: PF_MCTP;
+AF_MAX :: PF_MAX;
+
+SOL_RAW :: 255;
+SOL_DECNET :: 261;
+SOL_X25 :: 262;
+SOL_PACKET :: 263;
+SOL_ATM :: 264;
+SOL_AAL :: 265;
+SOL_IRDA :: 266;
+SOL_NETBEUI :: 267;
+SOL_LLC :: 268;
+SOL_DCCP :: 269;
+SOL_NETLINK :: 270;
+SOL_TIPC :: 271;
+SOL_RXRPC :: 272;
+SOL_PPPOL2TP :: 273;
+SOL_BLUETOOTH :: 274;
+SOL_PNPIPE :: 275;
+SOL_RDS :: 276;
+SOL_IUCV :: 277;
+SOL_CAIF :: 278;
+SOL_ALG :: 279;
+SOL_NFC :: 280;
+SOL_KCM :: 281;
+SOL_TLS :: 282;
+SOL_XDP :: 283;
+SOL_MPTCP :: 284;
+SOL_MCTP :: 285;
+SOL_SMC :: 286;
+
+SOMAXCONN :: 4096;
+
+SOL_SOCKET :: 1;
+
+SO_DEBUG :: 1;
+SO_REUSEADDR :: 2;
+SO_TYPE :: 3;
+SO_ERROR :: 4;
+SO_DONTROUTE :: 5;
+SO_BROADCAST :: 6;
+SO_SNDBUF :: 7;
+SO_RCVBUF :: 8;
+SO_SNDBUFFORCE :: 32;
+SO_RCVBUFFORCE :: 33;
+SO_KEEPALIVE :: 9;
+SO_OOBINLINE :: 10;
+SO_NO_CHECK :: 11;
+SO_PRIORITY :: 12;
+SO_LINGER :: 13;
+SO_BSDCOMPAT :: 14;
+SO_REUSEPORT :: 15;
+
+SO_PASSCRED :: 16;
+SO_PEERCRED :: 17;
+SO_RCVLOWAT :: 18;
+SO_SNDLOWAT :: 19;
+SO_RCVTIMEO_OLD :: 20;
+SO_SNDTIMEO_OLD :: 21;
+
+SO_SECURITY_AUTHENTICATION :: 22;
+SO_SECURITY_ENCRYPTION_TRANSPORT :: 23;
+SO_SECURITY_ENCRYPTION_NETWORK :: 24;
+
+SO_BINDTODEVICE :: 25;
+
+SO_ATTACH_FILTER :: 26;
+SO_DETACH_FILTER :: 27;
+SO_GET_FILTER :: SO_ATTACH_FILTER;
+
+SO_PEERNAME :: 28;
+
+SO_ACCEPTCONN :: 30;
+
+SO_PEERSEC :: 31;
+SO_PASSSEC :: 34;
+
+SO_MARK :: 36;
+
+SO_PROTOCOL :: 38;
+SO_DOMAIN :: 39;
+
+SO_RXQ_OVFL :: 40;
+
+SO_WIFI_STATUS :: 41;
+
+SO_PEEK_OFF :: 42;
+
+SO_NOFCS :: 43;
+
+SO_LOCK_FILTER :: 44;
+
+SO_SELECT_ERR_QUEUE :: 45;
+
+SO_BUSY_POLL :: 46;
+
+SO_MAX_PACING_RATE :: 47;
+
+SO_BPF_EXTENSIONS :: 48;
+
+SO_INCOMING_CPU :: 49;
+
+SO_ATTACH_BPF :: 50;
+SO_DETACH_BPF :: SO_DETACH_FILTER;
+
+SO_ATTACH_REUSEPORT_CBPF :: 51;
+SO_ATTACH_REUSEPORT_EBPF :: 52;
+
+SO_CNX_ADVICE :: 53;
+
+SO_MEMINFO :: 55;
+
+SO_INCOMING_NAPI_ID :: 56;
+
+SO_COOKIE :: 57;
+
+SO_PEERGROUPS :: 59;
+
+SO_ZEROCOPY :: 60;
+
+SO_TXTIME :: 61;
+
+SO_BINDTOIFINDEX :: 62;
+
+SO_TIMESTAMP_OLD :: 29;
+SO_TIMESTAMPNS_OLD :: 35;
+SO_TIMESTAMPING_OLD :: 37;
+
+SO_TIMESTAMP_NEW :: 63;
+SO_TIMESTAMPNS_NEW :: 64;
+SO_TIMESTAMPING_NEW :: 65;
+
+SO_RCVTIMEO_NEW :: 66;
+SO_SNDTIMEO_NEW :: 67;
+
+SO_DETACH_REUSEPORT_BPF :: 68;
+
+SO_PREFER_BUSY_POLL :: 69;
+SO_BUSY_POLL_BUDGET :: 70;
+
+SO_NETNS_COOKIE :: 71;
+
+SO_BUF_LOCK :: 72;
+
+SO_RESERVE_MEM :: 73;
+
+SO_TXREHASH :: 74;
+
+SO_RCVMARK :: 75;
+
+SO_PASSPIDFD :: 76;
+SO_PEERPIDFD :: 77;
+
+SO_TIMESTAMP :: SO_TIMESTAMP_OLD;
+SO_TIMESTAMPNS :: SO_TIMESTAMPNS_OLD;
+SO_TIMESTAMPING :: SO_TIMESTAMPING_OLD;
+
+SO_RCVTIMEO :: SO_RCVTIMEO_OLD;
+SO_SNDTIMEO :: SO_SNDTIMEO_OLD;
+
+__USE_KERNEL_IPV6_DEFS :: 0;
+
+IP_OPTIONS :: 4;
+IP_HDRINCL :: 3;
+IP_TOS :: 1;
+IP_TTL :: 2;
+IP_RECVOPTS :: 6;
+
+IP_RECVRETOPTS :: IP_RETOPTS;
+IP_RETOPTS :: 7;
+IP_MULTICAST_IF :: 32;
+IP_MULTICAST_TTL :: 33;
+IP_MULTICAST_LOOP :: 34;
+IP_ADD_MEMBERSHIP :: 35;
+IP_DROP_MEMBERSHIP :: 36;
+IP_UNBLOCK_SOURCE :: 37;
+IP_BLOCK_SOURCE :: 38;
+IP_ADD_SOURCE_MEMBERSHIP :: 39;
+IP_DROP_SOURCE_MEMBERSHIP :: 40;
+IP_MSFILTER :: 41;
+
+MCAST_JOIN_GROUP :: 42;
+MCAST_BLOCK_SOURCE :: 43;
+MCAST_UNBLOCK_SOURCE :: 44;
+MCAST_LEAVE_GROUP :: 45;
+MCAST_JOIN_SOURCE_GROUP :: 46;
+MCAST_LEAVE_SOURCE_GROUP :: 47;
+MCAST_MSFILTER :: 48;
+IP_MULTICAST_ALL :: 49;
+IP_UNICAST_IF :: 50;
+
+MCAST_EXCLUDE :: 0;
+MCAST_INCLUDE :: 1;
+
+IP_ROUTER_ALERT :: 5;
+IP_PKTINFO :: 8;
+IP_PKTOPTIONS :: 9;
+IP_PMTUDISC :: 10;
+IP_MTU_DISCOVER :: 10;
+IP_RECVERR :: 11;
+IP_RECVTTL :: 12;
+IP_RECVTOS :: 13;
+IP_MTU :: 14;
+IP_FREEBIND :: 15;
+IP_IPSEC_POLICY :: 16;
+IP_XFRM_POLICY :: 17;
+IP_PASSSEC :: 18;
+IP_TRANSPARENT :: 19;
+
+IP_ORIGDSTADDR :: 20;
+IP_RECVORIGDSTADDR :: IP_ORIGDSTADDR;
+
+IP_MINTTL :: 21;
+IP_NODEFRAG :: 22;
+IP_CHECKSUM :: 23;
+IP_BIND_ADDRESS_NO_PORT :: 24;
+IP_RECVFRAGSIZE :: 25;
+IP_RECVERR_RFC4884 :: 26;
+
+IP_PMTUDISC_DONT :: 0;
+IP_PMTUDISC_WANT :: 1;
+IP_PMTUDISC_DO :: 2;
+IP_PMTUDISC_PROBE :: 3;
+
+IP_PMTUDISC_INTERFACE :: 4;
+
+IP_PMTUDISC_OMIT :: 5;
+
+SOL_IP :: 0;
+
+IP_DEFAULT_MULTICAST_TTL :: 1;
+IP_DEFAULT_MULTICAST_LOOP :: 1;
+IP_MAX_MEMBERSHIPS :: 20;
+
+IPV6_ADDRFORM :: 1;
+IPV6_2292PKTINFO :: 2;
+IPV6_2292HOPOPTS :: 3;
+IPV6_2292DSTOPTS :: 4;
+IPV6_2292RTHDR :: 5;
+IPV6_2292PKTOPTIONS :: 6;
+IPV6_CHECKSUM :: 7;
+IPV6_2292HOPLIMIT :: 8;
+
+IPV6_NEXTHOP :: 9;
+IPV6_AUTHHDR :: 10;
+IPV6_UNICAST_HOPS :: 16;
+IPV6_MULTICAST_IF :: 17;
+IPV6_MULTICAST_HOPS :: 18;
+IPV6_MULTICAST_LOOP :: 19;
+IPV6_JOIN_GROUP :: 20;
+IPV6_LEAVE_GROUP :: 21;
+IPV6_ROUTER_ALERT :: 22;
+IPV6_MTU_DISCOVER :: 23;
+IPV6_MTU :: 24;
+IPV6_RECVERR :: 25;
+IPV6_V6ONLY :: 26;
+IPV6_JOIN_ANYCAST :: 27;
+IPV6_LEAVE_ANYCAST :: 28;
+IPV6_MULTICAST_ALL :: 29;
+IPV6_ROUTER_ALERT_ISOLATE :: 30;
+IPV6_RECVERR_RFC4884 :: 31;
+IPV6_IPSEC_POLICY :: 34;
+IPV6_XFRM_POLICY :: 35;
+IPV6_HDRINCL :: 36;
+
+IPV6_RECVPKTINFO :: 49;
+IPV6_PKTINFO :: 50;
+IPV6_RECVHOPLIMIT :: 51;
+IPV6_HOPLIMIT :: 52;
+IPV6_RECVHOPOPTS :: 53;
+IPV6_HOPOPTS :: 54;
+IPV6_RTHDRDSTOPTS :: 55;
+IPV6_RECVRTHDR :: 56;
+IPV6_RTHDR :: 57;
+IPV6_RECVDSTOPTS :: 58;
+IPV6_DSTOPTS :: 59;
+IPV6_RECVPATHMTU :: 60;
+IPV6_PATHMTU :: 61;
+IPV6_DONTFRAG :: 62;
+
+IPV6_RECVTCLASS :: 66;
+IPV6_TCLASS :: 67;
+
+IPV6_AUTOFLOWLABEL :: 70;
+
+IPV6_ADDR_PREFERENCES :: 72;
+
+IPV6_MINHOPCOUNT :: 73;
+
+IPV6_ORIGDSTADDR :: 74;
+IPV6_RECVORIGDSTADDR :: IPV6_ORIGDSTADDR;
+IPV6_TRANSPARENT :: 75;
+IPV6_UNICAST_IF :: 76;
+IPV6_RECVFRAGSIZE :: 77;
+IPV6_FREEBIND :: 78;
+
+IPV6_ADD_MEMBERSHIP :: IPV6_JOIN_GROUP;
+IPV6_DROP_MEMBERSHIP :: IPV6_LEAVE_GROUP;
+
+IPV6_RXHOPOPTS :: IPV6_HOPOPTS;
+IPV6_RXDSTOPTS :: IPV6_DSTOPTS;
+
+IPV6_PMTUDISC_DONT :: 0;
+IPV6_PMTUDISC_WANT :: 1;
+IPV6_PMTUDISC_DO :: 2;
+IPV6_PMTUDISC_PROBE :: 3;
+IPV6_PMTUDISC_INTERFACE :: 4;
+IPV6_PMTUDISC_OMIT :: 5;
+
+SOL_IPV6 :: 41;
+SOL_ICMPV6 :: 58;
+
+IPV6_RTHDR_LOOSE :: 0;
+IPV6_RTHDR_STRICT :: 1;
+
+IPV6_RTHDR_TYPE_0 :: 0;
+
+IN_CLASSA_NET :: 0xff000000;
+IN_CLASSA_NSHIFT :: 24;
+IN_CLASSA_HOST :: 0xffffffff & ~IN_CLASSA_NET;
+IN_CLASSA_MAX :: 128;
+
+IN_CLASSB_NET :: 0xffff0000;
+IN_CLASSB_NSHIFT :: 16;
+IN_CLASSB_HOST :: 0xffffffff & ~IN_CLASSB_NET;
+IN_CLASSB_MAX :: 65536;
+
+IN_CLASSC_NET :: 0xffffff00;
+IN_CLASSC_NSHIFT :: 8;
+IN_CLASSC_HOST :: 0xffffffff & ~IN_CLASSC_NET;
+
+INADDR_ANY :: cast(in_addr_t) 0x00000000;
+
+INADDR_BROADCAST :: cast(in_addr_t) 0xffffffff;
+
+INADDR_NONE :: cast(in_addr_t) 0xffffffff;
+
+INADDR_DUMMY :: cast(in_addr_t) 0xc0000008;
+
+IN_LOOPBACKNET :: 127;
+
+INADDR_LOOPBACK :: cast(in_addr_t) 0x7f000001;
+
+INADDR_UNSPEC_GROUP :: cast(in_addr_t) 0xe0000000;
+INADDR_ALLHOSTS_GROUP :: cast(in_addr_t) 0xe0000001;
+INADDR_ALLRTRS_GROUP :: cast(in_addr_t) 0xe0000002;
+INADDR_ALLSNOOPERS_GROUP :: cast(in_addr_t) 0xe000006a;
+INADDR_MAX_LOCAL_GROUP :: cast(in_addr_t) 0xe00000ff;
+
+INET_ADDRSTRLEN :: 16;
+INET6_ADDRSTRLEN :: 46;
+
+TCP_NODELAY :: 1;
+TCP_MAXSEG :: 2;
+TCP_CORK :: 3;
+TCP_KEEPIDLE :: 4;
+TCP_KEEPINTVL :: 5;
+TCP_KEEPCNT :: 6;
+TCP_SYNCNT :: 7;
+TCP_LINGER2 :: 8;
+TCP_DEFER_ACCEPT :: 9;
+TCP_WINDOW_CLAMP :: 10;
+TCP_INFO :: 11;
+TCP_QUICKACK :: 12;
+TCP_CONGESTION :: 13;
+TCP_MD5SIG :: 14;
+TCP_COOKIE_TRANSACTIONS :: 15;
+TCP_THIN_LINEAR_TIMEOUTS :: 16;
+TCP_THIN_DUPACK :: 17;
+TCP_USER_TIMEOUT :: 18;
+TCP_REPAIR :: 19;
+TCP_REPAIR_QUEUE :: 20;
+TCP_QUEUE_SEQ :: 21;
+TCP_REPAIR_OPTIONS :: 22;
+TCP_FASTOPEN :: 23;
+TCP_TIMESTAMP :: 24;
+TCP_NOTSENT_LOWAT :: 25;
+
+TCP_CC_INFO :: 26;
+
+TCP_SAVE_SYN :: 27;
+
+TCP_SAVED_SYN :: 28;
+
+TCP_REPAIR_WINDOW :: 29;
+TCP_FASTOPEN_CONNECT :: 30;
+TCP_ULP :: 31;
+TCP_MD5SIG_EXT :: 32;
+TCP_FASTOPEN_KEY :: 33;
+TCP_FASTOPEN_NO_COOKIE :: 34;
+TCP_ZEROCOPY_RECEIVE :: 35;
+TCP_INQ :: 36;
+
+TCP_CM_INQ :: TCP_INQ;
+TCP_TX_DELAY :: 37;
+
+TCP_REPAIR_ON :: 1;
+TCP_REPAIR_OFF :: 0;
+TCP_REPAIR_OFF_NO_WP :: -1;
+
+TH_FIN :: 0x01;
+TH_SYN :: 0x02;
+TH_RST :: 0x04;
+TH_PUSH :: 0x08;
+TH_ACK :: 0x10;
+TH_URG :: 0x20;
+
+TCPOPT_EOL :: 0;
+TCPOPT_NOP :: 1;
+TCPOPT_MAXSEG :: 2;
+TCPOLEN_MAXSEG :: 4;
+TCPOPT_WINDOW :: 3;
+TCPOLEN_WINDOW :: 3;
+TCPOPT_SACK_PERMITTED :: 4;
+TCPOLEN_SACK_PERMITTED :: 2;
+TCPOPT_SACK :: 5;
+TCPOPT_TIMESTAMP :: 8;
+TCPOLEN_TIMESTAMP :: 10;
+TCPOLEN_TSTAMP_APPA :: TCPOLEN_TIMESTAMP+2;
+
+TCPOPT_TSTAMP_HDR :: TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP;
+
+TCP_MSS :: 512;
+
+TCP_MAXWIN :: 65535;
+
+TCP_MAX_WINSHIFT :: 14;
+
+SOL_TCP :: 6;
+
+TCPI_OPT_TIMESTAMPS :: 1;
+TCPI_OPT_SACK :: 2;
+TCPI_OPT_WSCALE :: 4;
+TCPI_OPT_ECN :: 8;
+TCPI_OPT_ECN_SEEN :: 16;
+TCPI_OPT_SYN_DATA :: 32;
+
+TCP_MD5SIG_MAXKEYLEN :: 80;
+
+TCP_MD5SIG_FLAG_PREFIX :: 1;
+
+TCP_COOKIE_MIN :: 8;
+TCP_COOKIE_MAX :: 16;
+TCP_COOKIE_PAIR_SIZE :: 2*TCP_COOKIE_MAX;
+
+TCP_COOKIE_IN_ALWAYS :: 1 << 0;
+TCP_COOKIE_OUT_NEVER :: 1 << 1;
+
+TCP_S_DATA_IN :: 1 << 2;
+TCP_S_DATA_OUT :: 1 << 3;
+
+TCP_MSS_DEFAULT :: 536;
+TCP_MSS_DESIRED :: 1220;
+
+_PATH_HEQUIV :: "/etc/hosts.equiv";
+_PATH_HOSTS :: "/etc/hosts";
+_PATH_NETWORKS :: "/etc/networks";
+_PATH_NSSWITCH_CONF :: "/etc/nsswitch.conf";
+_PATH_PROTOCOLS :: "/etc/protocols";
+_PATH_SERVICES :: "/etc/services";
+
+HOST_NOT_FOUND :: 1;
+TRY_AGAIN :: 2;
+
+NO_RECOVERY :: 3;
+
+NO_DATA :: 4;
+
+NETDB_INTERNAL :: -1;
+NETDB_SUCCESS :: 0;
+NO_ADDRESS :: NO_DATA;
+
+IPPORT_RESERVED :: 1024;
+
+GAI_WAIT :: 0;
+GAI_NOWAIT :: 1;
+
+AI :: enum_flags u32 {
+    PASSIVE     :: 0x0001;
+    CANONNAME   :: 0x0002;
+    NUMERICHOST :: 0x0004;
+    V4MAPPED    :: 0x0008;
+    ALL         :: 0x0010;
+    ADDRCONFIG  :: 0x0020;
+    IDN         :: 0x0040;
+    CANONIDN    :: 0x0080;
+    NUMERICSERV :: 0x0400;
+
+    AI_PASSIVE     :: PASSIVE;
+    AI_CANONNAME   :: CANONNAME;
+    AI_NUMERICHOST :: NUMERICHOST;
+    AI_V4MAPPED    :: V4MAPPED;
+    AI_ALL         :: ALL;
+    AI_ADDRCONFIG  :: ADDRCONFIG;
+    AI_IDN         :: IDN;
+    AI_CANONIDN    :: CANONIDN;
+    AI_NUMERICSERV :: NUMERICSERV;
+}
+
+EAI_BADFLAGS :: -1;
+EAI_NONAME :: -2;
+EAI_AGAIN :: -3;
+EAI_FAIL :: -4;
+EAI_FAMILY :: -6;
+EAI_SOCKTYPE :: -7;
+EAI_SERVICE :: -8;
+EAI_MEMORY :: -10;
+EAI_SYSTEM :: -11;
+EAI_OVERFLOW :: -12;
+
+EAI_NODATA :: -5;
+EAI_ADDRFAMILY :: -9;
+EAI_INPROGRESS :: -100;
+EAI_CANCELED :: -101;
+EAI_NOTCANCELED :: -102;
+EAI_ALLDONE :: -103;
+EAI_INTR :: -104;
+EAI_IDN_ENCODE :: -105;
+
+NI_MAXHOST :: 1025;
+NI_MAXSERV :: 32;
+
+NI_NUMERICHOST :: 1;
+NI_NUMERICSERV :: 2;
+NI_NOFQDN :: 4;
+NI_NAMEREQD :: 8;
+NI_DGRAM :: 16;
+
+NI_IDN :: 32;
+
+IF_NAMESIZE :: 16;
+
+IFHWADDRLEN :: 6;
+IFNAMSIZ :: IF_NAMESIZE;
+
+__fd_mask :: s64;
+
+fd_set :: struct {
+    fds_bits: [16] __fd_mask;
+}
+
+fd_mask :: __fd_mask;
+
+select :: (__nfds: s32, __readfds: *fd_set, __writefds: *fd_set, __exceptfds: *fd_set, __timeout: *timeval) -> s32 #foreign libc;
+
+pselect :: (__nfds: s32, __readfds: *fd_set, __writefds: *fd_set, __exceptfds: *fd_set, __timeout: *timespec, __sigmask: *__sigset_t) -> s32 #foreign libc;
+
+socklen_t :: u32;
+
+SOCK :: enum u32 {
+    STREAM    :: 1;
+    DGRAM     :: 2;
+    RAW       :: 3;
+    RDM       :: 4;
+    SEQPACKET :: 5;
+    DCCP      :: 6;
+    PACKET    :: 10;
+    CLOEXEC   :: 524288;
+    NONBLOCK  :: 2048;
+
+    SOCK_STREAM    :: STREAM;
+    SOCK_DGRAM     :: DGRAM;
+    SOCK_RAW       :: RAW;
+    SOCK_RDM       :: RDM;
+    SOCK_SEQPACKET :: SEQPACKET;
+    SOCK_DCCP      :: DCCP;
+    SOCK_PACKET    :: PACKET;
+    SOCK_CLOEXEC   :: CLOEXEC;
+    SOCK_NONBLOCK  :: NONBLOCK;
+}
+
+sa_family_t :: u16;
+
+sockaddr :: struct {
+    sa_family: sa_family_t;
+    sa_data:   [14] u8;
+}
+
+sockaddr_storage :: struct {
+    ss_family:    sa_family_t;
+    __ss_padding: [118] u8;
+    __ss_align:   u64;
+}
+
+MSG :: enum_flags s32 {
+    OOB          :: 0x1;
+
+    PEEK         :: 0x2;
+
+    DONTROUTE    :: 0x4;
+
+    TRYHARD      :: 0x4;
+
+    CTRUNC       :: 0x8;
+
+    PROXY        :: 0x10;
+
+    TRUNC        :: 0x20;
+
+    DONTWAIT     :: 0x40;
+
+    EOR          :: 0x80;
+
+    WAITALL      :: 0x100;
+
+    FIN          :: 0x200;
+
+    SYN          :: 0x400;
+
+    CONFIRM      :: 0x800;
+
+    RST          :: 0x1000;
+
+    ERRQUEUE     :: 0x2000;
+
+    NOSIGNAL     :: 0x4000;
+
+    MORE         :: 0x8000;
+
+    WAITFORONE   :: 0x10000;
+
+    BATCH        :: 0x40000;
+
+    ZEROCOPY     :: 0x4000000;
+
+    FASTOPEN     :: 0x20000000;
+
+    CMSG_CLOEXEC :: 0x40000000;
+
+    MSG_OOB          :: OOB;
+
+    MSG_PEEK         :: PEEK;
+
+    MSG_DONTROUTE    :: DONTROUTE;
+
+    MSG_TRYHARD      :: TRYHARD;
+
+    MSG_CTRUNC       :: CTRUNC;
+
+    MSG_PROXY        :: PROXY;
+
+    MSG_TRUNC        :: TRUNC;
+
+    MSG_DONTWAIT     :: DONTWAIT;
+
+    MSG_EOR          :: EOR;
+
+    MSG_WAITALL      :: WAITALL;
+
+    MSG_FIN          :: FIN;
+
+    MSG_SYN          :: SYN;
+
+    MSG_CONFIRM      :: CONFIRM;
+
+    MSG_RST          :: RST;
+
+    MSG_ERRQUEUE     :: ERRQUEUE;
+
+    MSG_NOSIGNAL     :: NOSIGNAL;
+
+    MSG_MORE         :: MORE;
+
+    MSG_WAITFORONE   :: WAITFORONE;
+
+    MSG_BATCH        :: BATCH;
+
+    MSG_ZEROCOPY     :: ZEROCOPY;
+
+    MSG_FASTOPEN     :: FASTOPEN;
+
+    MSG_CMSG_CLOEXEC :: CMSG_CLOEXEC;
+}
+
+msghdr :: struct {
+    msg_name:       *void;
+    msg_namelen:    socklen_t;
+
+    msg_iov:        *iovec;
+    msg_iovlen:     u64;
+
+    msg_control:    *void;
+    msg_controllen: u64;
+
+    msg_flags:      s32;
+}
+
+cmsghdr :: struct {
+    cmsg_len:    u64;
+
+    cmsg_level:  s32;
+    cmsg_type:   s32;
+
+//     __cmsg_data: *u8;// Incomplete array in C (zero-sized)
+}
+
+__cmsg_nxthdr :: (__mhdr: *msghdr, __cmsg: *cmsghdr) -> *cmsghdr #foreign libc;
+
+SCM :: enum u32 {
+    RIGHTS                     :: 1;
+
+    CREDENTIALS                :: 2;
+
+    SCM_WIFI_STATUS            :: SO_WIFI_STATUS;
+
+    SCM_TIMESTAMPING_OPT_STATS :: 54;
+
+    SCM_TIMESTAMPING_PKTINFO   :: 58;
+
+    SCM_TXTIME                 :: SO_TXTIME;
+
+    SCM_TIMESTAMP              :: SO_TIMESTAMP;
+    SCM_TIMESTAMPNS            :: SO_TIMESTAMPNS;
+    SCM_TIMESTAMPING           :: SO_TIMESTAMPING;
+
+    SCM_RIGHTS      :: RIGHTS;
+
+    SCM_CREDENTIALS :: CREDENTIALS;
+}
+
+ucred :: struct {
+    pid: pid_t;
+    uid: uid_t;
+    gid: gid_t;
+}
+
+linger :: struct {
+    l_onoff:  s32;
+    l_linger: s32;
+}
+
+/* The following constants should be used for the second parameter of
+`shutdown'.  */
+SHUT :: enum u32 {
+    RD   :: 0;
+
+    WR   :: 1;
+
+    RDWR :: 2;
+
+    SHUT_RD   :: RD;
+
+    SHUT_WR   :: WR;
+
+    SHUT_RDWR :: RDWR;
+}
+
+/* For `recvmmsg' and `sendmmsg'.  */
+mmsghdr :: struct {
+    msg_hdr: msghdr; /* Actual message header.  */
+    /* Number of received or sent bytes for the
+    entry.  */
+    msg_len: u32;
+}
+
+/* Create a new socket of type TYPE in domain DOMAIN, using
+protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
+Returns a file descriptor for the new socket, or -1 for errors.  */
+socket :: (__domain: s32, __type: SOCK, __protocol: IPPROTO) -> s32 #foreign libc;
+
+/* Create two new sockets, of type TYPE in domain DOMAIN and using
+protocol PROTOCOL, which are connected to each other, and put file
+descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
+one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
+socketpair :: (__domain: s32, __type: SOCK, __protocol: IPPROTO, __fds: *[2] s32) -> s32 #foreign libc;
+
+/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
+bind :: (__fd: s32, __addr: *sockaddr, __len: socklen_t) -> s32 #foreign libc;
+
+/* Put the local address of FD into *ADDR and its length in *LEN.  */
+getsockname :: (__fd: s32, __addr: *sockaddr, __len: *socklen_t) -> s32 #foreign libc;
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+For connectionless socket types, just set the default address to send to
+and the only address from which to accept transmissions.
+Return 0 on success, -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+connect :: (__fd: s32, __addr: *sockaddr, __len: socklen_t) -> s32 #foreign libc;
+
+/* Put the address of the peer connected to socket FD into *ADDR
+(which is *LEN bytes long), and its actual length into *LEN.  */
+getpeername :: (__fd: s32, __addr: *sockaddr, __len: *socklen_t) -> s32 #foreign libc;
+
+/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+send :: (__fd: s32, __buf: *void, __n: u64, __flags: MSG) -> s64 #foreign libc;
+
+/* Read N bytes into BUF from socket FD.
+Returns the number read or -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+recv :: (__fd: s32, __buf: *void, __n: u64, __flags: MSG) -> s64 #foreign libc;
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+sendto :: (__fd: s32, __buf: *void, __n: u64, __flags: MSG, __addr: *sockaddr, __addr_len: socklen_t) -> s64 #foreign libc;
+
+/* Read N bytes into BUF through socket FD.
+If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
+the sender, and store the actual size of the address in *ADDR_LEN.
+Returns the number of bytes read or -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+recvfrom :: (__fd: s32, __buf: *void, __n: u64, __flags: MSG, __addr: *sockaddr, __addr_len: *socklen_t) -> s64 #foreign libc;
+
+sendmsg :: (__fd: s32, __message: *msghdr, __flags: MSG) -> s64 #foreign libc;
+
+sendmmsg :: (__fd: s32, __vmessages: *mmsghdr, __vlen: u32, __flags: MSG) -> s32 #foreign libc;
+
+recvmsg :: (__fd: s32, __message: *msghdr, __flags: MSG) -> s64 #foreign libc;
+
+recvmmsg :: (__fd: s32, __vmessages: *mmsghdr, __vlen: u32, __flags: MSG, __tmo: *timespec) -> s32 #foreign libc;
+
+getsockopt :: (__fd: s32, __level: s32, __optname: s32, __optval: *void, __optlen: *socklen_t) -> s32 #foreign libc;
+
+setsockopt :: (__fd: s32, __level: s32, __optname: s32, __optval: *void, __optlen: socklen_t) -> s32 #foreign libc;
+
+/* Prepare to accept connections on socket FD.
+N connection requests will be queued before further requests are refused.
+Returns 0 on success, -1 for errors.  */
+listen :: (__fd: s32, __n: s32) -> s32 #foreign libc;
+
+/* Await a connection on socket FD.
+When a connection arrives, open a new socket to communicate with it,
+set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
+peer and *ADDR_LEN to the address's actual length, and return the
+new socket's descriptor, or -1 for errors.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+accept :: (__fd: s32, __addr: *sockaddr, __addr_len: *socklen_t) -> s32 #foreign libc;
+
+/* Similar to 'accept' but takes an additional parameter to specify flags.
+
+This function is a cancellation point and therefore not marked with
+__THROW.  */
+accept4 :: (__fd: s32, __addr: *sockaddr, __addr_len: *socklen_t, __flags: SOCK) -> s32 #foreign libc;
+
+/* Shut down all or part of the connection open on socket FD.
+HOW determines what to shut down:
+SHUT_RD   = No more receptions;
+SHUT_WR   = No more transmissions;
+SHUT_RDWR = No more receptions or transmissions.
+Returns 0 on success, -1 for errors.  */
+shutdown :: (__fd: s32, __how: SHUT) -> s32 #foreign libc;
+
+/* Determine whether socket is at a out-of-band mark.  */
+sockatmark :: (__fd: s32) -> s32 #foreign libc;
+
+/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
+returns 1 if FD is open on an object of the indicated type, 0 if not,
+or -1 for errors (setting errno).  */
+isfdtype :: (__fd: s32, __fdtype: s32) -> s32 #foreign libc;
+
+/* Internet address.  */
+in_addr_t :: u32;
+in_addr :: struct {
+    s_addr: in_addr_t;
+}
+
+ip_opts :: struct {
+    ip_dst:  in_addr;
+    ip_opts: [40] u8;
+}
+
+ip_mreqn :: struct {
+    imr_multiaddr: in_addr;
+    imr_address:   in_addr;
+    imr_ifindex:   s32;
+}
+
+in_pktinfo :: struct {
+    ipi_ifindex:  s32;
+    ipi_spec_dst: in_addr;
+    ipi_addr:     in_addr;
+}
+
+/* Standard well-defined IP protocols.  */
+IPPROTO :: enum u32 {
+    IP       :: 0;
+    ICMP     :: 1;
+    IGMP     :: 2;
+    IPIP     :: 4;
+    TCP      :: 6;
+    EGP      :: 8;
+    PUP      :: 12;
+    UDP      :: 17;
+    IDP      :: 22;
+    TP       :: 29;
+    DCCP     :: 33;
+    IPV6     :: 41;
+    RSVP     :: 46;
+    GRE      :: 47;
+    ESP      :: 50;
+    AH       :: 51;
+    MTP      :: 92;
+    BEETPH   :: 94;
+    ENCAP    :: 98;
+    PIM      :: 103;
+    COMP     :: 108;
+    SCTP     :: 132;
+    UDPLITE  :: 136;
+    MPLS     :: 137;
+    ETHERNET :: 143;
+    RAW      :: 255;
+    MPTCP    :: 262;
+    MAX      :: 263;
+
+    IPPROTO_IP       :: IP;
+    IPPROTO_ICMP     :: ICMP;
+    IPPROTO_IGMP     :: IGMP;
+    IPPROTO_IPIP     :: IPIP;
+    IPPROTO_TCP      :: TCP;
+    IPPROTO_EGP      :: EGP;
+    IPPROTO_PUP      :: PUP;
+    IPPROTO_UDP      :: UDP;
+    IPPROTO_IDP      :: IDP;
+    IPPROTO_TP       :: TP;
+    IPPROTO_DCCP     :: DCCP;
+    IPPROTO_IPV6     :: IPV6;
+    IPPROTO_RSVP     :: RSVP;
+    IPPROTO_GRE      :: GRE;
+    IPPROTO_ESP      :: ESP;
+    IPPROTO_AH       :: AH;
+    IPPROTO_MTP      :: MTP;
+    IPPROTO_BEETPH   :: BEETPH;
+    IPPROTO_ENCAP    :: ENCAP;
+    IPPROTO_PIM      :: PIM;
+    IPPROTO_COMP     :: COMP;
+    IPPROTO_SCTP     :: SCTP;
+    IPPROTO_UDPLITE  :: UDPLITE;
+    IPPROTO_MPLS     :: MPLS;
+    IPPROTO_ETHERNET :: ETHERNET;
+    IPPROTO_RAW      :: RAW;
+    IPPROTO_MPTCP    :: MPTCP;
+    IPPROTO_MAX      :: MAX;
+}
+
+IPPROTO_1 :: enum u32 {
+    HOPOPTS  :: 0;
+
+    ROUTING  :: 43;
+
+    FRAGMENT :: 44;
+
+    ICMPV6   :: 58;
+
+    NONE     :: 59;
+
+    DSTOPTS  :: 60;
+
+    MH       :: 135;
+
+    IPPROTO_HOPOPTS  :: HOPOPTS;
+
+    IPPROTO_ROUTING  :: ROUTING;
+
+    IPPROTO_FRAGMENT :: FRAGMENT;
+
+    IPPROTO_ICMPV6   :: ICMPV6;
+
+    IPPROTO_NONE     :: NONE;
+
+    IPPROTO_DSTOPTS  :: DSTOPTS;
+
+    IPPROTO_MH       :: MH;
+}
+
+/* Type to represent a port.  */
+in_port_t :: u16;
+
+/* Standard well-known ports.  */
+IPPORT :: enum u32 {
+    ECHO         :: 7;
+    DISCARD      :: 9;
+    SYSTAT       :: 11;
+    DAYTIME      :: 13;
+    NETSTAT      :: 15;
+    FTP          :: 21;
+    TELNET       :: 23;
+    SMTP         :: 25;
+    TIMESERVER   :: 37;
+    NAMESERVER   :: 42;
+    WHOIS        :: 43;
+    MTP          :: 57;
+
+    TFTP         :: 69;
+    RJE          :: 77;
+    FINGER       :: 79;
+    TTYLINK      :: 87;
+    SUPDUP       :: 95;
+
+    EXECSERVER   :: 512;
+    LOGINSERVER  :: 513;
+    CMDSERVER    :: 514;
+    EFSSERVER    :: 520;
+
+    BIFFUDP      :: 512;
+    WHOSERVER    :: 513;
+    ROUTESERVER  :: 520;
+
+    RESERVED     :: 1024;
+
+    USERRESERVED :: 5000;
+
+    IPPORT_ECHO         :: ECHO;
+    IPPORT_DISCARD      :: DISCARD;
+    IPPORT_SYSTAT       :: SYSTAT;
+    IPPORT_DAYTIME      :: DAYTIME;
+    IPPORT_NETSTAT      :: NETSTAT;
+    IPPORT_FTP          :: FTP;
+    IPPORT_TELNET       :: TELNET;
+    IPPORT_SMTP         :: SMTP;
+    IPPORT_TIMESERVER   :: TIMESERVER;
+    IPPORT_NAMESERVER   :: NAMESERVER;
+    IPPORT_WHOIS        :: WHOIS;
+    IPPORT_MTP          :: MTP;
+
+    IPPORT_TFTP         :: TFTP;
+    IPPORT_RJE          :: RJE;
+    IPPORT_FINGER       :: FINGER;
+    IPPORT_TTYLINK      :: TTYLINK;
+    IPPORT_SUPDUP       :: SUPDUP;
+
+    IPPORT_EXECSERVER   :: EXECSERVER;
+    IPPORT_LOGINSERVER  :: LOGINSERVER;
+    IPPORT_CMDSERVER    :: CMDSERVER;
+    IPPORT_EFSSERVER    :: EFSSERVER;
+
+    IPPORT_BIFFUDP      :: BIFFUDP;
+    IPPORT_WHOSERVER    :: WHOSERVER;
+    IPPORT_ROUTESERVER  :: ROUTESERVER;
+
+    IPPORT_RESERVED     :: RESERVED;
+
+    IPPORT_USERRESERVED :: USERRESERVED;
+}
+
+/* IPv6 address */
+in6_addr :: struct {
+    __in6_u: union {
+        __u6_addr8:  [16] u8;
+        __u6_addr16: [8] u16;
+        __u6_addr32: [4] u32;
+    };
+}
+
+in6addr_any: in6_addr; /* :: */
+in6addr_loopback: in6_addr; /* ::1 */
+
+/* Structure describing an Internet socket address.  */
+sockaddr_in :: struct {
+    sin_family: sa_family_t;
+    sin_port:   in_port_t; /* Port number.  */
+    sin_addr:   in_addr; /* Internet address.  */
+
+    /* Pad to size of `struct sockaddr'.  */
+    sin_zero:   [8] u8;
+}
+
+/* Ditto, for IPv6.  */
+sockaddr_in6 :: struct {
+    sin6_family:   sa_family_t;
+    sin6_port:     in_port_t; /* Transport layer port # */
+    sin6_flowinfo: u32; /* IPv6 flow information */
+    sin6_addr:     in6_addr; /* IPv6 address */
+    sin6_scope_id: u32; /* IPv6 scope-id */
+}
+
+/* IPv4 multicast request.  */
+ip_mreq :: struct {
+    /* IP multicast address of group.  */
+    imr_multiaddr: in_addr;
+
+    /* Local IP address of interface.  */
+    imr_interface: in_addr;
+}
+
+ip_mreq_source :: struct {
+    /* IP multicast address of group.  */
+    imr_multiaddr:  in_addr;
+
+    /* IP address of interface.  */
+    imr_interface:  in_addr;
+
+    /* IP address of source.  */
+    imr_sourceaddr: in_addr;
+}
+
+/* Likewise, for IPv6.  */
+ipv6_mreq :: struct {
+    /* IPv6 multicast address of group */
+    ipv6mr_multiaddr: in6_addr;
+
+    /* local interface */
+    ipv6mr_interface: u32;
+}
+
+/* Multicast group request.  */
+group_req :: struct {
+    /* Interface index.  */
+    gr_interface: u32;
+
+    /* Group address.  */
+    gr_group:     sockaddr_storage;
+}
+
+group_source_req :: struct {
+    /* Interface index.  */
+    gsr_interface: u32;
+
+    /* Group address.  */
+    gsr_group:     sockaddr_storage;
+
+    /* Source address.  */
+    gsr_source:    sockaddr_storage;
+}
+
+/* Full-state filter operations.  */
+ip_msfilter :: struct {
+    /* IP multicast address of group.  */
+    imsf_multiaddr: in_addr;
+
+    /* Local IP address of interface.  */
+    imsf_interface: in_addr;
+
+    /* Filter mode.  */
+    imsf_fmode:     u32;
+
+    /* Number of source addresses.  */
+    imsf_numsrc:    u32;
+
+    /* Source addresses.  */
+    imsf_slist:     [1] in_addr;
+}
+
+group_filter :: struct {
+    /* Interface index.  */
+    gf_interface: u32;
+
+    /* Group address.  */
+    gf_group:     sockaddr_storage;
+
+    /* Filter mode.  */
+    gf_fmode:     u32;
+
+    /* Number of source addresses.  */
+    gf_numsrc:    u32;
+
+    /* Source addresses.  */
+    gf_slist:     [1] sockaddr_storage;
+}
+
+/* Functions to convert between host and network byte order.
+
+Please note that these functions normally take `unsigned long int' or
+`unsigned short int' values as arguments and also return them.  But
+this was a short-sighted decision since on different systems the types
+may have different representations but the values are always the same.  */
+ntohl :: (__netlong: u32) -> u32 #foreign libc;
+ntohs :: (__netshort: u16) -> u16 #foreign libc;
+
+htonl :: (__hostlong: u32) -> u32 #foreign libc;
+
+htons :: (__hostshort: u16) -> u16 #foreign libc;
+
+/* Bind socket to a privileged IP port.  */
+bindresvport :: (__sockfd: s32, __sock_in: *sockaddr_in) -> s32 #foreign libc;
+
+/* IPv6 packet information.  */
+in6_pktinfo :: struct {
+    ipi6_addr:    in6_addr; /* src/dst IPv6 address */
+    ipi6_ifindex: u32; /* send/recv interface index */
+}
+
+/* IPv6 MTU information.  */
+ip6_mtuinfo :: struct {
+    ip6m_addr: sockaddr_in6; /* dst address including zone ID */
+    ip6m_mtu:  u32; /* path MTU in host byte order */
+}
+
+/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
+inet6_option_space :: (__nbytes: s32) -> s32 #foreign libc;
+
+inet6_option_init :: (__bp: *void, __cmsgp: **cmsghdr, __type: s32) -> s32 #foreign libc;
+
+inet6_option_append :: (__cmsg: *cmsghdr, __typep: *u8, __multx: s32, __plusy: s32) -> s32 #foreign libc;
+
+inet6_option_alloc :: (__cmsg: *cmsghdr, __datalen: s32, __multx: s32, __plusy: s32) -> *u8 #foreign libc;
+
+inet6_option_next :: (__cmsg: *cmsghdr, __tptrp: **u8) -> s32 #foreign libc;
+
+inet6_option_find :: (__cmsg: *cmsghdr, __tptrp: **u8, __type: s32) -> s32 #foreign libc;
+
+/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
+inet6_opt_init :: (__extbuf: *void, __extlen: socklen_t) -> s32 #foreign libc;
+inet6_opt_append :: (__extbuf: *void, __extlen: socklen_t, __offset: s32, __type: u8, __len: socklen_t, __align: u8, __databufp: **void) -> s32 #foreign libc;
+
+inet6_opt_finish :: (__extbuf: *void, __extlen: socklen_t, __offset: s32) -> s32 #foreign libc;
+
+inet6_opt_set_val :: (__databuf: *void, __offset: s32, __val: *void, __vallen: socklen_t) -> s32 #foreign libc;
+
+inet6_opt_next :: (__extbuf: *void, __extlen: socklen_t, __offset: s32, __typep: *u8, __lenp: *socklen_t, __databufp: **void) -> s32 #foreign libc;
+
+inet6_opt_find :: (__extbuf: *void, __extlen: socklen_t, __offset: s32, __type: u8, __lenp: *socklen_t, __databufp: **void) -> s32 #foreign libc;
+
+inet6_opt_get_val :: (__databuf: *void, __offset: s32, __val: *void, __vallen: socklen_t) -> s32 #foreign libc;
+
+/* Routing Header Option (RFC 3542).  */
+inet6_rth_space :: (__type: s32, __segments: s32) -> socklen_t #foreign libc;
+inet6_rth_init :: (__bp: *void, __bp_len: socklen_t, __type: s32, __segments: s32) -> *void #foreign libc;
+
+inet6_rth_add :: (__bp: *void, __addr: *in6_addr) -> s32 #foreign libc;
+inet6_rth_reverse :: (__in: *void, __out: *void) -> s32 #foreign libc;
+inet6_rth_segments :: (__bp: *void) -> s32 #foreign libc;
+inet6_rth_getaddr :: (__bp: *void, __index: s32) -> *in6_addr #foreign libc;
+
+/* Get IPv4 source filter.  */
+getipv4sourcefilter :: (__s: s32, __interface_addr: in_addr, __group: in_addr, __fmode: *u32, __numsrc: *u32, __slist: *in_addr) -> s32 #foreign libc;
+
+/* Set IPv4 source filter.  */
+setipv4sourcefilter :: (__s: s32, __interface_addr: in_addr, __group: in_addr, __fmode: u32, __numsrc: u32, __slist: *in_addr) -> s32 #foreign libc;
+
+/* Get source filter.  */
+getsourcefilter :: (__s: s32, __interface_addr: u32, __group: *sockaddr, __grouplen: socklen_t, __fmode: *u32, __numsrc: *u32, __slist: *sockaddr_storage) -> s32 #foreign libc;
+
+/* Set source filter.  */
+setsourcefilter :: (__s: s32, __interface_addr: u32, __group: *sockaddr, __grouplen: socklen_t, __fmode: u32, __numsrc: u32, __slist: *sockaddr_storage) -> s32 #foreign libc;
+
+tcp_seq :: u32;
+
+/*
+* TCP header.
+* Per RFC 793, September, 1981.
+*/
+tcphdr :: struct {
+    union {
+        struct {
+            th_sport: u16; /* source port */
+            th_dport: u16; /* destination port */
+            th_seq:   tcp_seq; /* sequence number */
+            th_ack:   tcp_seq; /* acknowledgement number */
+
+            th_x2:    u8; /* (unused) */
+            #place th_x2; /*bitfield 4*/ th_off:   u8; /* data offset */
+
+            th_flags: u8;
+
+            th_win:   u16; /* window */
+            th_sum:   u16; /* checksum */
+            th_urp:   u16; /* urgent pointer */
+        }
+
+        struct {
+            source:  u16;
+            dest:    u16;
+            seq:     u32;
+            ack_seq: u32;
+
+            res1:    u16;
+            #place res1; /*bitfield 4*/ doff:    u16;
+            #place res1; /*bitfield 8*/ fin:     u16;
+            #place res1; /*bitfield 9*/ syn:     u16;
+            #place res1; /*bitfield 10*/ rst:     u16;
+            #place res1; /*bitfield 11*/ psh:     u16;
+            #place res1; /*bitfield 12*/ ack:     u16;
+            #place res1; /*bitfield 13*/ urg:     u16;
+            #place res1; /*bitfield 14*/ res2:    u16;
+
+            window:  u16;
+            check:   u16;
+            urg_ptr: u16;
+        }
+    }
+}
+
+TCP :: enum u32 {
+    ESTABLISHED :: 1;
+    SYN_SENT    :: 2;
+    SYN_RECV    :: 3;
+    FIN_WAIT1   :: 4;
+    FIN_WAIT2   :: 5;
+    TIME_WAIT   :: 6;
+    CLOSE       :: 7;
+    CLOSE_WAIT  :: 8;
+    LAST_ACK    :: 9;
+    LISTEN      :: 10;
+    CLOSING     :: 11;
+
+    TCP_ESTABLISHED :: ESTABLISHED;
+    TCP_SYN_SENT    :: SYN_SENT;
+    TCP_SYN_RECV    :: SYN_RECV;
+    TCP_FIN_WAIT1   :: FIN_WAIT1;
+    TCP_FIN_WAIT2   :: FIN_WAIT2;
+    TCP_TIME_WAIT   :: TIME_WAIT;
+    TCP_CLOSE       :: CLOSE;
+    TCP_CLOSE_WAIT  :: CLOSE_WAIT;
+    TCP_LAST_ACK    :: LAST_ACK;
+    TCP_LISTEN      :: LISTEN;
+    TCP_CLOSING     :: CLOSING;
+}
+
+/* Values for tcpi_state.  */
+tcp_ca_state :: enum u32 {
+    Open     :: 0;
+    Disorder :: 1;
+    CWR      :: 2;
+    Recovery :: 3;
+    Loss     :: 4;
+
+    TCP_CA_Open     :: Open;
+    TCP_CA_Disorder :: Disorder;
+    TCP_CA_CWR      :: CWR;
+    TCP_CA_Recovery :: Recovery;
+    TCP_CA_Loss     :: Loss;
+}
+
+tcp_info :: struct {
+    tcpi_state:          u8;
+    tcpi_ca_state:       u8;
+    tcpi_retransmits:    u8;
+    tcpi_probes:         u8;
+    tcpi_backoff:        u8;
+    tcpi_options:        u8;
+    tcpi_snd_wscale:     u8;
+    #place tcpi_snd_wscale; /*bitfield 4*/ tcpi_rcv_wscale:     u8;
+
+    tcpi_rto:            u32;
+    tcpi_ato:            u32;
+    tcpi_snd_mss:        u32;
+    tcpi_rcv_mss:        u32;
+
+    tcpi_unacked:        u32;
+    tcpi_sacked:         u32;
+    tcpi_lost:           u32;
+    tcpi_retrans:        u32;
+    tcpi_fackets:        u32;
+
+    /* Times. */
+    tcpi_last_data_sent: u32;
+    tcpi_last_ack_sent:  u32; /* Not remembered, sorry.  */
+    tcpi_last_data_recv: u32;
+    tcpi_last_ack_recv:  u32;
+
+    /* Metrics. */
+    tcpi_pmtu:           u32;
+    tcpi_rcv_ssthresh:   u32;
+    tcpi_rtt:            u32;
+    tcpi_rttvar:         u32;
+    tcpi_snd_ssthresh:   u32;
+    tcpi_snd_cwnd:       u32;
+    tcpi_advmss:         u32;
+    tcpi_reordering:     u32;
+
+    tcpi_rcv_rtt:        u32;
+    tcpi_rcv_space:      u32;
+
+    tcpi_total_retrans:  u32;
+}
+
+tcp_md5sig :: struct {
+    tcpm_addr:      sockaddr_storage; /* Address associated.  */
+    tcpm_flags:     u8; /* Extension flags.  */
+    tcpm_prefixlen: u8; /* Address prefix.  */
+    tcpm_keylen:    u16; /* Key length.  */
+    __tcpm_pad:     u32; /* Zero.  */
+    tcpm_key:       [80] u8; /* Key (binary).  */
+}
+
+/* For socket repair options.  */
+tcp_repair_opt :: struct {
+    opt_code: u32;
+    opt_val:  u32;
+}
+
+/* Queue to repair, for TCP_REPAIR_QUEUE.  */
+TCP_1 :: enum u32 {
+    NO_QUEUE   :: 0;
+    RECV_QUEUE :: 1;
+    SEND_QUEUE :: 2;
+    QUEUES_NR  :: 3;
+
+    TCP_NO_QUEUE   :: NO_QUEUE;
+    TCP_RECV_QUEUE :: RECV_QUEUE;
+    TCP_SEND_QUEUE :: SEND_QUEUE;
+    TCP_QUEUES_NR  :: QUEUES_NR;
+}
+
+tcp_cookie_transactions :: struct {
+    tcpct_flags:          u16;
+    __tcpct_pad1:         u8;
+    tcpct_cookie_desired: u8;
+    tcpct_s_data_desired: u16;
+    tcpct_used:           u16;
+    tcpct_value:          [536] u8;
+}
+
+/* For use with TCP_REPAIR_WINDOW.  */
+tcp_repair_window :: struct {
+    snd_wl1:    u32;
+    snd_wnd:    u32;
+    max_window: u32;
+    rcv_wnd:    u32;
+    rcv_wup:    u32;
+}
+
+/* For use with TCP_ZEROCOPY_RECEIVE.  */
+tcp_zerocopy_receive :: struct {
+    address:        u64; /* In: address of mapping.  */
+    length:         u32; /* In/out: number of bytes to map/mapped.  */
+    recv_skip_hint: u32; /* Out: amount of bytes to skip.  */
+}
+
+netent :: struct {
+    n_name:     *u8;
+    n_aliases:  **u8;
+    n_addrtype: s32;
+    n_net:      u32;
+}
+
+/* Function to get address of global `h_errno' variable.  */
+__h_errno_location :: () -> *s32 #foreign libc;
+
+/* Print error indicated by `h_errno' variable on standard error.  STR
+if non-null is printed before the error string.  */
+herror :: (__str: *u8) -> void #foreign libc;
+
+/* Return string associated with error ERR_NUM.  */
+hstrerror :: (__err_num: s32) -> *u8 #foreign libc;
+
+/* Description of data base entry for a single host.  */
+hostent :: struct {
+    h_name:      *u8; /* Official name of host.  */
+    h_aliases:   **u8; /* Alias list.  */
+    h_addrtype:  s32; /* Host address type.  */
+    h_length:    s32; /* Length of address.  */
+    h_addr_list: **u8; /* List of addresses from name server.  */
+}
+
+/* Open host data base files and mark them as staying open even after
+a later search if STAY_OPEN is non-zero.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+sethostent :: (__stay_open: s32) -> void #foreign libc;
+
+/* Close host data base files and clear `stay open' flag.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+endhostent :: () -> void #foreign libc;
+
+/* Get next entry from host data base file.  Open data base if
+necessary.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+gethostent :: () -> *hostent #foreign libc;
+
+/* Return entry from host data base which address match ADDR with
+length LEN and type TYPE.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+gethostbyaddr :: (__addr: *void, __len: u32, __type: s32) -> *hostent #foreign libc;
+
+/* Return entry from host data base for host with NAME.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+gethostbyname :: (__name: *u8) -> *hostent #foreign libc;
+
+/* Return entry from host data base for host with NAME.  AF must be
+set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
+for IPv6.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+gethostbyname2 :: (__name: *u8, __af: s32) -> *hostent #foreign libc;
+
+/* Reentrant versions of the functions above.  The additional
+arguments specify a buffer of BUFLEN starting at BUF.  The last
+argument is a pointer to a variable which gets the value which
+would be stored in the global variable `herrno' by the
+non-reentrant functions.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+gethostent_r :: (__result_buf: *hostent, __buf: *u8, __buflen: u64, __result: **hostent, __h_errnop: *s32) -> s32 #foreign libc;
+
+gethostbyaddr_r :: (__addr: *void, __len: u32, __type: s32, __result_buf: *hostent, __buf: *u8, __buflen: u64, __result: **hostent, __h_errnop: *s32) -> s32 #foreign libc;
+
+gethostbyname_r :: (__name: *u8, __result_buf: *hostent, __buf: *u8, __buflen: u64, __result: **hostent, __h_errnop: *s32) -> s32 #foreign libc;
+
+gethostbyname2_r :: (__name: *u8, __af: s32, __result_buf: *hostent, __buf: *u8, __buflen: u64, __result: **hostent, __h_errnop: *s32) -> s32 #foreign libc;
+
+/* Open network data base files and mark them as staying open even
+after a later search if STAY_OPEN is non-zero.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+setnetent :: (__stay_open: s32) -> void #foreign libc;
+
+/* Close network data base files and clear `stay open' flag.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+endnetent :: () -> void #foreign libc;
+
+/* Get next entry from network data base file.  Open data base if
+necessary.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getnetent :: () -> *netent #foreign libc;
+
+/* Return entry from network data base which address match NET and
+type TYPE.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getnetbyaddr :: (__net: u32, __type: s32) -> *netent #foreign libc;
+
+/* Return entry from network data base for network with NAME.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getnetbyname :: (__name: *u8) -> *netent #foreign libc;
+
+/* Reentrant versions of the functions above.  The additional
+arguments specify a buffer of BUFLEN starting at BUF.  The last
+argument is a pointer to a variable which gets the value which
+would be stored in the global variable `herrno' by the
+non-reentrant functions.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+getnetent_r :: (__result_buf: *netent, __buf: *u8, __buflen: u64, __result: **netent, __h_errnop: *s32) -> s32 #foreign libc;
+
+getnetbyaddr_r :: (__net: u32, __type: s32, __result_buf: *netent, __buf: *u8, __buflen: u64, __result: **netent, __h_errnop: *s32) -> s32 #foreign libc;
+
+getnetbyname_r :: (__name: *u8, __result_buf: *netent, __buf: *u8, __buflen: u64, __result: **netent, __h_errnop: *s32) -> s32 #foreign libc;
+
+/* Description of data base entry for a single service.  */
+servent :: struct {
+    s_name:    *u8; /* Official service name.  */
+    s_aliases: **u8; /* Alias list.  */
+    s_port:    s32; /* Port number.  */
+    s_proto:   *u8; /* Protocol to use.  */
+}
+
+/* Open service data base files and mark them as staying open even
+after a later search if STAY_OPEN is non-zero.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+setservent :: (__stay_open: s32) -> void #foreign libc;
+
+/* Close service data base files and clear `stay open' flag.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+endservent :: () -> void #foreign libc;
+
+/* Get next entry from service data base file.  Open data base if
+necessary.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getservent :: () -> *servent #foreign libc;
+
+/* Return entry from network data base for network with NAME and
+protocol PROTO.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getservbyname :: (__name: *u8, __proto: *u8) -> *servent #foreign libc;
+
+/* Return entry from service data base which matches port PORT and
+protocol PROTO.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getservbyport :: (__port: s32, __proto: *u8) -> *servent #foreign libc;
+
+/* Reentrant versions of the functions above.  The additional
+arguments specify a buffer of BUFLEN starting at BUF.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+getservent_r :: (__result_buf: *servent, __buf: *u8, __buflen: u64, __result: **servent) -> s32 #foreign libc;
+
+getservbyname_r :: (__name: *u8, __proto: *u8, __result_buf: *servent, __buf: *u8, __buflen: u64, __result: **servent) -> s32 #foreign libc;
+
+getservbyport_r :: (__port: s32, __proto: *u8, __result_buf: *servent, __buf: *u8, __buflen: u64, __result: **servent) -> s32 #foreign libc;
+
+/* Description of data base entry for a single service.  */
+protoent :: struct {
+    p_name:    *u8; /* Official protocol name.  */
+    p_aliases: **u8; /* Alias list.  */
+    p_proto:   s32; /* Protocol number.  */
+}
+
+/* Open protocol data base files and mark them as staying open even
+after a later search if STAY_OPEN is non-zero.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+setprotoent :: (__stay_open: s32) -> void #foreign libc;
+
+/* Close protocol data base files and clear `stay open' flag.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+endprotoent :: () -> void #foreign libc;
+
+/* Get next entry from protocol data base file.  Open data base if
+necessary.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getprotoent :: () -> *protoent #foreign libc;
+
+/* Return entry from protocol data base for network with NAME.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getprotobyname :: (__name: *u8) -> *protoent #foreign libc;
+
+/* Return entry from protocol data base which number is PROTO.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getprotobynumber :: (__proto: s32) -> *protoent #foreign libc;
+
+/* Reentrant versions of the functions above.  The additional
+arguments specify a buffer of BUFLEN starting at BUF.
+
+These functions are not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation they are cancellation points and
+therefore not marked with __THROW.  */
+getprotoent_r :: (__result_buf: *protoent, __buf: *u8, __buflen: u64, __result: **protoent) -> s32 #foreign libc;
+
+getprotobyname_r :: (__name: *u8, __result_buf: *protoent, __buf: *u8, __buflen: u64, __result: **protoent) -> s32 #foreign libc;
+
+getprotobynumber_r :: (__proto: s32, __result_buf: *protoent, __buf: *u8, __buflen: u64, __result: **protoent) -> s32 #foreign libc;
+
+/* Establish network group NETGROUP for enumeration.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+setnetgrent :: (__netgroup: *u8) -> s32 #foreign libc;
+
+/* Free all space allocated by previous `setnetgrent' call.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+endnetgrent :: () -> void #foreign libc;
+
+/* Get next member of netgroup established by last `setnetgrent' call
+and return pointers to elements in HOSTP, USERP, and DOMAINP.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getnetgrent :: (__hostp: **u8, __userp: **u8, __domainp: **u8) -> s32 #foreign libc;
+
+/* Test whether NETGROUP contains the triple (HOST,USER,DOMAIN).
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+innetgr :: (__netgroup: *u8, __host: *u8, __user: *u8, __domain: *u8) -> s32 #foreign libc;
+
+/* Reentrant version of `getnetgrent' where result is placed in BUFFER.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getnetgrent_r :: (__hostp: **u8, __userp: **u8, __domainp: **u8, __buffer: *u8, __buflen: u64) -> s32 #foreign libc;
+
+/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
+The local user is LOCUSER, on the remote machine the command is
+executed as REMUSER.  In *FD2P the descriptor to the socket for the
+connection is returned.  The caller must have the right to use a
+reserved port.  When the function returns *AHOST contains the
+official host name.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rcmd :: (__ahost: **u8, __rport: u16, __locuser: *u8, __remuser: *u8, __cmd: *u8, __fd2p: *s32) -> s32 #foreign libc;
+
+/* This is the equivalent function where the protocol can be selected
+and which therefore can be used for IPv6.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rcmd_af :: (__ahost: **u8, __rport: u16, __locuser: *u8, __remuser: *u8, __cmd: *u8, __fd2p: *s32, __af: sa_family_t) -> s32 #foreign libc;
+
+/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
+CMD.  The process runs at the remote machine using the ID of user
+NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
+to the socket for the connection is returned.  When the function
+returns *AHOST contains the official host name.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rexec :: (__ahost: **u8, __rport: s32, __name: *u8, __pass: *u8, __cmd: *u8, __fd2p: *s32) -> s32 #foreign libc;
+
+/* This is the equivalent function where the protocol can be selected
+and which therefore can be used for IPv6.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rexec_af :: (__ahost: **u8, __rport: s32, __name: *u8, __pass: *u8, __cmd: *u8, __fd2p: *s32, __af: sa_family_t) -> s32 #foreign libc;
+
+/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
+If SUSER is not zero the user tries to become superuser.  Return 0 if
+it is possible.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+ruserok :: (__rhost: *u8, __suser: s32, __remuser: *u8, __locuser: *u8) -> s32 #foreign libc;
+
+/* This is the equivalent function where the protocol can be selected
+and which therefore can be used for IPv6.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+ruserok_af :: (__rhost: *u8, __suser: s32, __remuser: *u8, __locuser: *u8, __af: sa_family_t) -> s32 #foreign libc;
+
+/* Check whether user REMUSER on system indicated by IPv4 address
+RADDR is allowed to login as LOCUSER.  Non-IPv4 (e.g., IPv6) are
+not supported.  If SUSER is not zero the user tries to become
+superuser.  Return 0 if it is possible.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+iruserok :: (__raddr: u32, __suser: s32, __remuser: *u8, __locuser: *u8) -> s32 #foreign libc;
+
+/* This is the equivalent function where the pfamiliy if the address
+pointed to by RADDR is determined by the value of AF.  It therefore
+can be used for IPv6
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+iruserok_af :: (__raddr: *void, __suser: s32, __remuser: *u8, __locuser: *u8, __af: sa_family_t) -> s32 #foreign libc;
+
+/* Try to allocate reserved port, returning a descriptor for a socket opened
+at this port or -1 if unsuccessful.  The search for an available port
+will start at ALPORT and continues with lower numbers.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rresvport :: (__alport: *s32) -> s32 #foreign libc;
+
+/* This is the equivalent function where the protocol can be selected
+and which therefore can be used for IPv6.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+rresvport_af :: (__alport: *s32, __af: sa_family_t) -> s32 #foreign libc;
+
+/* Structure to contain information about address of a service provider.  */
+addrinfo :: struct {
+    ai_flags:     AI; /* Input flags.  */
+    ai_family:    s32; /* Protocol family for socket.  */
+    ai_socktype:  SOCK; /* Socket type.  */
+    ai_protocol:  IPPROTO; /* Protocol for socket.  */
+    ai_addrlen:   socklen_t; /* Length of socket address.  */
+    ai_addr:      *sockaddr; /* Socket address for socket.  */
+    ai_canonname: *u8; /* Canonical name for service location.  */
+    ai_next:      *addrinfo; /* Pointer to next in list.  */
+}
+
+/* Structure used as control block for asynchronous lookup.  */
+gaicb :: struct {
+    ar_name:          *u8; /* Name to look up.  */
+    ar_service:       *u8; /* Service name.  */
+    ar_request:       *addrinfo; /* Additional request specification.  */
+    ar_result:        *addrinfo; /* Pointer to result.  */
+
+    /* The following are internal elements.  */
+    __return:         s32;
+    __glibc_reserved: [5] s32;
+}
+
+/* Translate name of a service location and/or a service name to set of
+socket addresses.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getaddrinfo :: (__name: *u8, __service: *u8, __req: *addrinfo, __pai: **addrinfo) -> s32 #foreign libc;
+
+/* Free `addrinfo' structure AI including associated storage.  */
+freeaddrinfo :: (__ai: *addrinfo) -> void #foreign libc;
+
+/* Convert error return from getaddrinfo() to a string.  */
+gai_strerror :: (__ecode: s32) -> *u8 #foreign libc;
+
+/* Translate a socket address to a location and service name.
+
+This function is a possible cancellation point and therefore not
+marked with __THROW.  */
+getnameinfo :: (__sa: *sockaddr, __salen: socklen_t, __host: *u8, __hostlen: socklen_t, __serv: *u8, __servlen: socklen_t, __flags: s32) -> s32 #foreign libc;
+
+/* Enqueue ENT requests from the LIST.  If MODE is GAI_WAIT wait until all
+requests are handled.  If WAIT is GAI_NOWAIT return immediately after
+queueing the requests and signal completion according to SIG.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+getaddrinfo_a :: (__mode: s32, __list: **gaicb, __ent: s32, __sig: *sigevent) -> s32 #foreign libc;
+
+/* Suspend execution of the thread until at least one of the ENT requests
+in LIST is handled.  If TIMEOUT is not a null pointer it specifies the
+longest time the function keeps waiting before returning with an error.
+
+This function is not part of POSIX and therefore no official
+cancellation point.  But due to similarity with an POSIX interface
+or due to the implementation it is a cancellation point and
+therefore not marked with __THROW.  */
+gai_suspend :: (__list: **gaicb, __ent: s32, __timeout: *timespec) -> s32 #foreign libc;
+
+/* Get the error status of the request REQ.  */
+gai_error :: (__req: *gaicb) -> s32 #foreign libc;
+
+/* Cancel the requests associated with GAICBP.  */
+gai_cancel :: (__gaicbp: *gaicb) -> s32 #foreign libc;
+
+/* Convert Internet host address from numbers-and-dots notation in CP
+into binary data in network byte order.  */
+inet_addr :: (__cp: *u8) -> in_addr_t #foreign libc;
+
+/* Return the local host address part of the Internet address in IN.  */
+inet_lnaof :: (__in: in_addr) -> in_addr_t #foreign libc;
+
+/* Make Internet host address in network byte order by combining the
+network number NET with the local address HOST.  */
+inet_makeaddr :: (__net: in_addr_t, __host: in_addr_t) -> in_addr #foreign libc;
+
+/* Return network number part of the Internet address IN.  */
+inet_netof :: (__in: in_addr) -> in_addr_t #foreign libc;
+
+/* Extract the network number in network byte order from the address
+in numbers-and-dots natation starting at CP.  */
+inet_network :: (__cp: *u8) -> in_addr_t #foreign libc;
+
+/* Convert Internet number in IN to ASCII representation.  The return value
+is a pointer to an internal array containing the string.  */
+inet_ntoa :: (__in: in_addr) -> *u8 #foreign libc;
+
+/* Convert from presentation format of an Internet number in buffer
+starting at CP to the binary network format and store result for
+interface type AF in buffer starting at BUF.  */
+inet_pton :: (__af: s32, __cp: *u8, __buf: *void) -> s32 #foreign libc;
+
+/* Convert a Internet address in binary network format for interface
+type AF in buffer starting at CP to presentation form and place
+result in buffer of length LEN astarting at BUF.  */
+inet_ntop :: (__af: s32, __cp: *void, __buf: *u8, __len: socklen_t) -> *u8 #foreign libc;
+
+/* Convert Internet host address from numbers-and-dots notation in CP
+into binary data and store the result in the structure INP.  */
+inet_aton :: (__cp: *u8, __inp: *in_addr) -> s32 #foreign libc;
+
+/* Convert ASCII representation in hexadecimal form of the Internet
+address to binary form and place result in buffer of length LEN
+starting at BUF.  */
+inet_nsap_addr :: (__cp: *u8, __buf: *u8, __len: s32) -> u32 #foreign libc;
+
+/* Convert internet address in binary form in LEN bytes starting at CP
+a presentation form and place result in BUF.  */
+inet_nsap_ntoa :: (__len: s32, __cp: *u8, __buf: *u8) -> *u8 #foreign libc;
+
+if_nameindex :: struct {
+    if_index: u32; /* 1, 2, ... */
+    if_name:  *u8; /* null terminated name: "eth0", ... */
+}
+
+/* Standard interface flags. */
+IFF :: enum u32 {
+    UP          :: 1;
+
+    BROADCAST   :: 2;
+
+    DEBUG       :: 4;
+
+    LOOPBACK    :: 8;
+
+    POINTOPOINT :: 16;
+
+    NOTRAILERS  :: 32;
+
+    RUNNING     :: 64;
+
+    NOARP       :: 128;
+
+    PROMISC     :: 256;
+
+    ALLMULTI    :: 512;
+
+    MASTER      :: 1024;
+
+    SLAVE       :: 2048;
+
+    MULTICAST   :: 4096;
+
+    PORTSEL     :: 8192;
+
+    AUTOMEDIA   :: 16384;
+
+    DYNAMIC     :: 32768;
+
+    IFF_UP          :: UP;
+
+    IFF_BROADCAST   :: BROADCAST;
+
+    IFF_DEBUG       :: DEBUG;
+
+    IFF_LOOPBACK    :: LOOPBACK;
+
+    IFF_POINTOPOINT :: POINTOPOINT;
+
+    IFF_NOTRAILERS  :: NOTRAILERS;
+
+    IFF_RUNNING     :: RUNNING;
+
+    IFF_NOARP       :: NOARP;
+
+    IFF_PROMISC     :: PROMISC;
+
+    IFF_ALLMULTI    :: ALLMULTI;
+
+    IFF_MASTER      :: MASTER;
+
+    IFF_SLAVE       :: SLAVE;
+
+    IFF_MULTICAST   :: MULTICAST;
+
+    IFF_PORTSEL     :: PORTSEL;
+
+    IFF_AUTOMEDIA   :: AUTOMEDIA;
+
+    IFF_DYNAMIC     :: DYNAMIC;
+}
+
+/* The ifaddr structure contains information about one address of an
+interface.  They are maintained by the different address families,
+are allocated and attached when an address is set, and are linked
+together so all addresses for an interface can be located.  */
+ifaddr :: struct {
+    ifa_addr: sockaddr; /* Address of interface.  */
+    ifa_ifu:  union {
+        ifu_broadaddr: sockaddr;
+        ifu_dstaddr:   sockaddr;
+    };
+
+    iface :: struct {}
+    ifa_ifp:  *iface; /* Back-pointer to interface.  */
+    ifa_next: *ifaddr; /* Next address for interface.  */
+}
+
+/* Device mapping structure. I'd just gone off and designed a
+beautiful scheme using only loadable modules with arguments for
+driver options and along come the PCMCIA people 8)
+
+Ah well. The get() side of this is good for WDSETUP, and it'll be
+handy for debugging things. The set side is fine for now and being
+very small might be worth keeping for clean configuration.  */
+ifmap :: struct {
+    mem_start: u64;
+    mem_end:   u64;
+    base_addr: u16;
+    irq:       u8;
+    dma:       u8;
+    port:      u8;
+}
+
+/* Interface request structure used for socket ioctl's.  All interface
+ioctl's must have parameter definitions which begin with ifr_name.
+The remainder may be interface specific.  */
+ifreq :: struct {
+    ifr_ifrn: union {
+        ifrn_name: [16] u8; /* Interface name, e.g. "en0".  */
+    };
+
+    ifr_ifru: union {
+        ifru_addr:      sockaddr;
+        ifru_dstaddr:   sockaddr;
+        ifru_broadaddr: sockaddr;
+        ifru_netmask:   sockaddr;
+        ifru_hwaddr:    sockaddr;
+        ifru_flags:     s16;
+        ifru_ivalue:    s32;
+        ifru_mtu:       s32;
+        ifru_map:       ifmap;
+        ifru_slave:     [16] u8; /* Just fits the size */
+        ifru_newname:   [16] u8;
+        ifru_data:      *u8;
+    };
+}
+
+/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
+configuration for machine (useful for programs which must know all
+networks accessible).  */
+ifconf :: struct {
+    ifc_len:  s32; /* Size of buffer.  */
+    ifc_ifcu: union {
+        ifcu_buf: *u8;
+        ifcu_req: *ifreq;
+    };
+}
+
+/* Convert an interface name to an index, and vice versa.  */
+if_nametoindex :: (__ifname: *u8) -> u32 #foreign libc;
+if_indextoname :: (__ifindex: u32, __ifname: *[16] u8) -> *u8 #foreign libc;
+
+/* Return a list of all interfaces and their indices.  */
+if_nameindex_ :: () -> *if_nameindex #foreign libc "if_nameindex";
+
+/* Free the data returned from if_nameindex.  */
+if_freenameindex :: (__ptr: *if_nameindex) -> void #foreign libc;
+
+/* The `getifaddrs' function generates a linked list of these structures.
+Each element of the list describes one network interface.  */
+ifaddrs :: struct {
+    ifa_next:    *ifaddrs; /* Pointer to the next structure.  */
+
+    ifa_name:    *u8; /* Name of this network interface.  */
+    ifa_flags:   u32; /* Flags as from SIOCGIFFLAGS ioctl.  */
+
+    ifa_addr:    *sockaddr; /* Network address of this interface.  */
+    ifa_netmask: *sockaddr; /* Netmask of this interface.  */
+    ifa_ifu:     union {
+        ifu_broadaddr: *sockaddr; /* Broadcast address of this interface. */
+        ifu_dstaddr:   *sockaddr; /* Point-to-point destination address.  */
+    };
+
+    ifa_data:    *void; /* Address-specific data (may be unused).  */
+}
+
+/* Create a linked list of `struct ifaddrs' structures, one for each
+network interface on the host machine.  If successful, store the
+list in *IFAP and return 0.  On errors, return -1 and set `errno'.
+
+The storage returned in *IFAP is allocated dynamically and can
+only be properly freed by passing it to `freeifaddrs'.  */
+getifaddrs :: (__ifap: **ifaddrs) -> s32 #foreign libc;
+
+/* Reclaim the storage allocated by a previous `getifaddrs' call.  */
+freeifaddrs :: (__ifa: *ifaddrs) -> void #foreign libc;
+
+#scope_file
+
+libc :: #library,system "libc";
diff --git a/modules/Socket/module.jai b/modules/Socket/module.jai
index b5766ca..1eb3afb 100644
--- a/modules/Socket/module.jai
+++ b/modules/Socket/module.jai
@@ -516,7 +516,12 @@ close_and_reset :: (s: *Socket, loc := #caller_location) {
 #if OS == .WINDOWS {
     #load "generated_windows.jai";
 } else #if OS == .LINUX {
-    #load "generated_linux.jai";
+    #if CPU == .ARM64 {
+        #load "generated_linux_arm64.jai";
+    }
+    else {
+        #load "generated_linux.jai";
+    }
 } else #if OS == .ANDROID {
     #load "generated_android.jai";
 } else #if OS == .MACOS {
diff --git a/modules/String/module.jai b/modules/String/module.jai
index 0ba95c6..7ba51e3 100644
--- a/modules/String/module.jai
+++ b/modules/String/module.jai
@@ -1559,7 +1559,7 @@ is_any :: (c: u8, chars:string) -> bool {
 
 #scope_module
 
-USE_SIMD   :: true;
+USE_SIMD   :: CPU == .X64;
 SIMD_WIDTH :: 16;
 
 Basic :: #import "Basic";
